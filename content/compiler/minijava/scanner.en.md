+++
title = "Lexical Analysis"
weight = 30
mathjax = true
+++

{{<mermaid align="center">}}
graph LR;
A[MiniJava source file] -->|characters| B(fa:fa-tools<br/> Lexical <br/> analysis)
B -->|tokens| C(fa:fa-tools <br/> Syntactic <br/> analysis)
C -->|abstract syntax tree| D(fa:fa-tools <br/> Typechecker)
D -->|abstract syntax tree| E(fa:fa-tools <br/> C code <br/> generator)
E -->|characters| F[C source file]
classDef green fill:#74B559,stroke:#222723,stroke-width:5px;
class B green
{{< /mermaid >}}

We will describe the MiniJava lexical analyzer, also called scanner, which will group the characters
of the source file into lexical units also called tokens. These lexical units will then be given to the syntactic analyzer in the following phase of the transpiler.\
Before describing the lexical analyzer of MiniJava, we will present regular expressions that will be used
to describe tokens. We will also study automata, a kind of graph, and use them to match regular expressions.
<a name="regular_expressions"></a>
## Regular Expressions
Regular expressions will allow us to describe succinctly and quite intuitively
the MiniJava lexical units and will be used in the `ocamllex` lexical analyzer generator that we
will be using in our transpiler.

A regular expression describes a set of words from a given vocabulary. We will take as an example
the vocabulary $\mathcal{V} = \\{0, 1\\}$ consisting simply of two elements: `0` and `1`. We describe below the basic elements and operators for creating regular expressions and the words that
they describe.

* Basic regular expressions:

 * The regular expression $\color{green}\epsilon$ generates the set containing only the empty word^[The empty word is the equivalent of the string `""`.]: $\\{\epsilon\\}$.
 * For $c \in \mathcal{V}$, the regular expression $\color{green}c$ represents the set containing a single word: $\\{c\\}$.

        | <center>Expression</center> | <center>Set of words</center> |
        | :----------------:          | :----------------:                |
        | $\color{green}0$            | $\\{0\\}$                         |
        | $\color{green}1$            | $\\{1\\}$                         |

* Compound regular expressions:

 * Parentheses can be used to group together regular expressions. Let $\color{green}{r}$ be a regular expression, then $\color{green}{\(r\)}$ represents the same set of
 words that the expression $\color{\green}{r}$.

        | <center>Expression</center> | <center>Set of words</center> |
        | :----------------:          | :----------------:                |
        | $\color{green}{(0)}$ | $\\{0\\}$ |

 * The concatenation operator allows to juxtapose the words generated by two regular expressions. Let $\color{green}{r\_1}$ and $\color{green}{r\_2}$ be two regular expressions.
 The concatenation of these two regular expressions is noted: $\color{green}{r\_1r\_2}$. The set of words described by this regular expression is
 the concatenation of the words described by $\color{green}{r\_1}$ with those described by $\color{green}{r\_2}$.\
 Note that this operator is associative, which means that for any
 regular expression $\color{green}{r\_1}$, $\color{green}{r\_2}$ and $\color{green}{r\_3}$, we have
 $\color{green}{(r\_1r\_2)r\_3} = \color{green}{r\_1(r\_2r\_3)}$ that we will simply write down as $\color{green}{r\_1r\_2r\_3}$.

        | <center>Expression</center> | <center>Set of words</center> |
        | :----------------:          | :----------------:                |
        | $\color{green}{\epsilon1}$  | $\\{1\\}$                         |
        | $\color{green}{10}$         | $\\{10\\}$                        |
        | $\color{green}{(10)1}$         | $\\{101\\}$                        |
        | $\color{green}{1(01)}$         | $\\{101\\}$                        |
        | $\color{green}{101}$         | $\\{101\\}$                        |

 * The union operator is used to get the union of the words generated by two regular expressions. Let $\color{green}{r\_1}$ and $\color{green}{r\_2}$ be two regular expressions.
 The union of these two regular expressions is noted: $\color{green}{r\_1\ |\ r\_2}$. The set of words described by this regular expression is
 the union of the words described by $\color{green}{r\_1}$ with those described by $\color{green}{r\_2}$.\
 Note that this operator is commutative, that is
 $\color{green}{r\_1\ |\ r\_2} = \color{green}{r\_2\ |\ r\_1}$. It's also associative, meaning that for every
 regular expression $\color{green}{r\_1}$, $\color{green}{r\_2}$ and $\color{green}{r\_3}$, we have
 $\color{green}{(r\_1\ |\ r\_2)\ |\ r\_3} = \color{green}{r\_1\ |\ (r\_2\ |\ r\_3)}$ that we will simply write down as $\color{green}{r\_1\ |\ r\_2\ |\ r\_3}$.

        | <center>Expression</center>  | <center>Set of words</center> |
        | :----------------:           | :----------------:                |
        | $\color{green}{\epsilon \\ \| \\ 1}$                            | $\\{\epsilon, 1\\}$ |
        | $\color{green}{(00) \\ \| \\ (10)}$                           | $\\{00, 10\\}$      |
        | $\color{green}{(10) \\ \| \\ (00)}$                           | $\\{00, 10\\}$      |
        | $\color{green}{(0 \\ \| \\ 1)\\ \|\\ (10)}$                           | $\\{0, 1, 10\\}$      |
        | $\color{green}{0\\ \|\\ (1 \\ \| \\ (10))}$                           | $\\{0, 1, 10\\}$      |
        | $\color{green}{0 \\ \| \\ 1\\ \|\\ (10)}$                           | $\\{0, 1, 10\\}$      |
        | $\color{green}{(0\\ \|\\ 1)(0\\ \|\\ 1)}$                           | $\\{00, 01, 10, 11\\}$      |

 * The iteration operator noted `*` allows to juxtapose $0$ or several times the words generated by a regular expression. Let $\color{green}{r}$ be a regular expression, then
 the regular expression $\color{green}{r^*}$ represents the hypothetical^[A regular expression must be of finite size.] regular expression
 $\color{\green}{\epsilon\ \|\ rr\ \|\ rrr\ \|\ rrrr\ \|\ \cdots}$.

        | <center>Expression</center> | <center>Set of words</center>          |
        | :----------------:          | :----------------:                         |
        | $\color{green}{0^*}$        | $\\{\epsilon, 0, 00, 000, 0000, \cdots\\}$ |
        | $\color{green}{(0\\ \| \\ 1)^*}$ | $\\{\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \cdots\\}$ |

 {{% notice note %}}
To avoid too many parentheses, there is a priority between the different operators: the parentheses have the highest priority,
then the $\color{green}{*}$ operator, then the concatenation operator and finally the $\color{green}{|}$ operator. We have also seen above that the operators
of concatenation and union are associative, which allows us to remove more brackets.
Thus, the regular expression $\color{green}{10^*1\ \|\ 11\ \|\ \epsilon}$ reads $\color{green}{(((1(0^ *))1)\ \|\ (11))\ \|\ \epsilon}$.
{{% /notice %}}

### Examples

We give below some examples of regular expressions still on the vocabulary $\mathcal{V} = \\{0, 1\\}$.

| <center>Description</center>                                       | <center>Expression</center>           | <center>Set of words</center> |
| :----------------:                                                 | :----------------:                    | :----------------:                |
| Binary numbers (without leading zeros)                  | $\color{green}{0\\ \| \\ 1(0\\ \| \\ 1)^*}$  | $\\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \cdots\\}$ |
| Odd binary numbers                                       | $\color{green}{1\\ \| \\ 1(0\\ \| \\ 1)^*1}$ | $\\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \cdots\\}$                 |
| Bit strings of even length containing only alternate zeros and ones | $\color{green}{(10)^* \\ \| \\ (01)^*}$  | $\\{\epsilon, 10, 01, 1010, 0101, 101010, 010101, \cdots\\}$                              |
| Bit strings whose length is a multiple of 3             | $\color{green}{((0\\ \| \\ 1)(0\\ \| \\ 1)(0\\ \| \\ 1))^*}$ | $\\{\epsilon, 000, 001, 010, 011, 100, \cdots, 111000, 111001, \cdots, 101011110, \cdots \\}$ |
| Bit strings that do not contain the sub-string $11$           | $\color{green}{0^* ( 100^* )^* (1\\ \| \\ \epsilon)}$ | $\\{\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \cdots\\}$ |

{{% notice info %}}
[You can have fun using regular expressions on Regex Crossword <i class="far fa-smile-beam"></i>.](https://regexcrossword.com/)
{{% /notice %}}

In the following video, we will formally define regular expressions and the languages they generate. We will also see how they are defined in
`ocamllex`.

{{<youtube 5VNKh7aaZ-g >}}

The following video will give examples of regular expressions found in MiniJava and show some extensions of regular expressions.

{{< youtube Wl8FXqv6dak >}}

## Automata

## Regular Expressions Matching

## Scanner with Ocamllex

## Questions

## Ressources
