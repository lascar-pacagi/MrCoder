+++
title = "Lexical Analysis"
weight = 30
mathjax = true
+++

{{<mermaid align="center">}}
graph LR;
A[MiniJava source file] -->|characters| B(fa:fa-tools<br/> Lexical <br/> analysis)
B -->|tokens| C(fa:fa-tools <br/> Syntactic <br/> analysis)
C -->|abstract syntax tree| D(fa:fa-tools <br/> Typechecker)
D -->|abstract syntax tree| E(fa:fa-tools <br/> C code <br/> generator)
E -->|characters| F[C source file]
classDef green fill:#74B559,stroke:#222723,stroke-width:5px;
class B green
{{< /mermaid >}}

We will describe the MiniJava lexical analyzer, also called scanner, which will group the characters
of the source file into lexical units also called tokens. These lexical units will then be given to the syntactic analyzer in the following phase of the transpiler.\
Before describing the lexical analyzer of MiniJava, we will present regular expressions that will be used
to describe tokens. We will also study automata, a kind of graph, and use them to match regular expressions.
<a name="regular_expressions"></a>
## Regular Expressions
Regular expressions will allow us to describe succinctly and quite intuitively
the MiniJava lexical units and will be used in the `ocamllex` lexical analyzer generator that we
will be using in our transpiler.

A regular expression describes a set of words from a given vocabulary. We will take as an example
the vocabulary $\mathcal{V} = \\{0, 1\\}$ consisting simply of two elements: `0` and `1`. We describe below the basic elements and operators for creating regular expressions and the words that
they describe.

* Basic regular expressions:

 * The regular expression $\color{green}\epsilon$ generates the set containing only the empty word^[The empty word is the equivalent of the string `""`.]: $\\{\epsilon\\}$.
 * For $c \in \mathcal{V}$, the regular expression $\color{green}c$ represents the set containing a single word: $\\{c\\}$.

        | <center>Expression</center> | <center>Set of words</center> |
        | :----------------:          | :----------------:                |
        | $\color{green}0$            | $\\{0\\}$                         |
        | $\color{green}1$            | $\\{1\\}$                         |

* Compound regular expressions:

 * Parentheses can be used to group together regular expressions. Let $\color{green}{r}$ be a regular expression, then $\color{green}{\(r\)}$ represents the same set of
 words that the expression $\color{\green}{r}$.

        | <center>Expression</center> | <center>Set of words</center> |
        | :----------------:          | :----------------:                |
        | $\color{green}{(0)}$ | $\\{0\\}$ |

 * The concatenation operator allows to juxtapose the words generated by two regular expressions. Let $\color{green}{r\_1}$ and $\color{green}{r\_2}$ be two regular expressions.
 The concatenation of these two regular expressions is noted: $\color{green}{r\_1r\_2}$. The set of words described by this regular expression is
 the concatenation of the words described by $\color{green}{r\_1}$ with those described by $\color{green}{r\_2}$.\
 Note that this operator is associative, which means that for any
 regular expression $\color{green}{r\_1}$, $\color{green}{r\_2}$ and $\color{green}{r\_3}$, we have
 $\color{green}{(r\_1r\_2)r\_3} = \color{green}{r\_1(r\_2r\_3)}$ that we will simply write down as $\color{green}{r\_1r\_2r\_3}$.

        | <center>Expression</center> | <center>Set of words</center> |
        | :----------------:          | :----------------:                |
        | $\color{green}{\epsilon1}$  | $\\{1\\}$                         |
        | $\color{green}{10}$         | $\\{10\\}$                        |
        | $\color{green}{(10)1}$         | $\\{101\\}$                        |
        | $\color{green}{1(01)}$         | $\\{101\\}$                        |
        | $\color{green}{101}$         | $\\{101\\}$                        |

 * The union operator is used to get the union of the words generated by two regular expressions. Let $\color{green}{r\_1}$ and $\color{green}{r\_2}$ be two regular expressions.
 The union of these two regular expressions is noted: $\color{green}{r\_1\ |\ r\_2}$. The set of words described by this regular expression is
 the union of the words described by $\color{green}{r\_1}$ with those described by $\color{green}{r\_2}$.\
 Note that this operator is commutative, that is
 $\color{green}{r\_1\ |\ r\_2} = \color{green}{r\_2\ |\ r\_1}$. It's also associative, meaning that for every
 regular expression $\color{green}{r\_1}$, $\color{green}{r\_2}$ and $\color{green}{r\_3}$, we have
 $\color{green}{(r\_1\ |\ r\_2)\ |\ r\_3} = \color{green}{r\_1\ |\ (r\_2\ |\ r\_3)}$ that we will simply write down as $\color{green}{r\_1\ |\ r\_2\ |\ r\_3}$.

        | <center>Expression</center>  | <center>Set of words</center> |
        | :----------------:           | :----------------:                |
        | $\color{green}{\epsilon \\ \| \\ 1}$                            | $\\{\epsilon, 1\\}$ |
        | $\color{green}{(00) \\ \| \\ (10)}$                           | $\\{00, 10\\}$      |
        | $\color{green}{(10) \\ \| \\ (00)}$                           | $\\{00, 10\\}$      |
        | $\color{green}{(0 \\ \| \\ 1)\\ \|\\ (10)}$                           | $\\{0, 1, 10\\}$      |
        | $\color{green}{0\\ \|\\ (1 \\ \| \\ (10))}$                           | $\\{0, 1, 10\\}$      |
        | $\color{green}{0 \\ \| \\ 1\\ \|\\ (10)}$                           | $\\{0, 1, 10\\}$      |
        | $\color{green}{(0\\ \|\\ 1)(0\\ \|\\ 1)}$                           | $\\{00, 01, 10, 11\\}$      |

 * The iteration operator noted `*` allows to juxtapose $0$ or several times the words generated by a regular expression. Let $\color{green}{r}$ be a regular expression, then
 the regular expression $\color{green}{r^*}$ represents the hypothetical^[A regular expression must be of finite size.] regular expression
 $\color{\green}{\epsilon\ \|\ rr\ \|\ rrr\ \|\ rrrr\ \|\ \cdots}$.

        | <center>Expression</center> | <center>Set of words</center>          |
        | :----------------:          | :----------------:                         |
        | $\color{green}{0^*}$        | $\\{\epsilon, 0, 00, 000, 0000, \cdots\\}$ |
        | $\color{green}{(0\\ \| \\ 1)^*}$ | $\\{\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \cdots\\}$ |

 {{% notice note %}}
To avoid too many parentheses, there is a priority between the different operators: the parentheses have the highest priority,
then the $\color{green}{*}$ operator, then the concatenation operator and finally the $\color{green}{|}$ operator. We have also seen above that the operators
of concatenation and union are associative, which allows us to remove more brackets.
Thus, the regular expression $\color{green}{10^*1\ \|\ 11\ \|\ \epsilon}$ reads $\color{green}{(((1(0^ *))1)\ \|\ (11))\ \|\ \epsilon}$.
{{% /notice %}}

### Examples

We give below some examples of regular expressions still on the vocabulary $\mathcal{V} = \\{0, 1\\}$.

| <center>Description</center>                                       | <center>Expression</center>           | <center>Set of words</center> |
| :----------------:                                                 | :----------------:                    | :----------------:                |
| Binary numbers (without leading zeros)                  | $\color{green}{0\\ \| \\ 1(0\\ \| \\ 1)^*}$  | $\\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \cdots\\}$ |
| Odd binary numbers                                       | $\color{green}{1\\ \| \\ 1(0\\ \| \\ 1)^*1}$ | $\\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \cdots\\}$                 |
| Bit strings of even length containing alternating zeros and ones | $\color{green}{(10)^* \\ \| \\ (01)^*}$  | $\\{\epsilon, 10, 01, 1010, 0101, 101010, 010101, \cdots\\}$                              |
| Bit strings whose length is a multiple of 3             | $\color{green}{((0\\ \| \\ 1)(0\\ \| \\ 1)(0\\ \| \\ 1))^*}$ | $\\{\epsilon, 000, 001, 010, 011, 100, \cdots, 111000, 111001, \cdots, 101011110, \cdots \\}$ |
| Bit strings that do not contain the sub-string $11$           | $\color{green}{0^* ( 100^* )^* (1\\ \| \\ \epsilon)}$ | $\\{\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \cdots\\}$ |

{{% notice info %}}
[You can have fun using regular expressions on Regex Crossword <i class="far fa-smile-beam"></i>.](https://regexcrossword.com/)
{{% /notice %}}

In the following video, we will formally define regular expressions and the languages they generate. We will also see how they are defined in
`ocamllex`.

{{<youtube 5VNKh7aaZ-g >}}

The following video will give examples of regular expressions found in MiniJava and show some extensions of regular expressions.

{{< youtube Wl8FXqv6dak >}}

### Questions

We will use the notation $\\{a,b\\}^\*$ in the questions below: $\\{a,b\\}^\*$ represents the language generated by the regular expression $\color{\green}{(a\ |\ b)^*}$.

---

{{%expand "Let's consider the alphabet $\{a, b\}$. Give a regular expression to describe the language: $\{ w \in \{a, b\}^*\ |\ w$ contains the words $aa$ or $bb$ $\}$." %}}

A regular expression representing this language is as follows:
${\color{green}{(}}a\ {\color{green}{|}}\ b{\color{green}{)}}^{\color{green}{\*}}{\color{green}{(}}aa\ {\color{green}{|}}\ bb{\color{green}{)}}{\color{green}{(}}a\ {\color{green}{|}}\ b{\color{green}{)}}^{\color{green}{*}}$

To test your regular expression, you can use the following [site](https://regex-generate.github.io/regenerate/), which allows you to generate words recognized by your regular expression,
and words that are not recognized.
{{% /expand%}}

---

{{%expand "This question, although one might think that it is very similar to the previous one, is not so easy. You can come back to this question after studying the next section on automata. Let's consider the alphabet $\{a, b\}$. Give a regular expression to describe the language: $\{ w \in \ a, b\}^*\ |\ w$ does not contain the words $aa$ or $bb$ $\}$." %}}

Since you cannot have two $a$ or two $b$ following each other, you have to alternate $a$ and $b$. This is the idea behind the following regular expression.

${\color{green}{(}}ab{\color{green}{)}}^{\color{green}{\*}}{\color{green}{(}}a\ {\color{green}{|}}\ \epsilon{\color{green}{)}}\ {\color{green}{|}}\ {\color{green}{(}}ba{\color{green}{)}}^{\color{green}{\*}}{\color{green}{(}}b\ {\color{green}{|}}\ \epsilon{\color{green}{)}}$

Another regular expression representing the same language, which we obtained using techniques we will see in the next section, is given below.

$\epsilon\ {\color{green}{|}}\ a\ {\color{green}{|}}\ {\color{green}{(}}b\ {\color{green}{|}}\ ab{\color{green}{)}}{\color{green}{(}}ab{\color{green}{)}}^{\color{green}{*}}{\color{green}{(}}a\ {\color{green}{|}}\ \epsilon{\color{green}{)}}$

{{% /expand%}}

---

We want to move in the grid below using the two actions: "go right" and "go up". We start from the lower left corner and
we want to get to the top right corner. A possible path is shown in the figure on the right.

{{< figure src="/images/minijava/scanner/scanner_question_grid3_en.svg" width="600px" height="auto">}}

{{%expand "Write a regular expression to describe all the actions that lead from the lower left corner to the upper right corner." %}}

This regular expression cannot be written succinctly without using extensions. We will have to list the different configurations.
The number of possibilities is the number of combinations of 3 elements among 6: ${{6}\choose{3}} = 20$. Indeed, it takes 6 actions to go from the start to the finish.
Among these 6 actions, 3 must go to the right and 3 must go up. So we are going to create a regular expression with 20 parts. We use `D` to go
to the right and `H` to the top.

{{< highlight perl>}}
HHHDDD | HHDHDD | HHDDHD | HHDDDH | HDHHDD |
HDHDHD | HDHDDH | HDDHHD | HDDHDH | HDDDHH |
DHHHDD | DHHDHD | DHHDDH | DHDHHD | DHDHDH |
DHDDHH | DDHHHD | DDHHDH | DDHDHH | DDDHHH
{{< /highlight >}}

We have generated the above combinations with the following program.

{{< highlight cpp>}}
#include <string>
#include <iostream>

using namespace std;

const string UP = "H";
const string RIGHT = "D";

void combos(int nH, int nD, string res)
{
    if (!nH && !nD) {
        cost << res << "\n";
        return;
    }
    if (nH) {
        combos(nH - 1, nD, res + TOP);
    }
    if (nD) {
        combos(nH, nD - 1, res + RIGHT);
    }
}

int main(int argc, char *argv[])
{
    combos(3, 3, "");
}
{{< /highlight >}}

By using regular expressions extensions we can obtain the following more concise form.

{{< highlight julia>}}
^(?!(.*H.*){4}|(.*D.*){4})(H|D){6}$
{{< /highlight>}}

In this expression, the operator `(?!(.*H.*){4}|(.*D.*){4})` expresses that one should not be able to find four `H` or four `D` down the line.
The expression `(H|D){6}` expresses that six characters must be recognized between `H` and `D`. It expresses that six characters must be recognized among `H` and `D`,
but we cannot find four `H` or four `D`. So we need to have exactly three `H` and three `D`.

{{% /expand%}}

---

{{%expand "This question is not too easy. You can come back to this question after studying the next section on automata. Let's consider the alphabet $\{a, b\}$. Give a regular expression to describe the language: $\{ w \in \ a, b\}^*\ |\ w$ contains an even number of $a$ $\}$." %}}

A regular expression representing this language is as follows.

${\color{green}{(}}b\ {\color{green}{|}}\ ab^{\color{green}{\*}}a{\color{green}{)}}^{\color{green}{\*}}$

The $ab^{\color{\green}{\*}}a$ part of the regular expression ensures that the number of $a$ is even. The word $\epsilon$ is not forgotten thanks to the iteration operator
on the whole alternative. The first part of the alternative, in conjunction with the iteration operator, allows you to put $b$ to the left or to the right
of the $ab^{\color{green}{\*}}a$ part and also allows you to have only $b$.

Note that we obtained this regular expression using techniques from the following section by first going through an automaton.

{{% /expand%}}

---

{{%expand "Let's consider the alphabet $\{0, 1\}$. What is the language described by the following regular expression: $\color{green}{0^*10^*10^*(10^*\ |\ \epsilon)}$?" %}}
It describes the language containing two or three `1`.
{{% /expand%}}

## Automata

In the previous section, we presented the regular expressions used to describe the so-called regular languages.
This notation is useful to describe regular languages, and we will use it to describe lexical units in the MiniJava lexical analyzer.
On the other hand, for recognition, i.e. to know whether a given word belongs to the language described by a regular expression, it is not easy to
use a regular expression directly.

We will now describe finite, non-deterministic and deterministic automata, which make it easier to answer the question of whether a given word
belongs to a given regular language. We will use these automata in the following section to build a software to test
effectively, if a given word belongs to the language generated by a given regular expression.

Note that the languages described by finite automata (non-deterministic or deterministic) are regular languages, regular expressions and the automata
are therefore two equivalent ways of describing the same languages.

### Non-deterministic Finite Automata

The following figure represents a non-deterministic finite automaton, which we will call $A_{ndf}$^[`ndf` for *non-deterministic finite*.], which describes C comments of type `/*...*/`.
To simplify, we assume that our vocabulary is $\mathcal{V} = \\{ a, b, /, * \\}$.
In this figure we can see the following:

* <span style="color:green">**states**</span>, the circles on the figure, numbered from `0` to `7` for this example.
You can see the <span style="color:green">**starting state**</span> (or initial state), the `0` state, which has an arrow coming at it,
but which doesn't start from any state. The `7` state is an <span style="color:green">**acceptance state**</span> (or final state), it is represented by a double circle.

* <span style="color:green">**transitions**</span> between states, the arrows on the figure. On the arrows, there are symbols
belonging to the vocabulary $\mathcal{V}$ or the symbol $\epsilon$. Note that on some transitions, for example the transition between the state `3` and
the state `2`, we put several symbols on the transition (on this transition there are the two symbols `a` and `b`).
Formally, we should have written two transitions instead of one, each with one of the two symbols, but doing as we did allows us to write the automaton more succinctly.

{{< figure src="/images/minijava/scanner/nfa_comments.svg" width="800px" height="auto">}}

The automaton will allow us to know if a word `m` constructed from the vocabulary $\mathcal{V}$ belongs to the language described by the automaton (we note this language $\mathcal{L}(A_{ndf})$).

Let's consider the word `/*/*/`, which we will call `m`, that belongs to $\mathcal{V}^*$.
How do we know if this word is described by the $A_{ndf}$ automaton?

We will start from the initial state, the state `0`, and we will follow the transitions,
character after character, looking for a path that leads us to the accepting state `7` after reading all the characters of the word `m`.

{{< figure src="/images/minijava/scanner/nfa_comments1_en.svg" width="600px" height="auto">}}

 * Starting from state `0`, there is only one transition, so there is no choice. The word must therefore begin with `/`, because that is the symbol on that transition.
 Once this transition is passed, we are in state `1` and we still have to analyze the `*/*/` part of `m`.

{{< figure src="/images/minijava/scanner/nfa_comments2_en.svg" width="600px" height="auto">}}


 * Starting from state `1`, there is also only one possible transition. We must therefore have the symbol `*` in the remaining part `*/*/` of `m`,
 because it is the symbol on the only transition from state `1`.
 Once this transition is done, we are in state `2` and we still have to analyze the `/*/` part of `m`.

{{< figure src="/images/minijava/scanner/nfa_comments3_en.svg" width="600px" height="auto">}}

 * The state `2` has three outgoing transitions. All three are labeled with the $\epsilon$ symbol. This symbol means that the input is not modified when
 you go through such a transition. We can see now why the automaton is non-deterministic because on the same symbol, here $\epsilon$, we have the choice between several transitions.
 How do we choose the transition to follow? We are going to assume for the moment that we have the skill of clairvoyance and that we are going
 to choose the right transition, which is the one towards state `4`. We will see in the videos how to automate this.

{{< figure src="/images/minijava/scanner/nfa_comments4_en.svg" width="600px" height="auto">}}

 * In state `4` we still have the choice between two transitions: we can choose not to consume a character in the input by taking the $\epsilon$ transition, or to consume the `/` character
 by looping back to state `4`. As we are assuming that we can guess correctly, we will loop back to state `4` and consume the `/`.

{{< figure src="/images/minijava/scanner/nfa_comments5_en.svg" width="600px" height="auto">}}


 * Now, the entry we have left to consume is `*/`. We will take the $\epsilon$ transition to state `2`, then the $\epsilon$ transition from state `2` to state `5`. Once again,
we do not worry for the moment about how to make the right transition choices when there is more than one possibility. We now find ourselves in the configuration below, where the cursor under the input string
has not moved.

 {{< figure src="/images/minijava/scanner/nfa_comments6_en.svg" width="600px" height="auto">}}

* In state `5`, we only have an outgoing transition on the `*` character. The cursor on the input is placed on the `*`, so we can
take this transition and move the cursor to the right. Now we just have to recognize the `/`.

 {{< figure src="/images/minijava/scanner/nfa_comments7_en.svg" width="600px" height="auto">}}

* In state `6`, there is also only one transition on the `/` symbol. Since the cursor on the input points to a `/` character, we can take this transition and move to
the accepting state `7`.

 {{< figure src="/images/minijava/scanner/nfa_comments8_en.svg" width="600px" height="auto">}}

 * Since the input string is now empty and we are in an accepting state, we can conclude that the word `/*/*/` belongs to the $\mathcal{L}(A_{ndf})$ language.
 The word `/*/*/` is therefore a comment.


The input string `/*/*/` is accepted by our automaton, but how do we know if a string is not in the $\mathcal{L}(A_{nfd})$ language, that is to say
how do you know if the word is not accepted?
For a non-deterministic automaton, it must be shown that after reading all the characters of the input string, one cannot be in an acceptance state.

{{% notice note %}}
It seems easier to construct the non-deterministic finite automaton we have just seen to describe the language of comments than the regular expression
*$/\*\color{darkgreen}{(}\*^{\color{darkgreen}{+}}\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}\ \color{darkgreen}{|}\ \color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\ \color{darkgreen}{|}\ /\color{darkgreen}{)}\color{darkgreen}{)}^{\color{darkgreen}{\*}}\*^{\color{darkgreen}{+}}/$* that we saw in the [previous](#regular_expressions) section.
Next, you may be [Perl](https://fr.wikipedia.org/wiki/Perl_(language))^[`Perl` stands for *Practical Extraction and Report Language*, or *Pathologically Eclectic Rubbish Lister* <i class="far fa-smile-wink"></i>.] guru
and it's just too easy for you <i class="far fa-smile-beam"></i>.
{{% /notice %}}

In the two following videos, we will detail non-deterministic finite automata, and how to detect if a word belongs or not to the language generated by a non-deterministic finite automaton.


{{< youtube rZGSM0vvz58 >}}

---

{{< youtube uJmyT-tE7dY >}}

In the following video, we will show how to go from a regular expression to a non-deterministic finite automaton.

{{< youtube KFqUYGvmAHA >}}


#### Questions

{{%expand "Let's consider the alphabet $\{a, b\}$. Build an automaton that recognizes the following language: $\{ w \in \{a, b\}^*\ |\ w$ contains the word $aba\}$. For example, $aba$ is in the language, as well as $bbbbbaabaaaabb$, but not $babbbaaa$." %}}
 {{< figure src="/images/minijava/scanner/nfa_question1.svg" width="600px" height="auto">}}

We can see that this automaton actually mimics the regular expression $\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{\*}}aba\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{\*}}$.
{{% /expand%}}

---

{{%expand "Let's consider the alphabet $\{a, b\}$. Construct an automaton that recognizes the language: $\{ w \in \{a, b\}^*\ |\ w$ does not contain the word $aba$ unless it is preceded by the word $bbb\}$. For example, $aaabbbaabaa$ is in the language, $abba$ is in the language, but not $bbabab$." %}}
{{< figure src="/images/minijava/scanner/nfa_question2.svg" width="600px" height="auto">}}

<a name="nfa_question2_states"></a>

The upper part of the automaton, the states `1`, `2`, `3` and `4`, is used to recognize a sequence of three `b` followed by anything.
The lower part of the automaton is used to recognize anything but `aba`.
The state `5` indicates that you haven't yet seen an `a` or that you've just encountered a sequence ending in `bb` (so you're sure you haven't seen a sequence ending in `ab`).
The state `6` indicates that we are analyzing a sequence of at least one `a`
and the state `7` that we just saw `ab`, so we must not have an `a` now.
From states `5`, `6` and `7` we can reach the upper part of the automaton because we just analyzed a correct prefix and we may want to add `aba` in the following (adding `bbb` before).

How can we be sure that the lower part recognizes everything but `aba`? For the upper part, it is quite easy to convince yourself that it recognizes $bbb\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{\*}}$.
But it's not so easy to convince yourself that the bottom part describes everything but the `aba` chain. When you really want to be sure, there's only one way,
you have to make a proof! Sure, You can tell me that it still has to be correct. You are right <i class="far fa-smile-beam"></i>, but in a proof you just have to
convince yourself that every elementary step is correct.

We will do a proof by induction on the length of the input string. For a string of length 0 ($\epsilon$) of length 1 ($a$ and $b$) and of length 2 ($aa$, $ab$, $ba$ and $bb$), we can follow the transitions
from state `0` to the lower part and see that they are all recognized and they don't have `aba` in them (because the string length is less than or equal to 2). Suppose
that the property holds for strings of length $n \ge $2, is it still true for strings of length $n + $1? Let's look at the last two characters of the string of length $n$ `m`.

 * `m` ends with `aa`. In this case we must be in state `6` [as shown above](#nfa_question2_states). We can add a `a` and accept
 the new `ma` string because we stay in state `6` which is an accepting state, and we can also add a `b` and accept the `mb` string because we are in state `7` which is also an accepting state.

 * `m` ends with `ab`. In this case we must be in state `7` [as indicated above](#nfa_question2_states). You cannot add an `a` because there is no transition on the character `a`
 from state `7` and therefore a string containing `aba` will not be recognized. However, you can add a `b` and still recognize the string of length $n+1$ `mb`.

 * `m` ends with `ba`. In this case we must be in state `6` [as indicated above](#nfa_question2_states) and we can add an `a` or a `b` to get the
 strings of length $n+1$ `ma` or `mb`.

 * `m` ends with `bb`. In this case we must be in state `5` [as above](#nfa_question2_states) and we can add an `a` or `b` to get the
 strings of length $n+1$ `ma` or `mb`.

So assuming that we can generate all words of length $n$ not containing `aba`, we have just shown that we can generate all words of length $n+1$ not containing `aba`.

{{% /expand%}}

## Regular Expressions Matching

## Scanner with Ocamllex

## Questions

## Ressources
