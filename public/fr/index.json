[
{
	"uri": "/fr/compiler/minijava/",
	"title": "MiniJava",
	"tags": ["compilation", "transpileur", "ramasse miettes", "langage à objets", "MiniJava", "C", "OCaml", "Menhir", "Bash"],
	"description": "",
	"content": " MiniJava Le compilateur que nous allons étudier dans cette partie est un transpileur permettant de passer du langage MiniJava au langage C. Il sera réalisé en en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.\nPour télécharger le code : git clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git.\n"
},
{
	"uri": "/fr/compiler/minijava/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Nous allons réaliser un transpileur, ou compilateur source à source, pour un sous-ensemble du langage Java, le langage MiniJava. La représentation d\u0026rsquo;entrée pour notre compilateur sera donc le langage MiniJava. La représentation en sortie de notre compilateur sera le langage C.\nUne exemple de programme permettant de calculer une factorielle est donné ci-dessous.\nclass Factorial { public static void main(String[] a) { System.out.println(new Fac().computeFac(10)); } } class Fac { public int computeFac(int num) { int numAux; if (num \u0026lt; 1) numAux = 1; else numAux = num * (this.computeFac(num-1)); return numAux; } } Comme Minijava est un sous-ensemble de Java, nous pourrons compiler nos fichiers MiniJava en utilisant le compilateur Java javac ce qui sera pratique pour tester la validité de nos traductions en langage C. En effet, nous pourrons comparer la sortie du programme obtenu en utilisant le compilateur Java, avec la sortie obtenue par l\u0026rsquo;exécutable obtenu grâce à notre transpileur.\n Vue d\u0026rsquo;ensemble du transpileur Nous allons considérer le programme MiniJava suivant pour illustrer cette section.  class Print42 { public static void main(String[] a) { System.out.println(35 + 2 * 3 + 1); } }\nLa figure suivante montre les différentes étapes permettant de passer du fichier source en MiniJava au fichier source transpilé en C.\ngraph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C]  Nous allons maintenant décrire les différentes étapes de la figure ci-dessus.\nPour suivre les démos dans les différentes vidéos qui vont suivre, commencer par installer les dépendances comme indiqué ici. Télécharger ensuite le code en faisant\ngit clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git cd MiniJava git checkout v1.0 make La branche master est la version avec le ramasse miettes et le tag v1.0 est une version sans ramasse miettes. Si vous voulez apporter des modifications à la version 1.0, vous pouvez créer une nouvelle branche (from_v1.0 par exemple) en faisant\ngit checkout -b from_v1.0 v1.0 Le code que je vais utiliser pendant les démos se trouve ci-dessous.\n  Pièces jointes   demo_code.tgz  (3 ko)    Analyse lexicale La première étape est l\u0026rsquo;analyse lexicale qui va permettre de découper un flot de caractères en mots. Ces mots sont appelés unités lexicales. On obtient alors une information plus structurée où les mots clés du langage, les identifiants, les entiers et les booléens ont été identifiés. Cette phase va aussi nous permettre de supprimer les commentaires et les blancs (espaces et retours à la ligne).\nPour le programme ci-dessus, l\u0026rsquo;analyse lexicale va produire le flot d\u0026rsquo;unités lexicales suivantes. On peut voir, par exemple, que le mot clé CLASS a été identifié, que la constante entière INT_CONST 35 aussi.\nCLASS IDENT ‘Print42‘ LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET IDENT ‘a‘ RPAREN LBRACE SYSO LPAREN INT_CONST ‘35‘ PLUS INT_CONST ‘2‘ TIMES INT_CONST ‘3‘ PLUS INT_CONST ‘1‘ RPAREN SEMICOLON RBRACE RBRACE EOF Dans la vidéo suivante, nous allons donner une vue d\u0026rsquo;ensemble du transpileur, et nous présenterons l\u0026rsquo;analyseur lexical de MiniJava.\n  Analyse syntaxique La deuxième étape, l\u0026rsquo;analyse syntaxique, prend en entrée le flot d\u0026rsquo;unités lexicales et va construire un arbre syntaxique abstrait permettant de représenter la structure du programme sous la forme d\u0026rsquo;un arbre.\nPour le programme ci-dessus, on obtient l\u0026rsquo;arbre suivant. On peut y voir, par exemple, l\u0026rsquo;expression arithmétique avec de manière explicite la priorité des opérateurs (plus c\u0026rsquo;est bas dans l\u0026rsquo;arbre et plus c\u0026rsquo;est prioritaire).\nprogram ├name Print42 ├main_args a └main └ISyso └EBinOp OpAdd ├EBinOp OpAdd │ ├EConst (ConstInt 35) │ └EBinOp OpMul │ ├EConst (ConstInt 2) │ └EConst (ConstInt 3) └EConst (ConstInt 1) L\u0026rsquo;analyse syntaxique a besoin de connaître la structure d\u0026rsquo;un programme MiniJava. Cette structure est donnée sous la forme d\u0026rsquo;une grammaire. La grammaire de MiniJava, dans sa forme EBNF est donnée ci-dessous. Une version sûrement plus lisible pour nous en diagramme syntaxique est donnée ici.1\nProgram = MainClass { ClassDeclaration } \u0026#39;eof\u0026#39; ; MainClass = \u0026#39;class\u0026#39; Identifier \u0026#39;{\u0026#39; \u0026#39;public\u0026#39; \u0026#39;static\u0026#39; \u0026#39;void\u0026#39; \u0026#39;main\u0026#39; \u0026#39;(\u0026#39; \u0026#39;String\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; Identifier \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; Statement \u0026#39;}\u0026#39; \u0026#39;}\u0026#39; ; ClassDeclaration = \u0026#39;class\u0026#39; Identifier [ \u0026#39;extends\u0026#39; Identifier ] \u0026#39;{\u0026#39; { VarDeclaration } { MethodDeclaration } \u0026#39;}\u0026#39; ; VarDeclaration = Type Identifier \u0026#39;;\u0026#39; ; MethodDeclaration = \u0026#39;public\u0026#39; Type Identifier \u0026#39;(\u0026#39; [ Type Identifier { \u0026#39;,\u0026#39; Type Identifier } ] \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; { VarDeclaration } { Statement } \u0026#39;return\u0026#39; Expression \u0026#39;;\u0026#39; \u0026#39;}\u0026#39; ; Type = \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; | \u0026#39;boolean\u0026#39; | \u0026#39;int\u0026#39; | Identifier ; Statement = \u0026#39;{\u0026#39; { Statement } \u0026#39;}\u0026#39; | \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement \u0026#39;else\u0026#39; Statement | \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement | \u0026#39;System.out.println\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; \u0026#39;;\u0026#39; | Identifier \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; | Identifier \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; ; Expression = Expression ( \u0026#39;\u0026amp;\u0026amp;\u0026#39; | \u0026#39;\u0026lt;\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; ) Expression | Expression \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | Expression \u0026#39;.\u0026#39; \u0026#39;length\u0026#39; | Expression \u0026#39;.\u0026#39; Identifier \u0026#39;(\u0026#39; [Expression {\u0026#39;,\u0026#39; Expression}] \u0026#39;)\u0026#39; | Integer | \u0026#39;true\u0026#39; | \u0026#39;false\u0026#39; | Identifier | \u0026#39;this\u0026#39; | \u0026#39;new\u0026#39; \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | \u0026#39;new\u0026#39; Identifier \u0026#39;(\u0026#39; \u0026#39;)\u0026#39; | \u0026#39;!\u0026#39; Expression | \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; ; Letter = \u0026#39;A\u0026#39; | \u0026#39;B\u0026#39; | \u0026#39;C\u0026#39; | \u0026#39;D\u0026#39; | \u0026#39;E\u0026#39; | \u0026#39;F\u0026#39; | \u0026#39;G\u0026#39; | \u0026#39;H\u0026#39; | \u0026#39;I\u0026#39; | \u0026#39;J\u0026#39; | \u0026#39;K\u0026#39; | \u0026#39;L\u0026#39; | \u0026#39;M\u0026#39; | \u0026#39;N\u0026#39; | \u0026#39;O\u0026#39; | \u0026#39;P\u0026#39; | \u0026#39;Q\u0026#39; | \u0026#39;R\u0026#39; | \u0026#39;S\u0026#39; | \u0026#39;T\u0026#39; | \u0026#39;U\u0026#39; | \u0026#39;V\u0026#39; | \u0026#39;W\u0026#39; | \u0026#39;X\u0026#39; | \u0026#39;Y\u0026#39; | \u0026#39;Z\u0026#39; | \u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39; | \u0026#39;d\u0026#39; | \u0026#39;e\u0026#39; | \u0026#39;f\u0026#39; | \u0026#39;g\u0026#39; | \u0026#39;h\u0026#39; | \u0026#39;i\u0026#39; | \u0026#39;j\u0026#39; | \u0026#39;k\u0026#39; | \u0026#39;l\u0026#39; | \u0026#39;m\u0026#39; | \u0026#39;n\u0026#39; | \u0026#39;o\u0026#39; | \u0026#39;p\u0026#39; | \u0026#39;q\u0026#39; | \u0026#39;r\u0026#39; | \u0026#39;s\u0026#39; | \u0026#39;t\u0026#39; | \u0026#39;u\u0026#39; | \u0026#39;v\u0026#39; | \u0026#39;w\u0026#39; | \u0026#39;x\u0026#39; | \u0026#39;y\u0026#39; | \u0026#39;z\u0026#39; ; Digit = \u0026#39;0\u0026#39; | \u0026#39;1\u0026#39; | \u0026#39;2\u0026#39; | \u0026#39;3\u0026#39; | \u0026#39;4\u0026#39; | \u0026#39;5\u0026#39; | \u0026#39;6\u0026#39; | \u0026#39;7\u0026#39; | \u0026#39;8\u0026#39; | \u0026#39;9\u0026#39; ; Integer = Digit { Digit } ; Character = Letter | Digit | \u0026#39;_\u0026#39; ; Identifier = Letter { Letter | Digit | \u0026#39;_\u0026#39; } ; La vidéo suivante va présenter l\u0026rsquo;analyseur syntaxique de MiniJava.\n   Typage La troisième étape, l\u0026rsquo;analyse de types, va prendre en entrée l\u0026rsquo;arbre abstrait et va vérifier si le typage est correct. Par exemple, on va vérifier qu\u0026rsquo;on utilise les méthodes avec le bon nombre de paramètres, que les opérateurs + et * sont utilisés avec des opérandes entières, qu\u0026rsquo;une classe est compatible avec une autre via la relation d\u0026rsquo;héritage, \u0026hellip;\nLa vidéo suivante va présenter une vue d\u0026rsquo;ensemble du typage dans MiniJava.\n  Génération de code La dernière étape va consister à générer le code en C. On va de nouveau parcourir l\u0026rsquo;arbre syntaxique abstrait pour générer ce code. Pour notre example, on obtient le fichier C ci-dessous.\n#include \u0026lt;stdio.h\u0026gt;int main(int argc, char *argv[]) { printf(\u0026#34;%d\\n\u0026#34;, ((35 + (2 * 3)) + 1)); return 0; } La vidéo suivante va décrire succinctement la génération de code C dans MiniJava.\n  Sémantique de MiniJava La sémantique de MiniJava est donnée par sa sémantique en tant que programme Java 2. Les principales restrictions sont\n Les classes n\u0026rsquo;héritent pas de la classe Object. Le mot clé super n\u0026rsquo;existe pas. Il y a simplement un constructeur par défaut. Les seuls types autorisés sont,  int. boolean. int[]. Les classes définies par l\u0026rsquo;utilisateur.  La surcharge d\u0026rsquo;opérateurs n\u0026rsquo;est pas autorisée. L\u0026rsquo;instruction System.out.printl() ne peut imprimer que des entiers. Toutes les méthodes doivent retourner une valeur. Il n\u0026rsquo;y a pas d\u0026rsquo;interface, d\u0026rsquo;exception, de généricité, de lambda.  Nous expliquons dans la vidéo suivante les principales différences entre MiniJava et Java.\n  Nous avons décrit rapidement l\u0026rsquo;initialisation par défaut en Java (et MiniJava) dans la vidéo. Nous apportons quelques précisions ci-dessous. Vous pouvez regarder ici pour tous les détails.\nSoit le programme Java Init.java suivant.\n1class Init { 2 public static void main(String[] args) { 3 int i; 4 boolean b; 5 int[] a; 6 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 7 } 8} Si on le compile, on obtient les messages d\u0026rsquo;erreur suivants.\n$ javac Init.java Init.java:6: error: variable i might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable b might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable a might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ 3 errors En effet, les trois variables i, b et a sont situées sur la pile, et leurs valeurs vont dépendre des valeurs qui sont situées sur la pile lors de l\u0026rsquo;appel du main. Java n\u0026rsquo;initialisant pas les variables locales avec une valeur par défaut, le compilateur refuse le programme en nous indiquant que l\u0026rsquo;on cherche à utiliser des variables non initialisées.\nPar contre, le programme suivant est correct car les attributs ont des valeurs par défaut.\n1class Init { 2 public static void main(String[] args) { 3 new Default().print(); 4 } 5} 6 7class Default { 8 private int i; 9 private boolean b; 10 private int[] a; 11 12 public void print() { 13 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 14 } 15} Et on obtient la sortie suivante.\n$ javac Init.java $ java Init 0 false null Rappels sur la liaison dynamique en Java Nous allons faire quelques rappels sur la liaison dynamique en Java dans la vidéo ci-dessous, car la gestion de la liaison dynamique sera un des points difficiles à gérer dans notre transpileur.\n  Questions Reprenons la grammaire de MiniJava. Nous voudrions ajouter la possibilité d\u0026rsquo;avoir\n L\u0026rsquo;opérateur de comparaison ==. Des constructeurs. Des constructeurs et méthodes private.    Quelles sont les modifications à apporter à cette grammaire pour incorporer ces nouveaux éléments ?   Grammaire de MiniJava modifiée.\n    Dans la question précédente, quels terminaux avez-vous dû ajouter à la grammaire (un terminal dans la grammaire deviendra une unité lexicale) ?   == et private.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6} 7 8class B extends A { 9 public boolean m1(int n) { 10 System.out.println(\u0026#34;boolean B:m1(int n)\u0026#34;); 11 return false; 12 } 13}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, à la ligne 9, la méthode m1 est une redéfinition de la méthode m1 de la ligne 2 : elle à le même nom et les mêmes paramètres. Par contre, pour être une redéfinition correcte, il aurait fallu que le type de retour boolean soit compatible avec le type de retour int, mais ce n\u0026rsquo;est pas le cas.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(int n) { 7 System.out.println(\u0026#34;boolean A:m1(int n)\u0026#34;); 8 return false; 9 } 10}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, le type de retour ne permet pas de différentier deux méthodes. Donc même si les méthodes aux lignes 2 et 6 ont des types de retour différents, comme elles se nomment pareil et ont les mêmes paramètres, on a pas une surcharge et il y a donc une erreur.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(A a) { 3 System.out.println(\u0026#34;int A:m1(A a)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(B b) { 7 System.out.println(\u0026#34;boolean A:m1(B b)\u0026#34;); 8 return false; 9 } 10} 11 12class B extends A { 13}   Ce code compile-t-il ?   Ce code compile. Cette fois-ci, la méthode à la ligne 6 est bien une surcharge de la méthode à la ligne 2 car le paramètre est d\u0026rsquo;un type différent.\n  Ressources Cours sur Java de Coursera partie 1\nCours sur Java de Coursera partie 2\nCours sur Java de Coursera partie 3\nCours sur Java de Princeton\nSpécifications du langage Java\nPage de MiniJava\nDiagramme syntaxique de MiniJava\nCours sur le langage C partie 1\nCours sur le langage C partie 2\nCours sur le langage C partie 3\nCours sur le langage C partie 4\nApprendre le C en construisant un Lisp\nCours sur le C moderne\nSpécifications du langage C (norme C11)\n  La description de la grammaire qui permet de générer le diagramme ne suit pas strictement la forme EBNF. Les détails sont donnés ici. [return] Voir ici pour la sémantique du langage Java. [return]   "
},
{
	"uri": "/fr/compiler/minijava/scanner/",
	"title": "Analyse lexicale",
	"tags": [],
	"description": "",
	"content": " graph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C] classDef green fill:#74B559,stroke:#222723,stroke-width:5px; class B green  Nous allons décrire l\u0026rsquo;analyseur lexical de MiniJava qui va permettre de découper les caractères du fichier source en unités lexicales. Ces unités lexicales seront ensuite utilisées par l\u0026rsquo;analyseur syntaxique.\nAvant de décrire cet analyseur lexical, nous allons présenter les expressions régulières qui seront utilisées pour décrire les unités lexicales. Nous étudierons aussi les automates qui permettront d\u0026rsquo;implémenter la reconnaissance des expressions régulières. \nExpressions régulières Les expressions régulières vont nous permettre de décrire succintement et assez intuitivement les unités lexicales de MiniJava et seront utilisées dans le générateur d\u0026rsquo;analyseur lexical ocamllex que nous allons utiliser dans notre transpiler.\nDéfinition Une expression régulière va décrire un ensemble de mots sur un vocabulaire donné. Nous allons prendre comme exemple le vocabulaire $\\mathcal{V} = \\{0, 1\\}$ constitué simplement de deux éléments : 0 et 1. Nous décrivons ci-dessous de manière informelle les éléments de base et les opérateurs permettant de créer des expressions régulières et les mots qu\u0026rsquo;elles décrivent.\n Expressions régulières de base :\n L\u0026rsquo;expression régulière $\\color{green}\\epsilon$ génère l\u0026rsquo;ensemble contenant simplement le mot vide1: $\\{\\epsilon\\}$. Pour $c \\in \\mathcal{V}$, l\u0026rsquo;expression régulière $\\color{green}c$ représente l\u0026rsquo;ensemble contenant un seul mot : $\\{c\\}$.\n   Expression Ensemble de mots     $\\color{green}0$ $\\{0\\}$   $\\color{green}1$ $\\{1\\}$     Expressions régulières composées :\n On peut utiliser des parenthèses pour regrouper des expressions régulières. Soit $\\color{green}{r}$ une expression régulière, alors $\\color{green}{(r)}$ représente le même ensemble de mots que l\u0026rsquo;expression $\\color{green}{r}$.\n   Expression Ensemble de mots     $\\color{green}{(0)}$ $\\{0\\}$    L\u0026rsquo;opérateur de concaténation permet de juxtaposer les mots engendrés par deux expressions régulières. Soit $\\color{green}{r_1}$ et $\\color{green}{r_2}$ deux expressions régulières. La concaténation de ces deux expressions régulières est notée : $\\color{green}{r_1r_2}$. L\u0026rsquo;ensemble des mots décrit par cette expression régulière est la concaténation des mots décrit par $\\color{green}{r_1}$ avec ceux décrit par $\\color{green}{r_2}$.\nNotons que cet opérateur est associatif, c\u0026rsquo;est-à-dire que pour toute expression régulière $\\color{green}{r_1}$, $\\color{green}{r_2}$ et $\\color{green}{r_3}$, on a $\\color{green}{(r_1r_2)r_3} = \\color{green}{r_1(r_2r_3)}$ que l\u0026rsquo;on notera simplement $\\color{green}{r_1r_2r_3}$.\n   Expression Ensemble de mots     $\\color{green}{\\epsilon1}$ $\\{1\\}$   $\\color{green}{10}$ $\\{10\\}$   $\\color{green}{(10)1}$ $\\{101\\}$   $\\color{green}{1(01)}$ $\\{101\\}$   $\\color{green}{101}$ $\\{101\\}$    L\u0026rsquo;opérateur d\u0026rsquo;union permet de faire l\u0026rsquo;union des mots engendrés par deux expressions régulières. Soit $\\color{green}{r_1}$ et $\\color{green}{r_2}$ deux expressions régulières. L\u0026rsquo;union de ces deux expressions régulières est notée : $\\color{green}{r_1 | \\ r_2}$. L\u0026rsquo;ensemble des mots décrit par cette expression régulière est l\u0026rsquo;union des mots décrit par $\\color{green}{r_1}$ avec ceux décrit par $\\color{green}{r_2}$.\nNotons que cet opérateur est commutatif, c\u0026rsquo;est-à-dire que $\\color{green}{r_1\\ |\\ r_2} = \\color{green}{r_2\\ |\\ r_1}$. Il est aussi associatif, c\u0026rsquo;est-à-dire que pour toute expression régulière $\\color{green}{r_1}$, $\\color{green}{r_2}$ et $\\color{green}{r_3}$, on a $\\color{green}{(r_1\\ |\\ r_2)\\ |\\ r_3} = \\color{green}{r_1\\ |\\ (r_2\\ |\\ r_3)}$ que l\u0026rsquo;on notera simplement $\\color{green}{r_1\\ |\\ r_2\\ |\\ r_3}$.\n   Expression Ensemble de mots     $\\color{green}{\\epsilon \\ | \\ 1}$ $\\{\\epsilon, 1\\}$   $\\color{green}{(00) \\ | \\ (10)}$ $\\{00, 10\\}$   $\\color{green}{(10) \\ | \\ (00)}$ $\\{00, 10\\}$   $\\color{green}{(0 \\ | \\ 1)\\ |\\ (10)}$ $\\{0, 1, 10\\}$   $\\color{green}{0\\ |\\ (1 \\ | \\ (10))}$ $\\{0, 1, 10\\}$   $\\color{green}{0 \\ | \\ 1\\ |\\ (10)}$ $\\{0, 1, 10\\}$   $\\color{green}{(0\\ |\\ 1)(0\\ |\\ 1)}$ $\\{00, 01, 10, 11\\}$    L\u0026rsquo;opérateur d\u0026rsquo;itération noté * permet de juxtaposer $0$ ou plusieurs fois les mots engendrés par une expression régulières. Soit $\\color{green}{r}$ une expression régulière, alors l\u0026rsquo;expression régulière $\\color{green}{r^*}$ représente l\u0026rsquo;hypothétique2 expression régulière $\\color{green}{\\epsilon \\ |\\ r\\ |\\ rr\\ |\\ rrr\\ |\\ rrrr\\ |\\ \\cdots}$.\n   Expression Ensemble de mots     $\\color{green}{0^*}$ $\\{\\epsilon, 0, 00, 000, 0000, \\cdots\\}$   $\\color{green}{(0\\ | \\ 1)^*}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \\cdots\\}$      Pour éviter trop de parenthèses, il existe une priorité entre les différents opérateurs : les parenthèses ont la plus grande priorité, ensuite l\u0026rsquo;opérateur $\\color{green}{*}$, puis l\u0026rsquo;opérateur de concaténation et enfin l\u0026rsquo;opérateur $\\color{green}{|}$. On a vu aussi ci-dessus que les opérateurs de concaténation et d\u0026rsquo;union sont associatifs, ce qui nous permet de supprimer d\u0026rsquo;avantage de parenthèses. Ainsi, l\u0026rsquo;expression régulière $\\color{green}{10^*1\\ |\\ 11\\ |\\ \\epsilon}$ se lit $\\color{green}{(((1(0^ *))1)\\ |\\ (11))\\ |\\ \\epsilon}$\n Exemples Nous donnons ci-dessous quelques exemples d\u0026rsquo;expressions régulières toujours sur le vocabulaire $\\mathcal{V} = \\{0, 1\\}$.\n-- --    Description Expression Ensemble de mots     Les nombres binaires (sans zéro non significatif) $\\color{green}{0\\ | \\ 1(0\\ | \\ 1)^*}$ $\\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \\cdots\\}$   Les nombres binaires impairs $\\color{green}{1\\ | \\ 1(0\\ | \\ 1)^*1}$ $\\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \\cdots\\}$   Les chaînes de bits de longueur paire ne contenant que des zeros et des uns alternés $\\color{green}{(10)^* \\ | \\ (01)^*}$ $\\{\\epsilon, 10, 01, 1010, 0101, 101010, 010101, \\cdots\\}$   Les chaînes de bits dont la longueur est multiple de 3 $\\color{green}{((0\\ | \\ 1)(0\\ | \\ 1)(0\\ | \\ 1))^*}$ $\\{\\epsilon, 000, 001, 010, 011, 100, \\cdots, 111000, 111001, \\cdots, 101011110, \\cdots \\}$   Les chaînes de bits ne contenant pas la sous-chaîne $11$ $\\color{green}{0^* ( 100^* )^* (1\\ | \\ \\epsilon)}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \\cdots\\}$    Vous pouvez vous amuser en utilisant les expressions régulières sur Regex Crossword .\n Dans la vidéo suivante, nous allons définir formellement les expressions régulières et les langages qu\u0026rsquo;elles engendrent. Nous verrons aussi comment elles sont définies dans ocamllex.\n  La vidéo suivante va donner des exemples d\u0026rsquo;expressions régulières que l\u0026rsquo;on trouvera dans MiniJava et montrer quelques extensions des expressions régulières.\n  Questions On utilisera la notation $\\{a,b\\}^*$ dans les questions ci-dessous : $\\{a,b\\}^*$ représente le langage engendré par l\u0026rsquo;expression régulière $\\color{green}{(a\\ |\\ b)^*}$.\n  Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner une expression régulière permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient les mots $aa$ ou $bb$ $\\}$.   Une expression régulière représentant ce langage est la suivante : ${\\color{green}{(}}a\\ {\\color{green}{|}}\\ b{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}aa\\ {\\color{green}{|}}\\ bb{\\color{green}{)}}{\\color{green}{(}}a\\ {\\color{green}{|}}\\ b{\\color{green}{)}}^{\\color{green}{*}}$\nPour tester votre expression régulière, vous pouvez utiliser le site suivant, qui permet de générer des mots reconnus par votre expression régulière, et des mots qui ne sont pas reconnus.\n    Cette question même si on pourrait penser qu\u0026#39;elle ressemble beaucoup à la précédente est moins facile. Vous pouvez revenir sur cette question après avoir étudié la section suivante sur les automates. Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner une expression régulière permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ ne contient pas les mots $aa$ ou $bb$ $\\}$.   Puisque l\u0026rsquo;on ne peut pas avoir deux $a$ ou deux $b$ qui se suivent, on doit alterner les $a$ et les $b$. C\u0026rsquo;est l\u0026rsquo;idée derrière l\u0026rsquo;expression régulière suivante.\n${\\color{green}{(}}ab{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}a\\ {\\color{green}{|}}\\ \\epsilon{\\color{green}{)}}\\ {\\color{green}{|}}\\ {\\color{green}{(}}ba{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}b\\ {\\color{green}{|}}\\ \\epsilon{\\color{green}{)}}$\nUne autre expression régulière représentant le même langage, que nous avons obtenu en utilisant des techniques que nous verrons dans la section suivante est donnée ci-dessous.\n$\\epsilon\\ {\\color{green}{|}}\\ a\\ {\\color{green}{|}}\\ {\\color{green}{(}}b\\ {\\color{green}{|}}\\ ab{\\color{green}{)}}{\\color{green}{(}}ab{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}a\\ {\\color{green}{|}}\\ \\epsilon{\\color{green}{)}}$\n  On veut se déplacer dans la grille ci-dessous en utilisant les deux actions : \u0026ldquo;aller à droite\u0026rdquo; et \u0026ldquo;aller en haut\u0026rdquo;. On part du coin inférieur gauche et on veut arriver au coin supérieur droit. Un chemin possible est indiqué dans la figure de droite.\n    Écrire une expression régulière permettant de décrire toutes les actions permettant d\u0026#39;aller du coin inférieur gauche au coin supérieur droit.   On ne peut pas écrire succintement cette expression régulière sans utiliser des extensions. On va devoir énumérer les différentes configurations. Le nombre de possibilités est le nombre de combinaisons de 3 éléments parmis 6 : ${{6}\\choose{3}} = 20$. En effet, il faut 6 actions pour aller du départ jusqu\u0026rsquo;à l\u0026rsquo;arrivée. Parmis ces 6 actions, 3 doivent aller vers la droite et 3 vers le haut. On va donc créer une expression régulière avec 20 parties. Nous utilisons D pour allez à droite et H pour allez en haut.\nHHHDDD | HHDHDD | HHDDHD | HHDDDH | HDHHDD | HDHDHD | HDHDDH | HDDHHD | HDDHDH | HDDDHH | DHHHDD | DHHDHD | DHHDDH | DHDHHD | DHDHDH | DHDDHH | DDHHHD | DDHHDH | DDHDHH | DDDHHH Nous avons généré les combinaisons ci-dessus grâce au programme suivant.\n#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const string HAUT = \u0026#34;H\u0026#34;; const string DROITE = \u0026#34;D\u0026#34;; void combos(int nH, int nD, string res) { if (!nH \u0026amp;\u0026amp; !nD) { cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } if (nH) { combos(nH - 1, nD, res + HAUT); } if (nD) { combos(nH, nD - 1, res + DROITE); } } int main(int argc, char *argv[]) { combos(3, 3, \u0026#34;\u0026#34;); }  En utilisant les extensions des expressions régulières on peut obtenir la forme plus concise suivante.\n^(?!(.*H.*){4}|(.*D.*){4})(H|D){6}$ Dans cette expression, l\u0026rsquo;opérateur (?!(.*H.*){4}|(.*D.*){4}) exprime qu\u0026rsquo;il ne faut pas réussir à trouver quatre H ou quatre D dans la suite de la ligne. L\u0026rsquo;expression (H|D){6} exprime qu\u0026rsquo;il faut reconnaître six caractères parmis H et D. On exprime donc qu\u0026rsquo;il faut reconnaître six caractères parmis H et D, mais on ne doit pas trouver quatre H ou quatre D. On doit donc avoir exactement trois H et trois D.\n  \n  Cette question n\u0026#39;est pas trop facile. Vous pouvez revenir sur cette question après avoir étudié la section suivante sur les automates. Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner une expression régulière permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient un nombre pair de $a$ $\\}$.   Une expression régulière représentant ce langage est la suivante.\n${\\color{green}{(}}b\\ {\\color{green}{|}}\\ ab^{\\color{green}{*}}a{\\color{green}{)}}^{\\color{green}{*}}$\nLa partie $ab^{\\color{green}{*}}a$ de l\u0026rsquo;expression régulière permet d\u0026rsquo;assurer que le nombre de $a$ est pair. Le mot $\\epsilon$ n\u0026rsquo;est pas oublié grâce à l\u0026rsquo;opérateur d\u0026rsquo;itération sur toute l\u0026rsquo;alternative. La première partie de l\u0026rsquo;alternative, en conjonction avec l\u0026rsquo;opérateur d\u0026rsquo;itération, permet de mettre des $b$ à gauche ou à droite de la partie $ab^{\\color{green}{*}}a$ et permet aussi de n\u0026rsquo;avoir que des $b$.\nNotons que nous avons obtenu cette expression régulière en utilisant des techniques de la section suivante en passant d\u0026rsquo;abord par un automate.\n    Soit l\u0026#39;alphabet $\\{0, 1\\}$. Quel est le langage décrit par l\u0026#39;expression régulière suivante : $\\color{green}{0^*10^*10^*(10^*\\ |\\ \\epsilon)}$ ?   Le langage contenant deux ou trois 1.\n  Automates Dans la section précédente nous avons présenté les expressions régulières qui permettent de décrire les langages dit réguliers. Cette notation est pratique pour décrire les langages réguliers, et nous l\u0026rsquo;utiliserons pour décrire les unités lexicales dans l\u0026rsquo;analyseur lexical de MiniJava. Par contre, pour la reconnaissance, c\u0026rsquo;est-à-dire pour savoir si un mot donné appartient bien au langage décrit par une expression régulière, il n\u0026rsquo;est pas facile d\u0026rsquo;utiliser directement une expression régulière.\nNous allons décrire maintenant les automates finis, non-déterministes et déterministes, qui permettent de répondre plus facilement à la question de savoir si un mot donné appartient bien à un langage régulier donné. Nous nous servirons de ces automates dans la section suivante pour construire un logiciel permettant de tester efficacement, si un mot donné appartient bien au langage engendré par une expression régulière donnée.\nNotons que les langages décrits par les automates finis (non-déterministes ou déterministes) sont les langages réguliers, les expressions régulières et les automates sont donc deux moyens équivalents permettant de décrire les mêmes langages.\nAutomates finis non-déterministes La figure suivante représente un automate fini non-déterministe, que nous appellerons $A_{fnd}$3, qui décrit les commentaires en C de type /*...*/. On suppose, pour simplifier, que notre vocabulaire est $\\mathcal{V} = \\{ a, b, /, * \\}$. Sur cette figure on peut voir les éléments suivants :\n Des états, les cercles sur la figure, numérotés de 0 à 7 pour cet exemple. On peut y voir l\u0026rsquo;état de départ (ou état initial), l\u0026rsquo;état 0, qui possède une flèche qui arrive sur lui, mais qui ne part d\u0026rsquo;aucun autre état. L\u0026rsquo;état 7 est un état d\u0026rsquo;acceptation (ou état final), il est représenté par un double cercle.\n Des transitions entre états, les flèches sur la figure. Sur les transitions il y a des symboles appartenant au vocabulaire $\\mathcal{V}$ ou bien le symbole $\\epsilon$. Notons que sur certaines transitions, par exemple la transition entre l\u0026rsquo;état 3 et l\u0026rsquo;état 2, nous avons mis plusieurs symboles sur la transition (sur cette transition il y a les deux symboles a et b). Formellement, nous aurions dû écrire deux transitions au lieu d\u0026rsquo;une, avec chacune un des deux symboles, mais faire comme nous l\u0026rsquo;avons fait permet d\u0026rsquo;écrire plus succinctement l\u0026rsquo;automate.\n    L\u0026rsquo;automate va nous permettre de savoir si un mot m construit à partir du vocabulaire $\\mathcal{V}$ appartient au langage décrit par l\u0026rsquo;automate (on note ce langage $\\mathcal{L}(A_{fnd})$).\nSoit /*/*/ un mot, que nous appellerons m, appartenant à $\\mathcal{V}^*$. Comment savoir si ce mot est décrit par l\u0026rsquo;automate $A_{fnd}$ ?\nOn va partir de l\u0026rsquo;état initial, l\u0026rsquo;état 0, et on va suivre les transitions, caractères après caractères, en cherchant un chemin qui nous mène vers l\u0026rsquo;état d\u0026rsquo;acceptation 7 après avoir lu tous les caractères du mot m.\n   À Partir de l\u0026rsquo;état 0, il n\u0026rsquo;y a qu\u0026rsquo;une seule transition, il n\u0026rsquo;y a donc pas le choix. Le mot doit donc forcément commencer par /, car c\u0026rsquo;est le symbole sur cette transition. Une fois cette transition passée, on se trouve dans l\u0026rsquo;état 1 et il nous reste à analyser la partie */*/ de m.     À Partir de l\u0026rsquo;état 1, il n\u0026rsquo;y a aussi qu\u0026rsquo;une seule transition possible. On doit donc forcément avoir le symbole * dans ce qu\u0026rsquo;il nous reste à analyser */*/, car c\u0026rsquo;est le symbole sur la seule transition partant de l\u0026rsquo;état 1. Une fois cette transition passée, on se trouve dans l\u0026rsquo;état 2 et il nous reste à analyser la partie /*/ de m.     L\u0026rsquo;état 2 possède trois transitions sortantes. Elles sont toutes les trois labelées avec le symbole $\\epsilon$. Ce symbole signifie que l\u0026rsquo;on ne modifie pas l\u0026rsquo;entrée lorsque l\u0026rsquo;on passe par une telle transition. On peut voir maintenant pourquoi l\u0026rsquo;automate est non déterministe car sur le même symbole, ici $\\epsilon$, on a le choix entre plusieurs transitions. Comment faire pour s\u0026rsquo;orienter ? On va supposer pour le moment que l\u0026rsquo;on a des dons de clairvoyance et que l\u0026rsquo;on va choisir la bonne transition, qui est celle vers l\u0026rsquo;état 4. On verra dans les vidéos comment automatiser cela.     Dans l\u0026rsquo;état 4 nous avons encore le choix entre deux transitions : ne pas consommer un caractère de l\u0026rsquo;entrée en prenant la transition $\\epsilon$, ou consommer le caractère / en bouclant sur l\u0026rsquo;état 4. Comme nous sommes devin, nous allons boucler sur l\u0026rsquo;état 4 et consommer le /.     Maintenant, l\u0026rsquo;entrée qu\u0026rsquo;il nous reste à consommer est */. Nous allons prendre la transition $\\epsilon$ jusqu\u0026rsquo;à l\u0026rsquo;état 2, puis la transition $\\epsilon$ de l\u0026rsquo;état 2 vers l\u0026rsquo;état 3. Encore une fois on ne se préoccupe pas pour l\u0026rsquo;instant du comment faire les bons choix de transitions lorsqu\u0026rsquo;il y a plus d\u0026rsquo;une possibilité. Nous nous retrouvons dans la configuration ci-dessous, où le curseur sous la chaîne d\u0026rsquo;entrée n\u0026rsquo;a pas bougé.     Dans l\u0026rsquo;état 5, nous n\u0026rsquo;avons qu\u0026rsquo;une transition sortante sur le caractère *. Le curseur sur l\u0026rsquo;entrée est placé sur le *, on peut donc prendre cette transition et déplacer le curseur vers la droite. Il nous reste maintenant simplement à reconnaître le /.     Dans l\u0026rsquo;état 6, il n\u0026rsquo;y a là aussi qu\u0026rsquo;une seule transition sur le symbole /. Comme le curseur sur l\u0026rsquo;entrée pointe sur un caractère /, on peut prendre cette transition et se placer sur l\u0026rsquo;état final 7.     Comme la chaîne d\u0026rsquo;entrée est maintenant vide et que nous sommes dans un état d\u0026rsquo;acceptation, on peut conclure que le mot /*/*/ appartient bien au langage $\\mathcal{L}(A_{fnd})$. Le mot /*/*/ est donc bien un commentaire.  La chaîne d\u0026rsquo;entrée /*/*/ est acceptée par notre automate, mais comment sait-on si une chaîne n\u0026rsquo;est pas dans le langage $\\mathcal{L}(A_{fnd})$, autrement dit comment sait-on si le mot n\u0026rsquo;est pas accepté ? Pour un automate non déterministe, il faut montrer qu\u0026rsquo;après avoir lu tous les caractères de la chaîne d\u0026rsquo;entrée, on ne peut pas être dans un état d\u0026rsquo;acceptation.\nIl nous semble plus aisé de construire l\u0026rsquo;automate fini non déterministe que nous venons de voir pour décrire le langage des commentaires que l\u0026rsquo;expression régulière $/*\\color{darkgreen}{(}*^{\\color{darkgreen}{+}}\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}\\ \\color{darkgreen}{|}\\ \\color{darkgreen}{(}a\\ |\\ b\\ |\\ /\\color{darkgreen}{)}\\color{darkgreen}{)}^{\\color{darkgreen}{*}}*^{\\color{darkgreen}{+}}/$ que nous avions vu dans la section précedente. Après, vous êtes peut-être des gourous de Perl1 et c\u0026rsquo;est juste trop facile pour vous .\n Perl signifie Practical Extraction and Report Language, ou Pathologically Eclectic Rubbish Lister . [return]    Nous allons détailler dans les deux vidéos suivantes les automates finis non déterministes, et comment détecter si un mot appartient ou non au langage engendré par un automate fini non déterministe.\n    Dans la vidéo suivante, nous allons montrer comment passer d\u0026rsquo;une expression régulière à un automate fini non déterministe.\n  Questions   Soit l\u0026#39;alphabet $\\{a, b\\}$. Construire un automate qui reconnait le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient le mot $aba$ $\\}$. Par exemple, $aba$ est dans le langage, ainsi que $bbbbbaabaaaabb$, mais pas $babbbaaa$.     Notons que cet automate calque vraiment l\u0026rsquo;expression régulière $\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}aba\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}$.\n    Soit l\u0026#39;alphabet $\\{a, b\\}$. Construire un automate qui reconnait le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ ne contient pas le mot $aba$ sauf s\u0026#39;il est précédé par le mot $bbb$ $\\}$. Par exemple, $aaabbbaabaa$ est dans le langage, $abba$ aussi, mais pas $bbababbb$.      La partie haute de l\u0026rsquo;automate, les états 1, 2, 3 et 4, permet de reconnaître une suite de trois b suivie de n\u0026rsquo;importe quoi. La partie basse s\u0026rsquo;occupe de reconnaître tout sauf aba. L\u0026rsquo;état 5 indique que l\u0026rsquo;on a pas encore vu de a ou bien que l\u0026rsquo;on vient de rencontrer une séquence se terminant par bb (on est donc sûr de ne pas avoir vu une séquence se terminant par ab). L\u0026rsquo;état 6 indique qu\u0026rsquo;on est en train d\u0026rsquo;analyser une suite d\u0026rsquo;au moins un a et l\u0026rsquo;état 7 qu\u0026rsquo;on vient de voir ab, donc qu\u0026rsquo;on ne doit pas avoir un a maintenant). À partir des états 5, 6 et 7 on peut rejoindre la partie haute de l\u0026rsquo;automate car on vient d\u0026rsquo;analyser un préfixe correcte et on peut vouloir ajouter aba dans la suite (en ajoutant bbb avant).\nComment être sûr que la partie basse reconnaît bien tout sauf aba ? Pour la partie haute, il est assez facile de se convaincre qu\u0026rsquo;elle reconnaît bien $bbb\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}$. Mais ce n\u0026rsquo;est pas si évident de se convaincre que la partie basse décrit bien tout sauf la chaîne aba. Quand on veut vraiment être sûr, il n\u0026rsquo;y a qu\u0026rsquo;un moyen, c\u0026rsquo;est faire une preuve !1\nOn va faire une preuve par récurrence sur la longueur de la chaîne. Pour une chaîne de longueur 0 ($\\epsilon$) de longueur 1 ($a$ et $b$) et de longueur 2 ($aa$, $ab$, $ba$ et $bb$), on peut suivre les transitions à partir de l\u0026rsquo;état 0 vers la partie basse et voir qu\u0026rsquo;on les reconnaît toutes et elles n\u0026rsquo;ont pas aba dedans (car la longueur de la chaîne est inférieure ou égale à 2). Supposons que la propriété est vraie pour les chaînes de longueur $n \\ge 2$, est-ce vraie pour les chaînes de longueur $n + 1$ ? Regardons les deux derniers caractères de la chaîne m de longueur $n$.\n m se termine par aa. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 6 comme indiqué ci-dessus. On peut ajouter un a et accepter la nouvelle chaîne ma car on reste dans l\u0026rsquo;état 6 qui est un état d\u0026rsquo;acceptation, et on peut aussi ajouter un b et accepter la chaîne mb car on se retrouve dans l\u0026rsquo;état 7 qui est aussi un état d\u0026rsquo;acceptation.\n m se termine par ab. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 7 comme indiqué ci-dessus. On ne peut pas ajouter de a car il n\u0026rsquo;y a aucune transition sur un a à partir de l\u0026rsquo;état 7 et donc on ne reconnaîtra pas une chaîne contenant aba. On peut par contre ajouter un b et bien reconnaître la chaîne de longueur $n+1$ mb.\n m se termine par ba. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 6 comme indiqué ci-dessus et on peut ajouter un a ou bien un b pour obtenir la chaîne de longueur $n+1$ ma ou mb.\n m se termine par bb. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 5 comme indiqué ci-dessus et on peut ajouter un a ou bien un b pour obtenir la chaîne de longueur $n+1$ ma ou mb.\n  En supposant donc qu\u0026rsquo;on peut générer tous les mots de longueur $n$ ne contenant pas aba, on vient de montrer qu\u0026rsquo;on peut générer tous les mots de longueur $n+1$ ne contenant pas aba.\n Vous me direz qu\u0026rsquo;il faut encore qu\u0026rsquo;elle soit correcte. C\u0026rsquo;est pas faux , mais dans une preuve il faut juste se convaincre que chaque étape élémentaire est correcte. [return]     Automates finis déterministes Les automates finis déterministes sont un sous-ensemble des automates finis non-déterministes. L\u0026rsquo;intérêt de ces automates, c\u0026rsquo;est de ne plus avoir besoin de \u0026ldquo;deviner\u0026rdquo; la bonne transition à suivre car, dans un état donné et pour un symbole donné de l\u0026rsquo;entrée, il n\u0026rsquo;y a au plus qu\u0026rsquo;une transition possible. Comme nous l\u0026rsquo;avons vu dans la section précédente, on peut en réalité se servir d\u0026rsquo;un automate non-déterministe sans avoir besoin de deviner. L\u0026rsquo;algorithme que nous avons vu permet en fait de construire dynamiquement un automate fini déterministe. L\u0026rsquo;intérêt de partir directement d\u0026rsquo;un automate déterministe, c\u0026rsquo;est que l\u0026rsquo;on n\u0026rsquo;a pas besoin de reconstruire à chaque fois ce dernier. Ce sera d\u0026rsquo;autant plus intéressant pour un analyseur lexical car les expressions régulières permettant de décrire les unités lexicales ne changeront pas et on gagnera en efficacité en construisant une fois pour toute les automates correspondants aux expressions régulières.\nL\u0026rsquo;automate suivant est une version déterministe de l\u0026rsquo;automate non-déterministe qui reconnaît les commentaires en C de la section précédente.\n  Comme les automates finis déterministes sont une restriction des automates finis non-déterministes, on pourrait à juste titre croire qu\u0026rsquo;ils permettent de décrire moins de langages. En fait ce n\u0026rsquo;est pas le cas et ils sont aussi puissants que les automates finis non-déterministes.\nLa vidéo ci-dessous va décrire les automates finis déterministe et montrer comment transformer un automate non-déterministe en un automate déterministe.\n  Le code utilisé dans la vidéo précédente est accessible ici.\nDans la vidéo suivante, nous allons montrer comment fonctionne un analyseur lexical et comment obtenir un automate fini déterministe de taille minimale.\n   Dans les vidéos suivantes, nous allons coder en C++ un analyseur lexical pour la partie du langage présentée dans la vidéo précédente. Le code utilisé dans cette vidéo est accessible ici.\n      Questions    Soit l\u0026#39;alphabet $\\{a, b\\}$. Construire un automate qui reconnait le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient un nombre impair de $a$ et un nombre pair de $b \\}$. Par exemple, $abb$ est dans le langage, ainsi que $bbabbaa$ et $aaaaa$, mais pas $b$ ni $aabb$.     Dans l\u0026rsquo;automate ci-dessus, on a un état par configuration possible de la parité des $a$ et des $b$. Par exemple, l\u0026rsquo;état d\u0026rsquo;acceptation $IP$ indique que l\u0026rsquo;on a rencontré un nombre impair de $a$ et un nombre pair de $b$. L\u0026rsquo;état de départ $PP$ indique que l\u0026rsquo;on a vu un nombre pair de $a$ et de $b$. C\u0026rsquo;est vrai tout au début aussi, car on a alors rencontré aucun $a$ et aucun $b$.\n \n  Soit l\u0026#39;expression régulière $\\color{darkgreen}{0^*(100^*)^*(1|\\epsilon)}$ décrivant les chaînes de bits sur l\u0026#39;alphabet $\\{0, 1\\}$ ne contenant pas la sous-chaîne $11$. Transformer cette expression régulière en un automate fini non-déterministe, puis transformer ce dernier en un automate fini déterministe et pour terminer, minimiser ce dernier.   La transformation de l\u0026rsquo;expression régulière en un automate fini non-déterministe donne l\u0026rsquo;automate suivant. Notons que nous avons pris quelques libertés avec les transformations que nous avions vu dans la vidéo pour réduire un peu la taille de l\u0026rsquo;automate, mais la transformation est très similaire à ce que nous avions vu.\n  L\u0026rsquo;automate fini déterministe correspondant (en utilisant la transformation que nous avons vu) est donné ci-dessous.\n\n  Dans cet automate, par exemple, l\u0026rsquo;état $0$ correspond à l\u0026rsquo;ensemble des états $\\{0,1,3,4,10,11\\}$ de l\u0026rsquo;automate fini non-déterministe et l\u0026rsquo;état $4$ correspond à l\u0026rsquo;ensemble $\\{8,7,9,4,10,11\\}$.\nIl nous reste maintenant à minimiser cet automate. Nous allons tout d\u0026rsquo;abord rendre explicite l\u0026rsquo;état puits que nous allons noter P, qui est implicite dans la figure ci-dessus représentant l\u0026rsquo;automate déterministe. C\u0026rsquo;est l\u0026rsquo;état qui est atteint sur une transition qui n\u0026rsquo;est pas indiquée dans l\u0026rsquo;automate de la figure. Si nous rendons explicite cet état, nous obtenons l\u0026rsquo;automate équivalent suivant :\n  Nous allons tout d\u0026rsquo;abord considérer les deux ensembles d\u0026rsquo;états que nous pouvons tout de suite distinguer : les états terminaux et les états non terminaux. On obtient les deux groupes suivants.\n $G_1 = \\{0,1,2,3,4\\}$ $G_2 = \\{P\\}$  Pour le groupe $G_1$, les états $0,1,3$ et $4$ transitionnent vers un des états du groupe $G_1$ sur un 0 ou un 1. Par contre, l\u0026rsquo;état $2$ lui transitionne vers le groupe $G_2$ sur un 1. Le groupe $G_1$ va devoir donc être scindé. Le groupe $G_2$ ne possède qu\u0026rsquo;un élément, il reste donc inchangé. On obtient maintenant les trois groupes suivants.\n $G_{1,1} = \\{0,1,3,4\\}$ $G_{1,2} = \\{2\\}$ $G_2 = \\{P\\}$  Dans le groupe $G_{1,1}$, on a\n $0 \\xrightarrow[]{0} G_{1,1}$ $1 \\xrightarrow[]{0} G_{1,1}$ $3 \\xrightarrow[]{0} G_{1,1}$ $4 \\xrightarrow[]{0} G_{1,1}$ $0 \\xrightarrow[]{1} G_{1,2}$ $1 \\xrightarrow[]{1} G_{1,2}$ $3 \\xrightarrow[]{1} G_{1,2}$ $4 \\xrightarrow[]{1} G_{1,2}$  L\u0026rsquo;état $G_{1,1}$ n\u0026rsquo;a donc pas besoin d\u0026rsquo;être scindé d\u0026rsquo;avantage car les transitions sur 0 comme sur 1 font transitionner chacun des états de $G_{1,1}$ dans le même groupe. Il ne reste plus aucun groupe pouvant être scindé, on a donc fini la minimisation. Les états $0, 1, 3$ et $4$ vont donc être regroupés dans un seul état. L\u0026rsquo;automate obtenu après minimisation est donné ci-dessous (nous ne faisons pas apparaître l\u0026rsquo;état puits).\n  Si l\u0026rsquo;on interprète cet automate, on peut voir que l\u0026rsquo;état $0$ indique que l\u0026rsquo;on vient de rencontrer un zéro, ou bien que l\u0026rsquo;on n\u0026rsquo;a encore rien lu. Quant à l\u0026rsquo;état $2$, il indique que l\u0026rsquo;on vient de rencontrer un $1$.\n  Passage d\u0026rsquo;un automate à une expression régulière Nous pouvons construire automatiquement l\u0026rsquo;expression régulière correspondant à un automate fini (déterministe ou non-déterministe). Nous montrons ci-dessous une suite de transformations permettant de passer de l\u0026rsquo;automate fini déterministe correspondant aux commentaires en C vu plus haut, vers une expression régulière équivalente. Nous détaillerons dans la vidéo ci-dessous cette transformation.\nOn peut voir sur les transitions apparaître des expressions régulières au fur et à mesure des transformations. Pour ne pas confondre le caractère * avec l\u0026rsquo;opérateur *, nous avons écrit l\u0026rsquo;opérateur en vert.\n --  --  --   Tout d\u0026rsquo;abord, nous allons réécrire l\u0026rsquo;automate en faisant apparaître clairement les expressions régulières représentant les alternatives sur les transitions.\n  Nous allons maintenant éliminer tour à tour des états pour arriver à un automate ne contenant plus que deux états: un état initial et un état d\u0026rsquo;acceptation.\nPour éliminer l\u0026rsquo;état $q = \\{3,5,6\\}$, il faut regarder pour chaque paire d\u0026rsquo;états $(q_1, q_2)$ s\u0026rsquo;il existe un arc entre $q_1$ et $q$ et entre $q$ et $q_2$. Il faut alors maintenir cette information en modifiant l\u0026rsquo;arc entre $q_1$ et $q_2$.\nPar exemple, ici, on va devoir considérer le chemin $\\{2,3,4,5\\}\\rightarrow q \\rightarrow \\{7\\}$ et ajouter l\u0026rsquo;expression régulière $**^{\\color{darkgreen}{*}}/$ entre les états $\\{2,3,4,5\\}$ et $\\{7\\}$ afin de conserver la même information. On doit aussi considérer le chemin $\\{2,3,4,5\\}\\rightarrow q \\rightarrow \\{2,3,4,5\\}$ et ajouter l\u0026rsquo;expression régulière $**^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}a\\mbox{ }{\\color{darkgreen}{|}}\\mbox{ }b{\\color{darkgreen}{)}}$ sur la boucle de l\u0026rsquo;état $\\{2,3,4,5\\}$. On obtient alors l\u0026rsquo;automate suivant.\n  En éliminant l\u0026rsquo;état $\\{2,3,4,5\\}$ on obtient alors l\u0026rsquo;automate suivant.\n  Et enfin, en éliminant l\u0026rsquo;état $\\{1\\}$, on obtient l\u0026rsquo;expression régulière finale qui se trouve sur l\u0026rsquo;arc reliant l\u0026rsquo;état de départ à l\u0026rsquo;état d\u0026rsquo;acceptation.\n  La vidéo suivante va détailler cette construction.\n  Les prochaines vidéos vont détailler un programme en OCaml permettant de transformer un automate en une expression régulière en utilisant l\u0026rsquo;algorithme de Floyd-Warshall.\nLa vidéo suivante présente l\u0026rsquo;algorithme de fermeture transitive de Floyd-Warshall sur un graphe pour présenter plus simplement les concepts avant de passer à la création automatique des expressions régulières à partir de l\u0026rsquo;automate. Le code présenté dans la vidéo se trouve ici.\n  La vidéo suivante décrit le code qui permet de transformer un automate en une expression régulière. Le code se trouve ici, et le petit script python permettant de transformer notre représentation en celle attendue sur ce site se trouve ici.\n  Questions   Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner un automate déterministe permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient un nombre pair de $a$ $\\}$. Transformer ensuite cet automate en une expression régulière.   Nous avions déjà rencontré ce langage dans la section sur les expressions régulières dans cette question.\nL\u0026rsquo;automate suivant permet de représenter le langage des mots sur le vocabulaire $\\{a, b\\}$ où le nombre de $a$ est pair.\n  Les différentes étapes de la transformation de l\u0026rsquo;automate vers une expression régulière équivalente sont données ci-dessous.\n      On obtient donc l\u0026rsquo;expression régulière ${\\color{darkgreen}{(}}b\\ {\\color{darkgreen}{|}}\\ ab^{\\color{darkgreen}{*}}a{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}$. C\u0026rsquo;est ce que l\u0026rsquo;on avait obtenu comme réponse à cette question. C\u0026rsquo;est pas étonnant, car nous avions procédé comme ici pour obtenir l\u0026rsquo;expression régulière .\n    Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner un automate déterministe permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ ne contient pas un nombre impair de $a$ ou ne contient pas un nombre pair de $b \\}$. Transformer ensuite cet automate en une expression régulière. Notons que ce langage est le complémentaire du langage $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient un nombre impair de $a$ et un nombre pair de $b \\}$ que nous avions déjà rencontré.   L\u0026rsquo;automate suivant permet de représenter ce langage. Notons que cet automate est l\u0026rsquo;automate que nous avions rencontré dans cette question avec les états d\u0026rsquo;acceptations qui sont devenus des états normaux et les états normaux qui sont devenus d\u0026rsquo;acceptations.\n  Les différentes étapes de la transformation de l\u0026rsquo;automate vers une expression régulière équivalente sont données ci-dessous.\n          L\u0026rsquo;expression régulière obtenue est donc la suivante.\n${\\color{darkgreen}{(}}aa\\ {\\color{darkgreen}{|}}\\ bb\\ {\\color{darkgreen}{|}}\\ {\\color{darkgreen}{(}}ab\\ {\\color{darkgreen}{|}}\\ ba{\\color{darkgreen}{)}}{\\color{darkgreen}{(}}bb\\ {\\color{darkgreen}{|}}\\ aa{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}ba\\ {\\color{darkgreen}{|}}\\ ab{\\color{darkgreen}{)}}{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}\\epsilon\\ {\\color{darkgreen}{|}}\\ b\\ {\\color{darkgreen}{|}}\\ {\\color{darkgreen}{(}}ab\\ {\\color{darkgreen}{|}}\\ ba{\\color{darkgreen}{)}}{\\color{darkgreen}{(}}bb\\ {\\color{darkgreen}{|}}\\ aa{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}\\epsilon\\ {\\color{darkgreen}{|}}\\ a{\\color{darkgreen}{)}}{\\color{darkgreen}{)}}$\nPour vérifier que l\u0026rsquo;on a pas fait d\u0026rsquo;erreurs durant la transformation, on peut utiliser le site suivant et passer de l\u0026rsquo;expression régulière vers un automate minimal pour voir si l\u0026rsquo;on reconnaît notre automate de départ. Si vous faites cela, vous verrez qu\u0026rsquo;on retrouve le même automate (avec des noms d\u0026rsquo;états différents).\n  Identification de motifs Nous allons mettre en pratique les notions que nous venons de voir sur les expressions régulières et les automates en réalisant une petite application permettant de tester si une chaîne de caractères vérifie ou non un motif représenté par une expression régulière.\nNous allons présenter une séquence d\u0026rsquo;intéractions dans l\u0026rsquo;interpréteur OCaml que nous pourrons réaliser grâce à cette application.\n1utop # let re = RE.regex_from_string \u0026#34;0*(100*)*1?\u0026#34;;; 2val re : RE.regex = 3 RE.Concatenation (RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;), 4 RE.Concatenation 5 (RE.ZeroOrMore 6 (RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, 7 RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, 8 RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;)))), 9 RE.ZeroOrOne (RE.CharSet \u0026lt;abstr\u0026gt;))) À la ligne 1, on crée l\u0026rsquo;expression régulière $\\color{darkgreen}{0^*(100^*)^*(1|\\epsilon)}$ qui permet de représenter les mots sur ne contenant pas de 1 consécutifs. Notons que nous utilisons la notation 1? pour représenter $\\color{darkgreen}{(1|\\epsilon)}$.\nOn crée ensuite un automate fini non-déterministe équivalent.\nutop # let nfa = NFA.init re;; val nfa : NFA.t = \u0026lt;abstr\u0026gt; On peut ensuite tester si une chaîne de caractères, ici 101010 appartient ou non au langage engendré par l\u0026rsquo;automate fini non-déterministe et donc par l\u0026rsquo;expression régulière.\nutop # NFA.full_match nfa \u0026#34;101010\u0026#34;;; - : bool = true On voit dans l\u0026rsquo;exemple suivant, que la chaîne 011111100100, contenant des 1 consécutifs, n\u0026rsquo;est pas représenté par l\u0026rsquo;expression régulière.\nutop # NFA.full_match nfa \u0026#34;011111100100\u0026#34;;; - : bool = false On peut chercher une sous-chaîne dans une chaîne de caractères en entourant une expression de l\u0026rsquo;expression .*. Le . représente n\u0026rsquo;importe quel caractère. L\u0026rsquo;exemple suivant va définir une expression régulière permettant de rechercher la sous-chaîne Doc4\nutop # let re = RE.regex_from_string \u0026#34;.*Doc.*\u0026#34;;; val re : RE.regex = RE.Concatenation (RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;), RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;))))) utop # let dfa = DFA.init re;; val dfa : DFA.t = \u0026lt;abstr\u0026gt; utop # DFA.full_match dfa \u0026#34;Wait a minute, Doc. Ah... Are you telling me that you built a time machine... out of a DeLorean?\u0026#34;;; - : bool = true utop # DFA.full_match dfa \u0026#34;The way I see it, if you\u0026#39;re gonna build a time machine into a car, why not do it with some style?\u0026#34;;; - : bool = false Le code qui sera expliqué dans les vidéos suivantes se trouve ici.\nDans la vidéo suivante, nous allons présenter une vue d\u0026rsquo;ensemble de l\u0026rsquo;application et détailler le passage d\u0026rsquo;une chaîne de caractères représentant une expression règulière, vers une représentation OCaml de cette expression régulière. La grammaire décrivant les expressions régulières se trouve ici.\n  Dans la vidéo suivante, nous présentons la notion de programmation par continuation que nous allons utiliser dans le module de reconnaissance de motifs basé sur du retour arrière. Le code pour illustrer les continuations se trouve ici.\nIl y a la solution à une des questions que nous posons dans la vidéo à la fin du listing sur les continuations.\n   Dans la vidéo suivante, nous allons décrire le module de reconnaissance de motifs basé sur du retour arrière et des continuations.\n  Dans la vidéo suivante, nous allons décrire le module de reconnaissance de motifs basé sur des automates finis non-déterministes.\n  Dans la vidéo suivante, nous allons décrire le module de reconnaissance de motifs basé sur des automates finis déterministes.\n  Dans la vidéo suivante, nous allons montrer comment nous avons testé nos différents modules.\n  Questions Le code ci-dessous décrit la partie de la fonction regex_from_string qui s\u0026rsquo;occupe de reconnaître les concaténations à partir de la liste de caractères.\n1and re1 l = 2 let e, l = re2 l in 3 let e, l = 4 let rec re1\u0026#39; e l = 5 match l with 6 | \u0026#39;?\u0026#39; :: r -\u0026gt; re1\u0026#39; (ZeroOrOne e) r 7 | \u0026#39;*\u0026#39; :: r -\u0026gt; re1\u0026#39; (ZeroOrMore e) r 8 | \u0026#39;+\u0026#39; :: r -\u0026gt; re1\u0026#39; (OneOrMore e) r 9 | _ -\u0026gt; e, l 10 in 11 re1\u0026#39; e l 12 in 13 match l with 14 | c :: _ when c \u0026lt;\u0026gt; \u0026#39;)\u0026#39; \u0026amp;\u0026amp; c \u0026lt;\u0026gt; \u0026#39;|\u0026#39; -\u0026gt; 15 let e\u0026#39;, l = re1 l in 16 Concatenation (e, e\u0026#39;), l 17 | _ -\u0026gt; 18 e, l   Durant la vidéo, nous avons dit que les deux cas qui permettaient de savoir s\u0026#39;il n\u0026#39;y avait plus de nouvelles concaténations à gérer, à la ligne 17, était si le prochain caractère était une barre verticale ou la parenthèse fermante. Il y a un autre cas, que le code gère bien, mais dont nous n\u0026#39;avons pas parlé. Quel est ce dernier cas ?   S\u0026rsquo;il n\u0026rsquo;y a plus de caractères, autrement dit si la liste l est vide à la ligne 13, on n\u0026rsquo;a plus aucune concaténation possible. Ce cas est bien géré à la ligne 17, car le test à la ligne 14 nécessite au moins un caractère pour pouvoir réussir.\n    Pour le module d\u0026#39;indentification de motifs par retour arrière, nous avons vu que que pour l\u0026#39;expression régulière $\\color{green}{(a?)^{40}a^{40}}$ (le 40 en exposant indique que l\u0026#39;on répète la chaîne quarante fois) et la chaîne d\u0026#39;entrée $a^{40}$ on obtenait un temps d\u0026#39;exécution prohibitif. Pouvez-vous trouver une autre expression régulière et une autre chaîne d\u0026#39;entrée qui donneraient lieu aussi à un temps d\u0026#39;exécution très long ?   Par exemple, l\u0026rsquo;expression régulière $\\color{green}{a^{++}}$ donne lieu à un temps prohibitif sur la chaîne d\u0026rsquo;entrée aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab.\nComment expliquer ce comportement ?\nOn peut visualiser l\u0026rsquo;expression régulière $\\color{green}{(a^+)^+}$ comme l\u0026rsquo;hypothétique expression régulière suivante $\\color{green}{aa^*\\ |\\ aa^*aa^* \\ |\\ aa^*aa^*aa^*\\ |\\ aa^*aa^*aa^*aa^*\\ |\\ \\cdots}$. Si on prend la sous-expression $\\color{green}{aa^*aa^*}$, le premier $\\color{green}{aa^*}$ va d\u0026rsquo;abord consommer tous les a et le deuxième $\\color{green}{aa^*}$ va alors échouer car il y a un b dans l\u0026rsquo;entrée. Maintenant, le premier $\\color{green}{aa^*}$ va laisser un seul a et le deuxième va consommer le dernier et on va échouer car il reste un b en entrée alors qu\u0026rsquo;on a fini d\u0026rsquo;analyser l\u0026rsquo;expression régulière. Maintenant, le premier $\\color{green}{aa^*}$ va laisser deux a dans l\u0026rsquo;entrée et le deuxième $\\color{green}{aa^*}$ va consommer les deux derniers et échouer, puis un seul et échouer aussi. Du coup, le premier $\\color{green}{aa^*}$ va laisser trois a dans l\u0026rsquo;entrée et le deuxième $\\color{green}{aa^*}$ va d\u0026rsquo;abord consommer les trois a et échouer, puis essayer en consommant que deux a et échouer, puis un seul a et échouer aussi. Et Maintenant, le premier $\\color{green}{aa^*}$ va laisser quatre a et ainsi de suite. Le nombre de tentatives va être encore plus important avec la sous-expression $\\color{green}{aa^*aa^*aa^*}$.\nNotons que dans notre implémentation du module Backtracking, nous avons le code suivant.\n1| ZeroOrMore t1 -\u0026gt; 2 full_match t1 l (fun l\u0026#39; -\u0026gt; l \u0026lt;\u0026gt; l\u0026#39; \u0026amp;\u0026amp; full_match t l\u0026#39; k) 3 || k l Inverser les lignes 2 et 3 comme ci-dessous donne toujours lieu à un temps prohibitif contrairement à ce qu\u0026rsquo;on avait vu pour l\u0026rsquo;expression $\\color{green}{(a?)^{40}a^{40}}$ et la chaîne d\u0026rsquo;entrée $a^{40}$ lorsqu\u0026rsquo;on avait fait une inversion équivalente pour ZeroOrOne t1.\n1| ZeroOrMore t1 -\u0026gt; 2 k l 3 || full_match t1 l (fun l\u0026#39; -\u0026gt; l \u0026lt;\u0026gt; l\u0026#39; \u0026amp;\u0026amp; full_match t l\u0026#39; k)   Dans notre module DFA, nous mémorisons les transitions déjà rencontrées grâce au module Memo dont la définition est rappelée ci-dessous.\n1module Memo = 2 Map.Make( 3 struct 4 type t = S.t * char 5 let compare (s1, c1) (s2, c2) = 6 let res = compare c1 c2 in 7 if res = 0 then 8 S.compare s1 s2 9 else 10 res 11 end) La fonction de comparaison des clés dans cette table, définie à partir de la ligne 5, peut nécessiter de comparer des ensembles à la ligne 8. Lorsque l\u0026rsquo;on se trouve dans un état donné de l\u0026rsquo;automate fini déterministe, il est suffisant de regarder si la transition sur un caractère particulier a déjà été rencontrée. Il est donc inutile de comparer des ensembles et de devoir avoir, pour chaque transition à partir du même état, une clé qui contienne l\u0026rsquo;état et le caractère.\nPour éviter de créer une table qui nécessite comme clé un état et un caractère, il faudrait associer à chaque état de l\u0026rsquo;automate fini déterministe (qui est un ensemble d\u0026rsquo;états de l\u0026rsquo;automate fini non-déterministe) une table. Les clés de cette table seront des caractères, et celle-ci permettra de stocker les transitions déjà rencontrées.\nLe nouveau module que nous souhaitons réaliser sera le suivant.\nmodule DFA2 : Matching = struct (* À faire *) end   Votre mission, si vous l\u0026#39;acceptez, est de coder ce module permettant d\u0026#39;implémenter notre nouvelle idée.   Une solution possible se trouve ici. Le fichier pour tester en prenant en compte le nouveau module se trouve quant à lui ici.\n  Analyseur lexical avec ocamllex Nous allons décrire maintenant l\u0026rsquo;analyseur lexical de MiniJava qui est réalisé à l\u0026rsquo;aide d\u0026rsquo;ocamllex. L\u0026rsquo;outil ocamllex est un générateur d\u0026rsquo;analyseur lexical. On lui donne une liste d\u0026rsquo;expressions régulières avec des actions à réaliser lorsque une expression régulière est reconnue. L\u0026rsquo;outil va alors générer automatiquement un analyseur lexical qui ressemble, en gros, au programme lexer.cpp que l\u0026rsquo;on avait étudié plus haut.\nLe programme suivant montre un programme MiniJava, Lexical.java, non valide, mais qui est néanmoins lexicalement correct.\n class /*/*/ public 123MrC00der; while )( { int int42 [] // this sentence is false\nSi on exécute la commande ./mini-java --show-tokens-with-loc Lexical.java pour lancer notre transpileur mini-java avec pour option de ne sortir que les unités lexicale produite par l\u0026rsquo;analyseur lexical, nous obtenons les unités lexicales suivantes5.\nCLASS PUBLIC INT_CONST ‘123‘ IDENT ‘MrC00der‘ ▸ line 3, char 11 ◂ SEMICOLON WHILE RPAREN LPAREN LBRACE INTEGER IDENT ‘int42‘ ▸ line 6, char 1 ◂ LBRACKET RBRACKET EOF Les unités lexicales seront utilisées par l\u0026rsquo;analyseur syntaxique que nous étudierons dans le prochain chapitre.\nLa vidéo suivante va présenter ocamllex et l\u0026rsquo;analyseur lexical de notre transpileur. Le code de la calculatrice en notation polonaise inverse se trouve ici.\n  Questions   Supposons que dans l\u0026#39;analyseur lexical, on n\u0026#39;utilise pas la règle du plus long appariement (l\u0026#39;expression régulière qui reconnaît le plus de caractères est sélectionnée), mais la règle du plus court appariement. Pourquoi ne pourrions nous pas reconnaître correctement les unités lexicales de MiniJava ?   On peut essayer en modifiant le fichier lexer.mll de notre transpileur en utilisant l\u0026rsquo;option du plus court appariement. On remplace alors la ligne\nrule get_token = parse par la ligne\nrule get_token = shortest Reprenons maintenant l\u0026rsquo;exemple que nous avions vu plus haut. Si on recompile notre transpileur et que l\u0026rsquo;on exécute la commande ci-dessous,\n./mini-java --show-tokens-with-loc Lexical.java on obtient la sortie suivante.\nIDENT ‘c‘ ▸ line 1, char 1 ◂ IDENT ‘l‘ ▸ line 1, char 2 ◂ IDENT ‘a‘ ▸ line 1, char 3 ◂ IDENT ‘s‘ ▸ line 1, char 4 ◂ IDENT ‘s‘ ▸ line 1, char 5 ◂ Lexical error file \u0026#34;Lexical.java\u0026#34;, line 2, character 1: Illegal character: /. Notre analyseur lexical, avec la règle du plus court appariement, reconnaît chaque caractère du mot clé class comme un identifiant. Lorsqu\u0026rsquo;il rencontre le / du commentaire, il ne peut pas reconnaître un identifiant et il passe donc à la prochaine règle permettant de reconnaître un seul caractère qui est la règle ci-dessous.\n| _ as c { raise (Error (\u0026#34;Illegal character: \u0026#34; ^ String.make 1 c)) }   On souhaite écrire un programme, en utilisant ocamllex, qui nous permette de remplacer les tabulations par quatre espaces et de supprimer les espaces et les tabulations avant les fins de ligne. Par exemple, supposons que nous ayons un fichier fichier.txt. Le contenu du fichier est indiqué ci-dessous. On utilise la commande cat d\u0026rsquo;unix pour afficher les tabulations représentée par ^I et les retours à la ligne représentés par $.\ncat -ET fichier.txt Je vous souhaite^I ^I$ une très belle^I^I année^I $ ^I$ $ Si le fichier ocamllex se nomme clean.mll, on le compilera comme indiqué ci-dessous.\nocamllex clean.mll ocamlopt clean.ml -o clean On utilisera ensuite le programme clean sur un fichier fichier.txt par exemple, comme suit.\n./clean \u0026lt; fichier.txt \u0026gt; res.txt On obtiendra alors dans le fichier res.txt le contenu du fichier fichier.txt où les tabulations auront été transformées en quatre espaces, et où on aura supprimé les espaces et les tabulations avant les fins de ligne.\ncat -ET res.txt Je vous souhaite$ une très belle année$ $ $   Réaliser le programme permettant de remplacer les tabulations par quatre espaces et de supprimer les espaces et les tabulations en fin de ligne.   Le fichier ocamllex suivant répond à la question.\n  Ressources Jouer avec les expressions régulières\nTester des expressions régulières\nGénérer des exemples et contre-exemples pour une expression régulière donnée\nTransformer des expressions régulières en automates\nRuss Cox on regular expression matching\nApprendre OCaml\nEssayer OCaml\nCours sur la programmation fonctionnelle utilisant OCaml\nDocumentation d\u0026rsquo;OCaml\nDocumentation de ocamllex\nPartie sur ocamllex dans Real World OCaml\nISO C++\nC++ bonnes pratiques\nC++ standard\n  Le mot vide est l\u0026rsquo;équivalent de la chaîne de caractères \u0026quot;\u0026quot;. [return] Une expression régulière doit être de taille finie. [return] fnd pour fini non déterministe. [return] On ne gère que les caractères ASCII dans notre application, on a donc mis la version anglaise des dialogues (sans accents). La version française donne : \u0026ldquo;Mais attendez un peu Doc, est-ce que j\u0026rsquo;ai bien entendu ? Vous dites que vous avez fabriqué une machine à voyager dans le temps\u0026hellip; à partir d’une DeLorean ?\u0026rdquo; et \u0026ldquo;Faut voir grand dans la vie, quitte à voyager à travers le temps au volant d\u0026rsquo;une voiture, autant en choisir une qui ait de la gueule.\u0026rdquo;  [return] Plus précisément, nous obtenons une représentation des unités lexicales. [return]   "
},
{
	"uri": "/fr/compiler/minijava/parser/",
	"title": "Analyse syntaxique",
	"tags": [],
	"description": "",
	"content": " graph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C] classDef green fill:#74B559,stroke:#222723,stroke-width:5px; class C green  "
},
{
	"uri": "/fr/tags/bash/",
	"title": "Bash",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/c/",
	"title": "C",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/compilation/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/compiler/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": "De manière abstraite, un compilateur est un programme qui transforme un fichier d\u0026rsquo;entrée contenant une certaine représentation en un fichier de sortie contenant une autre représentation.\ngraph LR; subgraph fichier d'entrée A[Représentation A] end A[Représentation A] -- C(fa:fa-tools Compilateur) C -- B subgraph fichier de sortie B[Représentation B] end  Généralement, le fichier d\u0026rsquo;entrée sera un fichier contenant un langage de programmation (fichier en langage C par exemple) et le fichier de sortie sera un fichier contenant une représentation exécutable directement par la machine (avec l\u0026rsquo;aide du système d\u0026rsquo;exploitation) ou par une machine virtuelle. Un compilateur va généralement produire plusieurs représentations intermédiaires avant de produire la représentation finale. Le compilateur pourra effectuer, selon le langage source, de l\u0026rsquo;analyse statique de types pour essayer de détecter des erreurs avant l\u0026rsquo;exécution du programme et pourra transformer le programme source, sans changer sa sémantique, en un code plus efficace que ce que l\u0026rsquo;utilisateur avait écrit : cette transformation est appelée optimisation.\n Dans la partie MiniJava nous allons étudier une sorte de compilateur qui se nomme transpileur, aussi appelé compilateur source à source, dans lequel la représentation d\u0026rsquo;entrée sera un langage de programmation (le langage MiniJava), et la représentation de sortie sera elle aussi un langage de programmation (le langage C). Nous pourrons ainsi profiter de l\u0026rsquo;existence d\u0026rsquo;un compilateur pour le langage C et nous concentrer seulement sur l\u0026rsquo;analyse statique du fichier source et sur la génération en C des éléments liés à l\u0026rsquo;orientation objet.\nCe premier compilateur nous permettra de rentrer plus en douceur dans le domaine de la compilation tout en montrant une approche très pratique pour écrire plus rapidement un compilateur sans avoir à se soucier de la difficulté de générer du code machine optimisé pour une architecture particulière.  "
},
{
	"uri": "/fr/tags/langage-%C3%A0-objets/",
	"title": "Langage À Objets",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/menhir/",
	"title": "Menhir",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/minijava/",
	"title": "Minijava",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/",
	"title": "MrCodeur",
	"tags": [],
	"description": "",
	"content": " MrCodeur \u0026ldquo;C\u0026rsquo;est en forgeant qu\u0026rsquo;on devient forgeron.\u0026rdquo;\nObjectif Ce petit coin du web est dédié à l\u0026rsquo;apprentissage de l\u0026rsquo;informatique avec pour principe de coder pour apprendre. Nous parcourrons ensemble, pas à pas, différents thèmes de l\u0026rsquo;informatique, construisant tout au long des logiciels pour comprendre en profondeur les différents sujets. J\u0026rsquo;espère que ce site sera utile pour certains d\u0026rsquo;entre vous et que vous vous amuserez tout en apprenant.\nStructure du site Je vais utiliser du texte, des vidéos et du code pour expliquer les différents sujets:\n Les vidéos seront en français avec des sous-titres anglais. Le code sera sur github.  Choisissez votre sujet sur le panneau de gauche ou parmis les thèmes ci-dessous, et nous allons pouvoir commencer à explorer ensemble le monde vaste et passionnant de l\u0026rsquo;informatique !\nThèmes abordés  MiniJava transpileur  Nous transformons un fichier source contenant un programme écrit dans un sous-ensemble du langage Java, le langage MiniJava, en un fichier en langage C. Nous utilisons ensuite gcc pour traduire le fichier en langage C en un fichier exécutable.\nPour effectuer cette transpilation, nous faisons d\u0026rsquo;abord une analyse lexicale du fichier source, puis une analyse syntaxique, puis une vérification du typage (analyse statique) et enfin une génération du code C à partir de l\u0026rsquo;arbre syntaxique abstrait de MiniJava. Les difficultés principales pour la génération du code C sont la représentation des classes, l\u0026rsquo;implémentation de la liaison dynamique et l\u0026rsquo;ajout du ramasse miettes.\nLe transpileur est écrit en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.   "
},
{
	"uri": "/fr/tags/ocaml/",
	"title": "Ocaml",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/ramasse-miettes/",
	"title": "Ramasse Miettes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/transpileur/",
	"title": "Transpileur",
	"tags": [],
	"description": "",
	"content": ""
}]