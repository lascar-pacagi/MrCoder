[
{
	"uri": "/fr/compiler/minijava/",
	"title": "MiniJava",
	"tags": ["compilation", "transpileur", "ramasse miettes", "langage à objets", "MiniJava", "C", "OCaml", "Menhir", "Bash"],
	"description": "",
	"content": " MiniJava Le compilateur que nous allons étudier dans cette partie est un transpileur permettant de passer du langage MiniJava au langage C. Il sera réalisé en en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.\nPour télécharger le code : git clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git.\n"
},
{
	"uri": "/fr/compiler/minijava/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Nous allons réaliser un transpileur, ou compilateur source à source, pour un sous-ensemble du langage Java, le langage MiniJava. La représentation d\u0026rsquo;entrée pour notre compilateur sera donc le langage MiniJava. La représentation en sortie de notre compilateur sera le langage C.\nUne exemple de programme permettant de calculer une factorielle est donné ci-dessous.\nclass Factorial { public static void main(String[] a) { System.out.println(new Fac().computeFac(10)); } } class Fac { public int computeFac(int num) { int numAux; if (num \u0026lt; 1) numAux = 1; else numAux = num * (this.computeFac(num-1)); return numAux; } } Comme Minijava est un sous-ensemble de Java, nous pourrons compiler nos fichiers MiniJava en utilisant le compilateur Java javac ce qui sera pratique pour tester la validité de nos traductions en langage C. En effet, nous pourrons comparer la sortie du programme obtenu en utilisant le compilateur Java, avec la sortie obtenue par l\u0026rsquo;exécutable obtenu grâce à notre transpileur.\n Vue d\u0026rsquo;ensemble du transpileur Nous allons considérer le programme MiniJava suivant pour illustrer cette section.  class Print42 { public static void main(String[] a) { System.out.println(35 + 2 * 3 + 1); } }\nLa figure suivante montre les différentes étapes permettant de passer du fichier source en MiniJava au fichier source transpilé en C.\ngraph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C]  Nous allons maintenant décrire les différentes étapes de la figure ci-dessus.\nPour suivre les démos dans les différentes vidéos qui vont suivre, commencer par installer les dépendances comme indiqué ici. Télécharger ensuite le code en faisant\ngit clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git cd MiniJava git checkout v1.0 make La branche master est la version avec le ramasse miettes et le tag v1.0 est une version sans ramasse miettes. Si vous voulez apporter des modifications à la version 1.0, vous pouvez créer une nouvelle branche (from_v1.0 par exemple) en faisant\ngit checkout -b from_v1.0 v1.0 Le code que je vais utiliser pendant les démos se trouve ci-dessous.\n  Pièces jointes   demo_code.tgz  (3 ko)    Analyse lexicale La première étape est l\u0026rsquo;analyse lexicale qui va permettre de découper un flot de caractères en mots. Ces mots sont appelés unités lexicales. On obtient alors une information plus structurée où les mots clés du langage, les identifiants, les entiers et les booléens ont été identifiés. Cette phase va aussi nous permettre de supprimer les commentaires et les blancs (espaces et retours à la ligne).\nPour le programme ci-dessus, l\u0026rsquo;analyse lexicale va produire le flot d\u0026rsquo;unités lexicales suivantes. On peut voir, par exemple, que le mot clé CLASS a été identifié, que la constante entière INT_CONST 35 aussi.\nCLASS IDENT ‘Print42‘ LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET IDENT ‘a‘ RPAREN LBRACE SYSO LPAREN INT_CONST ‘35‘ PLUS INT_CONST ‘2‘ TIMES INT_CONST ‘3‘ PLUS INT_CONST ‘1‘ RPAREN SEMICOLON RBRACE RBRACE EOF   Analyse syntaxique La deuxième étape, l\u0026rsquo;analyse syntaxique, prend en entrée le flot d\u0026rsquo;unités lexicales et va construire un arbre syntaxique abstrait permettant de représenter la structure du programme sous la forme d\u0026rsquo;un arbre.\nPour le programme ci-dessus, on obtient l\u0026rsquo;arbre suivant. On peut y voir, par exemple, l\u0026rsquo;expression arithmétique avec de manière explicite la priorité des opérateurs (plus c\u0026rsquo;est bas dans l\u0026rsquo;arbre et plus c\u0026rsquo;est prioritaire).\nprogram ├name Print42 ├main_args a └main └ISyso └EBinOp OpAdd ├EBinOp OpAdd │ ├EConst (ConstInt 35) │ └EBinOp OpMul │ ├EConst (ConstInt 2) │ └EConst (ConstInt 3) └EConst (ConstInt 1) L\u0026rsquo;analyse syntaxique a besoin de connaître la structure d\u0026rsquo;un programme MiniJava. Cette structure est donnée sous la forme d\u0026rsquo;une grammaire. La grammaire de MiniJava, dans sa forme EBNF est donnée ci-dessous. Une version sûrement plus lisible pour nous en diagramme syntaxique est donnée ici.1\nProgram = MainClass { ClassDeclaration } \u0026#39;eof\u0026#39; ; MainClass = \u0026#39;class\u0026#39; Identifier \u0026#39;{\u0026#39; \u0026#39;public\u0026#39; \u0026#39;static\u0026#39; \u0026#39;void\u0026#39; \u0026#39;main\u0026#39; \u0026#39;(\u0026#39; \u0026#39;String\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; Identifier \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; Statement \u0026#39;}\u0026#39; \u0026#39;}\u0026#39; ; ClassDeclaration = \u0026#39;class\u0026#39; Identifier [ \u0026#39;extends\u0026#39; Identifier ] \u0026#39;{\u0026#39; { VarDeclaration } { MethodDeclaration } \u0026#39;}\u0026#39; ; VarDeclaration = Type Identifier \u0026#39;;\u0026#39; ; MethodDeclaration = \u0026#39;public\u0026#39; Type Identifier \u0026#39;(\u0026#39; [ Type Identifier { \u0026#39;,\u0026#39; Type Identifier } ] \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; { VarDeclaration } { Statement } \u0026#39;return\u0026#39; Expression \u0026#39;;\u0026#39; \u0026#39;}\u0026#39; ; Type = \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; | \u0026#39;boolean\u0026#39; | \u0026#39;int\u0026#39; | Identifier ; Statement = \u0026#39;{\u0026#39; { Statement } \u0026#39;}\u0026#39; | \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement \u0026#39;else\u0026#39; Statement | \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement | \u0026#39;System.out.println\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; \u0026#39;;\u0026#39; | Identifier \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; | Identifier \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; ; Expression = Expression ( \u0026#39;\u0026amp;\u0026amp;\u0026#39; | \u0026#39;\u0026lt;\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; ) Expression | Expression \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | Expression \u0026#39;.\u0026#39; \u0026#39;length\u0026#39; | Expression \u0026#39;.\u0026#39; Identifier \u0026#39;(\u0026#39; [Expression {\u0026#39;,\u0026#39; Expression}] \u0026#39;)\u0026#39; | Integer | \u0026#39;true\u0026#39; | \u0026#39;false\u0026#39; | Identifier | \u0026#39;this\u0026#39; | \u0026#39;new\u0026#39; \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | \u0026#39;new\u0026#39; Identifier \u0026#39;(\u0026#39; \u0026#39;)\u0026#39; | \u0026#39;!\u0026#39; Expression | \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; ; Letter = \u0026#39;A\u0026#39; | \u0026#39;B\u0026#39; | \u0026#39;C\u0026#39; | \u0026#39;D\u0026#39; | \u0026#39;E\u0026#39; | \u0026#39;F\u0026#39; | \u0026#39;G\u0026#39; | \u0026#39;H\u0026#39; | \u0026#39;I\u0026#39; | \u0026#39;J\u0026#39; | \u0026#39;K\u0026#39; | \u0026#39;L\u0026#39; | \u0026#39;M\u0026#39; | \u0026#39;N\u0026#39; | \u0026#39;O\u0026#39; | \u0026#39;P\u0026#39; | \u0026#39;Q\u0026#39; | \u0026#39;R\u0026#39; | \u0026#39;S\u0026#39; | \u0026#39;T\u0026#39; | \u0026#39;U\u0026#39; | \u0026#39;V\u0026#39; | \u0026#39;W\u0026#39; | \u0026#39;X\u0026#39; | \u0026#39;Y\u0026#39; | \u0026#39;Z\u0026#39; | \u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39; | \u0026#39;d\u0026#39; | \u0026#39;e\u0026#39; | \u0026#39;f\u0026#39; | \u0026#39;g\u0026#39; | \u0026#39;h\u0026#39; | \u0026#39;i\u0026#39; | \u0026#39;j\u0026#39; | \u0026#39;k\u0026#39; | \u0026#39;l\u0026#39; | \u0026#39;m\u0026#39; | \u0026#39;n\u0026#39; | \u0026#39;o\u0026#39; | \u0026#39;p\u0026#39; | \u0026#39;q\u0026#39; | \u0026#39;r\u0026#39; | \u0026#39;s\u0026#39; | \u0026#39;t\u0026#39; | \u0026#39;u\u0026#39; | \u0026#39;v\u0026#39; | \u0026#39;w\u0026#39; | \u0026#39;x\u0026#39; | \u0026#39;y\u0026#39; | \u0026#39;z\u0026#39; ; Digit = \u0026#39;0\u0026#39; | \u0026#39;1\u0026#39; | \u0026#39;2\u0026#39; | \u0026#39;3\u0026#39; | \u0026#39;4\u0026#39; | \u0026#39;5\u0026#39; | \u0026#39;6\u0026#39; | \u0026#39;7\u0026#39; | \u0026#39;8\u0026#39; | \u0026#39;9\u0026#39; ; Integer = Digit { Digit } ; Character = Letter | Digit | \u0026#39;_\u0026#39; ; Identifier = Letter { Letter | Digit | \u0026#39;_\u0026#39; } ;    Typage La troisième étape, l\u0026rsquo;analyse de types, va prendre en entrée l\u0026rsquo;arbre abstrait et va vérifier si le typage est correct. Par exemple, on va vérifier qu\u0026rsquo;on utilise les méthodes avec le bon nombre de paramètres, que les opérateurs + et * sont utilisés avec des opérandes entières, qu\u0026rsquo;une classe est compatible avec une autre via la relation d\u0026rsquo;héritage, \u0026hellip;\n  Génération de code La dernière étape va consister à générer le code en C. On va de nouveau parcourir l\u0026rsquo;arbre syntaxique abstrait pour générer ce code. Pour notre example, on obtient le fichier C ci-dessous.\n#include \u0026lt;stdio.h\u0026gt;int main(int argc, char *argv[]) { printf(\u0026#34;%d\\n\u0026#34;, ((35 + (2 * 3)) + 1)); return 0; }   Sémantique de MiniJava La sémantique de MiniJava est donnée par sa sémantique en tant que programme Java 2. Les principales restrictions sont\n Les classes n\u0026rsquo;héritent pas de la classe Object. Le mot clé super n\u0026rsquo;existe pas. Il y a simplement un constructeur par défaut. Les seuls types autorisés sont,  int. boolean. int[]. Les classes définies par l\u0026rsquo;utilisateur.  La surcharge d\u0026rsquo;opérateurs n\u0026rsquo;est pas autorisée. L\u0026rsquo;instruction System.out.printl() ne peut imprimer que des entiers. Toutes les méthodes doivent retourner une valeur. Il n\u0026rsquo;y a pas d\u0026rsquo;interface, d\u0026rsquo;exception, de généricité, de lambda.  Nous expliquons dans la vidéo suivante les principales différences entre MiniJava et Java.\n  Nous avons décrit rapidement l\u0026rsquo;initialisation par défaut en Java (et MiniJava) dans la vidéo. Nous apportons quelques précisions ci-dessous. Vous pouvez regarder ici pour tous les détails.\nSoit le programme Java Init.java suivant.\n1class Init { 2 public static void main(String[] args) { 3 int i; 4 boolean b; 5 int[] a; 6 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 7 } 8} Si on le compile, on obtient les messages d\u0026rsquo;erreur suivants.\n$ javac Init.java Init.java:6: error: variable i might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable b might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable a might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ 3 errors En effet, les trois variables i, b et a sont situées sur la pile, et leurs valeurs vont dépendre des valeurs qui sont situées sur la pile lors de l\u0026rsquo;appel du main. Java n\u0026rsquo;initialisant pas les variables locales avec une valeur par défaut, le compilateur refuse le programme en nous indiquant que l\u0026rsquo;on cherche à utiliser des variables non initialisées.\nPar contre, le programme suivant est correct car les attributs ont des valeurs par défaut.\n1class Init { 2 public static void main(String[] args) { 3 new Default().print(); 4 } 5} 6 7class Default { 8 private int i; 9 private boolean b; 10 private int[] a; 11 12 public void print() { 13 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 14 } 15} Et on obtient la sortie suivante.\n$ javac Init.java $ java Init 0 false null Rappels sur la liaison dynamique en Java Nous allons faire quelques rappels sur la liaison dynamique en Java dans la vidéo ci-dessous, car la gestion de la liaison dynamique sera un des points les plus difficiles à gérer dans notre transpileur.\n  Questions Reprenons la grammaire de MiniJava. Nous voudrions ajouter la possibilité d\u0026rsquo;avoir\n L\u0026rsquo;opérateur de comparaison ==. Des constructeurs. Des constructeurs et méthodes private.    Quelles sont les modifications à apporter à cette grammaire pour incorporer ces nouveaux éléments ?   Grammaire de MiniJava modifiée.\n    Dans la question précédente, quels terminaux avez-vous dû ajouter à la grammaire (un terminal dans la grammaire deviendra une unité lexicale) ?   == et private.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6} 7 8class B extends A { 9 public boolean m1(int n) { 10 System.out.println(\u0026#34;boolean B:m1(int n)\u0026#34;); 11 return false; 12 } 13}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, à la ligne 9, la méthode m1 est une redéfinition de la méthode m1 de la ligne 2 : elle à le même nom et les mêmes paramètres. Par contre, pour être une redéfinition correcte, il aurait fallu que le type de retour boolean soit compatible avec le type de retour int, mais ce n\u0026rsquo;est pas le cas.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(int n) { 7 System.out.println(\u0026#34;boolean A:m1(int n)\u0026#34;); 8 return false; 9 } 10}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, le type de retour ne permet pas de différentier deux méthodes. Donc même si les méthodes aux lignes 2 et 6 ont des types de retour différents, comme elles se nomment pareil et ont les mêmes paramètres, on a pas une surcharge et il y a donc une erreur.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(A a) { 3 System.out.println(\u0026#34;int A:m1(A a)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(B b) { 7 System.out.println(\u0026#34;boolean A:m1(B b)\u0026#34;); 8 return false; 9 } 10} 11 12class B extends A { 13}   Ce code compile-t-il ?   Ce code compile. Cette fois-ci, la méthode à la ligne 6 est bien une surcharge de la méthode à la ligne 2 car le paramètre est d\u0026rsquo;un type différent.\n  Ressources Cours sur Java de Coursera partie 1\nCours sur Java de Coursera partie 2\nCours sur Java de Coursera partie 3\nCours sur Java de Princeton\nSpécifications du langage Java\nPage de MiniJava\nDiagramme syntaxique de MiniJava\nCours sur le langage C partie 1\nCours sur le langage C partie 2\nCours sur le langage C partie 3\nCours sur le langage C partie 4\nApprendre le C en construisant un Lisp\nCours sur le C moderne\nSpécifications du langage C (norme C11)\n  La description de la grammaire qui permet de générer le diagramme ne suit pas strictement la forme EBNF. Les détails sont donnés ici. [return] Voir ici pour la sémantique du langage Java. [return]   "
},
{
	"uri": "/fr/compiler/minijava/scanner/",
	"title": "Analyse lexicale",
	"tags": [],
	"description": "",
	"content": " {{}} graph LR; A[source en MiniJava] \u0026ndash;\u0026gt;|caractères| B(fa:fa-tools Analyse  lexicale) B \u0026ndash;\u0026gt;|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C \u0026ndash;\u0026gt;|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D \u0026ndash;\u0026gt;|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E \u0026ndash;\u0026gt;|caractères| F[source en C]\nclassDef green fill:#74B559,stroke:#222723,stroke-width:5px; class B green {{\u0026lt; /mermaid \u0026gt;}}\nNous allons décrire l\u0026rsquo;analyseur lexical de MiniJava qui va permettre de découper les caractères du fichier source en unités lexicales. Ces unités lexicales seront ensuite utilisées par l\u0026rsquo;analyseur syntaxique.\nAvant de décrire cet analyseur lexical, nous allons présenter les expressions régulières qui seront utilisées pour décrire les unités lexicales. Nous étudierons aussi les automates qui permettront d\u0026rsquo;implémenter la reconnaissance des expressions régulières. \nExpressions régulières Les expressions régulières vont nous permettre de décrire succintement et assez intuitivement les unités lexicales de MiniJava et seront utilisées dans le générateur d\u0026rsquo;analyseur lexical ocamllex que nous allons utiliser dans notre transpiler.\nDéfinition Une expression régulière va décrire un ensemble de mots sur un vocabulaire donné. Nous allons prendre comme exemple le vocabulaire $\\mathcal{V} = \\{0, 1\\}$ constitué simplement de deux éléments : 0 et 1. Nous décrivons ci-dessous de manière informelle les éléments de base et les opérateurs permettant de créer des expressions régulières et les mots qu\u0026rsquo;elles décrivent.\n Expressions régulières de base :\n L\u0026rsquo;expression régulière $\\color{green}\\epsilon$ génère l\u0026rsquo;ensemble contenant simplement le mot vide1: $\\{\\epsilon\\}$. Pour $c \\in \\mathcal{V}$, l\u0026rsquo;expression régulière $\\color{green}c$ représente l\u0026rsquo;ensemble contenant un seul mot : $\\{c\\}$. -- --\n   Expression Ensemble de mots     $\\color{green}0$ $\\{0\\}$   $\\color{green}1$ $\\{1\\}$     Expressions régulières composées :\n On peut utiliser des parenthèses pour regrouper des expressions régulières. Soit $\\color{green}{r}$ une expression régulière, alors $\\color{green}{(r)}$ représente le même ensemble de mots que l\u0026rsquo;expression $\\color{green}{r}$.\n   Expression Ensemble de mots     $\\color{green}{(0)}$ $\\{0\\}$    L\u0026rsquo;opérateur de concaténation permet de juxtaposer les mots engendrés par deux expressions régulières. Soit $\\color{green}{r_1}$ et $\\color{green}{r_2}$ deux expressions régulières. La concaténation de ces deux expressions régulières est notée : $\\color{green}{r_1r_2}$. L\u0026rsquo;ensemble des mots décrit par cette expression régulière est la concaténation des mots décrit par $\\color{green}{r_1}$ avec ceux décrit par $\\color{green}{r_2}$.\nNotons que cet opérateur est associatif, c\u0026rsquo;est-à-dire que pour toute expression régulière $\\color{green}{r_1}$, $\\color{green}{r_2}$ et $\\color{green}{r_3}$, on a $\\color{green}{(r_1r_2)r_3} = \\color{green}{r_1(r_2r_3)}$ que l\u0026rsquo;on notera simplement $\\color{green}{r_1r_2r_3}$.\n   Expression Ensemble de mots     $\\color{green}{\\epsilon1}$ $\\{1\\}$   $\\color{green}{10}$ $\\{10\\}$   $\\color{green}{(10)1}$ $\\{101\\}$   $\\color{green}{1(01)}$ $\\{101\\}$   $\\color{green}{101}$ $\\{101\\}$    L\u0026rsquo;opérateur d\u0026rsquo;union permet de faire l\u0026rsquo;union des mots engendrés par deux expressions régulières. Soit $\\color{green}{r_1}$ et $\\color{green}{r_2}$ deux expressions régulières. L\u0026rsquo;union de ces deux expressions régulières est notée : $\\color{green}{r_1 | \\ r_2}$. L\u0026rsquo;ensemble des mots décrit par cette expression régulière est l\u0026rsquo;union des mots décrit par $\\color{green}{r_1}$ avec ceux décrit par $\\color{green}{r_2}$.\nNotons que cet opérateur est commutatif, c\u0026rsquo;est-à-dire que $\\color{green}{r_1\\ |\\ r_2} = \\color{green}{r_2\\ |\\ r_1}$. Il est aussi associatif, c\u0026rsquo;est-à-dire que pour toute expression régulière $\\color{green}{r_1}$, $\\color{green}{r_2}$ et $\\color{green}{r_3}$, on a $\\color{green}{(r_1\\ |\\ r_2)\\ |\\ r_3} = \\color{green}{r_1\\ |\\ (r_2\\ |\\ r_3)}$ que l\u0026rsquo;on notera simplement $\\color{green}{r_1\\ |\\ r_2\\ |\\ r_3}$.\n   Expression Ensemble de mots     $\\color{green}{\\epsilon \\ | \\ 1}$ $\\{\\epsilon, 1\\}$   $\\color{green}{(00) \\ | \\ (10)}$ $\\{00, 10\\}$   $\\color{green}{(10) \\ | \\ (00)}$ $\\{00, 10\\}$   $\\color{green}{(0 \\ | \\ 1)\\ |\\ (10)}$ $\\{0, 1, 10\\}$   $\\color{green}{0\\ |\\ (1 \\ | \\ (10))}$ $\\{0, 1, 10\\}$   $\\color{green}{0 \\ | \\ 1\\ |\\ (10)}$ $\\{0, 1, 10\\}$   $\\color{green}{(0\\ |\\ 1)(0\\ |\\ 1)}$ $\\{00, 01, 10, 11\\}$    L\u0026rsquo;opérateur d\u0026rsquo;itération noté * permet de juxtaposer $0$ ou plusieurs fois les mots engendrés par une expression régulières. Soit $\\color{green}{r}$ une expression régulière, alors l\u0026rsquo;expression régulière $\\color{green}{r^*}$ représente l\u0026rsquo;hypothétique2 expression régulière $\\color{green}{\\epsilon \\ |\\ r\\ |\\ rr\\ |\\ rrr\\ |\\ rrrr\\ |\\ \\cdots}$.\n   Expression Ensemble de mots     $\\color{green}{0^*}$ $\\{\\epsilon, 0, 00, 000, 0000, \\cdots\\}$   $\\color{green}{(0\\ | \\ 1)^*}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \\cdots\\}$      {{% notice note %}} Pour éviter trop de parenthèses, il existe une priorité entre les différents opérateurs : les parenthèses ont la plus grande priorité, ensuite l\u0026rsquo;opérateur $\\color{green}{*}$, puis l\u0026rsquo;opérateur de concaténation et enfin l\u0026rsquo;opérateur $\\color{green}{|}$. On a vu aussi ci-dessus que les opérateurs de concaténation et d\u0026rsquo;union sont associatifs, ce qui nous permet de supprimer d\u0026rsquo;avantage de parenthèses. Ainsi, l\u0026rsquo;expression régulière $\\color{green}{10^*1\\ |\\ 11\\ |\\ \\epsilon}$ se lit $\\color{green}{(((1(0^ *))1)\\ |\\ (11))\\ |\\ \\epsilon}$ {{% /notice %}}\nExamples Nous donnons ci-dessous quelques examples d\u0026rsquo;expressions régulières toujours sur le vocabulaire $\\mathcal{V} = \\{0, 1\\}$.\n-- --    Description Expression Ensemble de mots     Les nombres binaires (sans zéro non significatif) $\\color{green}{0\\ | \\ 1(0\\ | \\ 1)^*}$ $\\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \\cdots\\}$   Les nombres binaires impairs $\\color{green}{1\\ | \\ 1(0\\ | \\ 1)^*1}$ $\\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \\cdots\\}$   Les chaînes de bits ne contenant que des zeros et des uns alternés $\\color{green}{10(10)^* \\ | \\ 01(01)^*}$ $\\{10, 01, 1010, 0101, 101010, 010101, \\cdots\\}$   Les chaînes de bits dont la longueur est multiple de 3 $\\color{green}{((0\\ | \\ 1)(0\\ | \\ 1)(0\\ | \\ 1))^*}$ $\\{\\epsilon, 000, 001, 010, 011, 100, \\cdots, 111000, 111001, \\cdots, 101011110, \\cdots \\}$   Les chaînes de bits ne contenant pas la sous-chaîne $11$ $\\color{green}{0^* ( 100^* )^* (1\\ | \\ \\epsilon)}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \\cdots\\}$    {{% notice info %}} Vous pouvez vous amuser en utilisant les expressions régulières sur Regex Crossword . {{% /notice %}}\n{{\u0026lt; youtube 5VNKh7aaZ-g \u0026gt;}}\n{{\u0026lt; youtube Wl8FXqv6dak \u0026gt;}}\nQuestions On utilisera la notation $\\{a,b\\}^*$ dans les questions ci-dessous : $\\{a,b\\}^*$ représente le langage engendré par l\u0026rsquo;expression régulière $\\color{green}{(a\\ |\\ b)^*}$.\n{{%expand \u0026ldquo;Soit l\u0026rsquo;alphabet ${a, b}$. Donner une expression régulière permettant de décrire le langage : ${ w \\in { a, b}^*\\ |\\ w$ contient les mots $aa$ ou $bb$ $}$.\u0026rdquo; %}}\n{{% /expand%}}\n{{%expand \u0026ldquo;Cette question même si on pourrait penser qu\u0026rsquo;elle ressemble beaucoup à la précédente n\u0026rsquo;est pas facile. Vous pouvez revenir sur cette question après avoir vu la section suivante sur les automates. Soit l\u0026rsquo;alphabet ${a, b}$. Donner une expression régulière permettant de décrire le langage : ${ w \\in { a, b}^*\\ |\\ w$ ne contient pas les mots $aa$ ou $bb$ $}$.\u0026rdquo; %}}\n{{% /expand%}}\nOn veut se déplacer dans la grille ci-dessous en utilisant les deux actions : \u0026ldquo;aller à droite\u0026rdquo; et \u0026ldquo;aller en haut\u0026rdquo;. On part du coin inférieur gauche et on veut arriver au coin supérieur droit. Un chemin possible est indiqué dans la figure de droite.\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/scanner_question_grid3.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n{{%expand \u0026ldquo;Écrire une expression régulière permettant de décrire toutes les actions permettant d\u0026rsquo;aller du coin inférieur gauche au coin supérieur droit.\u0026rdquo; %}}\nOn ne peut pas écrire succintement cette expression régulière sans utiliser des extensions. On va devoir énumérer les différentes configurations. Le nombre de possibilités est le nombre de combinaisons de 3 éléments parmis 6 : ${{6}\\choose{3}} = 20$. En effet, il faut 6 actions pour aller du départ jusqu\u0026rsquo;à l\u0026rsquo;arrivée. Parmis ces 6 actions, 3 doivent aller vers la droite et 3 vers le haut. On va donc créer une expression régulière avec 20 parties. Nous utilisons D pour allez à droite et H pour allez en haut.\n$$ \\scriptsize \\color{green}{HHHDDD\\ |\nHHDHDD\\ |\nHHDDHD\\ |\nHHDDDH\\ |\nHDHHDD\\ |\nHDHDHD\\ |\nHDHDDH\\ |\nHDDHHD\\ |\nHDDHDH\\ |\nHDDDHH\\ |\nDHHHDD\\ |\nDHHDHD\\ |\nDHHDDH\\ |\nDHDHHD\\ |\nDHDHDH\\ |\nDHDDHH\\ |\nDDHHHD\\ |\nDDHHDH\\ |\nDDHDHH\\ |\nDDDHHH } $$\nNous avons généré les combinaisons ci-dessus grâce au programme suivant.\n{{\u0026lt; highlight cpp\u0026gt;}} #include  #include \nusing namespace std;\nconst string HAUT = \u0026ldquo;H\u0026rdquo;; const string DROITE = \u0026ldquo;D\u0026rdquo;;\nvoid combos(int nH, int nD, string res) { if (!nH \u0026amp;\u0026amp; !nD) { cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026ldquo;\\n\u0026rdquo;; return; } if (nH) { combos(nH - 1, nD, res + HAUT); } if (nD) { combos(nH, nD - 1, res + DROITE); } }\nint main(int argc, char *argv[]) { combos(3, 3, \u0026ldquo;\u0026rdquo;); } {{\u0026lt; /highlight \u0026gt;}}\nEn utilisant les extensions des expressions régulières on peut obtenir la forme plus concise suivante.\n{{\u0026lt; highlight julia\u0026gt;}} ^(?!(.H.){4}|(.D.){4})(H|D){6}$ {{\u0026lt; /highlight\u0026gt;}}\nDans cette expression, l\u0026rsquo;opérateur (?!(.*H.*){4}|(.*D.*){4}) exprime qu\u0026rsquo;il ne faut pas réussir à trouver quatre H ou quatre D dans la suite de la ligne. L\u0026rsquo;expression (H|D){6} exprime qu\u0026rsquo;il faut reconnaître six caractères parmis H et D. On exprime donc qu\u0026rsquo;il faut reconnaître six caractères parmis H et D, mais on ne doit pas trouver quatre H ou quatre D. On doit donc avoir exactement trois H et trois D.\n{{% /expand%}}\n{{%expand \u0026ldquo;Cette question n\u0026rsquo;est pas facile. Vous pouvez revenir sur cette question après avoir vu la section suivante sur les automates. Soit l\u0026rsquo;alphabet ${a, b}$. Donner une expression régulière permettant de décrire le langage : ${ w \\in { a, b}^*\\ |\\ w$ contient un nombre pair de $a$ et un nombre impair de $b$ $}$.\u0026rdquo; %}}\n{{% /expand%}}\n{{%expand \u0026ldquo;Soit l\u0026rsquo;alphabet ${0, 1}$. Quel est le langage décrit par l\u0026rsquo;expression régulière suivante : $\\color{green}{0^*10^10^(10^*\\ |\\ \\epsilon)}$ ?\u0026rdquo; %}} Le langage contenant deux ou trois 1. {{% /expand%}}\nAutomates Dans la section précédente nous avons présenté les expressions régulières qui permettent de décrire les langages dit réguliers. Cette notation est pratique pour décrire les langages réguliers, et nous l\u0026rsquo;utiliserons pour décrire les unités lexicales dans l\u0026rsquo;analyseur lexical de MiniJava. Par contre, pour la reconnaissance, c\u0026rsquo;est-à-dire pour savoir si un mot donné appartient bien au langage décrit par une expression régulière, il n\u0026rsquo;est pas facile d\u0026rsquo;utiliser directement une expression régulière.\nNous allons décrire maintenant les automates finis, non-déterministes et déterministes, qui permettent de répondre plus facilement à la question de savoir si un mot donné appartient bien à un langage régulier donné. Nous nous servirons de ces automates dans la section suivante pour construire un logiciel permettant de tester efficacement, si un mot donné appartient bien au langage engendré par une expression régulière donnée.\nNotons que les langages décrits par les automates finis (non-déterministes ou déterministes) sont les langages réguliers, les expressions régulières et les automates sont donc deux moyens équivalents permettant de décrire les mêmes langages.\nAutomates finis non-déterministes La figure suivante représente un automate fini non-déterministe, que nous appellerons $A_{fnd}$3, qui décrit les commentaires en C de type /*...*/. On suppose, pour simplifier, que notre vocabulaire est $\\mathcal{V} = \\{ a, b, /, * \\}$. Sur cette figure on peut voir les éléments suivants :\n Des états, les cercles sur la figure, numérotés de 0 à 7 pour cet exemple. On peut y voir l\u0026rsquo;état de départ (ou état initial), l\u0026rsquo;état 0, qui possède une flèche qui arrive sur lui, mais qui ne part d\u0026rsquo;aucun autre état. L\u0026rsquo;état 7 est un état d\u0026rsquo;acceptation (ou état final), il est représenté par un double cercle.\n Des transitions entre états, les flèches sur la figure. Sur les transitions il y a des symboles appartenant au vocabulaire $\\mathcal{V}$ ou bien le symbole $\\epsilon$. Notons que sur certaines transitions, par exemple la transition entre l\u0026rsquo;état 3 et l\u0026rsquo;état 2, nous avons mis plusieurs symboles sur la transition (sur cette transition il y a les deux symboles a et b). Formellement, nous aurions dû écrire deux transitions au lieu d\u0026rsquo;une, avec chacune un des deux symboles, mais faire comme nous l\u0026rsquo;avons fait permet d\u0026rsquo;écrire plus succinctement l\u0026rsquo;automate.\n  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\nL\u0026rsquo;automate va nous permettre de savoir si un mot m construit à partir du vocabulaire $\\mathcal{V}$ appartient au langage décrit par l\u0026rsquo;automate (on note ce langage $\\mathcal{L}(A_{fnd})$).\nTest de l\u0026rsquo;appartenance d\u0026rsquo;un mot au langage décrit par l\u0026rsquo;automate Soit /*/*/ un mot, que nous appellerons m, appartenant à $\\mathcal{V}^*$. Comment savoir si ce mot est décrit par l\u0026rsquo;automate $A_{fnd}$ ?\nOn va partir de l\u0026rsquo;état initial, l\u0026rsquo;état 0, et on va suivre les transitions, caractères après caractères, en cherchant un chemin qui nous mène vers l\u0026rsquo;état d\u0026rsquo;acceptation 7 après avoir lu tous les caractères du mot m.\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments1.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n À Partir de l\u0026rsquo;état 0, il n\u0026rsquo;y a qu\u0026rsquo;une seule transition, il n\u0026rsquo;y a donc pas le choix. Le mot doit donc forcément commencer par /, car c\u0026rsquo;est le symbole sur cette transition. Une fois cette transition passée, on se trouve dans l\u0026rsquo;état 1 et il nous reste à analyser la partie */*/ de m.  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments2.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n À Partir de l\u0026rsquo;état 1, il n\u0026rsquo;y a aussi qu\u0026rsquo;une seule transition possible. On doit donc forcément avoir le symbole * dans ce qu\u0026rsquo;il nous reste à analyser */*/, car c\u0026rsquo;est le symbole sur la seule transition partant de l\u0026rsquo;état 1. Une fois cette transition passée, on se trouve dans l\u0026rsquo;état 2 et il nous reste à analyser la partie /*/ de m.  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments3.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n L\u0026rsquo;état 2 possède trois transitions sortantes. Elles sont toutes les trois labelées avec le symbole $\\epsilon$. Ce symbole signifie que l\u0026rsquo;on ne modifie pas l\u0026rsquo;entrée lorsque l\u0026rsquo;on passe par une telle transition. On peut voir maintenant pourquoi l\u0026rsquo;automate est non déterministe car sur le même symbole, ici $\\epsilon$, on a le choix entre plusieurs transitions. Comment faire pour s\u0026rsquo;orienter ? On va supposer pour le moment que l\u0026rsquo;on a des dons de clairvoyance et que l\u0026rsquo;on va choisir la bonne transition, qui est celle vers l\u0026rsquo;état 4. On verra dans les vidéos comment automatiser cela.  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments4.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n Dans l\u0026rsquo;état 4 nous avons encore le choix entre deux transitions : ne pas consommer un caractère de l\u0026rsquo;entrée en prenant la transition $\\epsilon$, ou consommer le caractère / en bouclant sur l\u0026rsquo;état 4. Comme nous sommes devin, nous allons boucler sur l\u0026rsquo;état 4 et consommer le /.  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments5.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n Maintenant, l\u0026rsquo;entrée qu\u0026rsquo;il nous reste à consommer est */. Nous allons prendre la transition $\\epsilon$ jusqu\u0026rsquo;à l\u0026rsquo;état 2, puis la transition $\\epsilon$ de l\u0026rsquo;état 2 vers l\u0026rsquo;état 3. Encore une fois on ne se préoccupe pas pour l\u0026rsquo;instant du comment faire les bons choix de transitions lorsqu\u0026rsquo;il y a plus d\u0026rsquo;une possibilité. Nous nous retrouvons dans la configuration ci-dessous, où le curseur sous la chaîne d\u0026rsquo;entrée n\u0026rsquo;a pas bougé.  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments6.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n Dans l\u0026rsquo;état 5, nous n\u0026rsquo;avons qu\u0026rsquo;une transition sortante sur le caractère *. Le curseur sur l\u0026rsquo;entrée est placé sur le *, on peut donc prendre cette transition et déplacer le curseur vers la droite. Il nous reste maintenant simplement à reconnaître le /.  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments7.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n Dans l\u0026rsquo;état 6, il n\u0026rsquo;y a là aussi qu\u0026rsquo;une seule transition sur le symbole /. Comme le curseur sur l\u0026rsquo;entrée pointe sur un caractère /, on peut prendre cette transition et se placer sur l\u0026rsquo;état final 7.  {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_comments8.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n Comme la chaîne d\u0026rsquo;entrée est maintenant vide et que nous sommes dans un état d\u0026rsquo;acceptation, on peut conclure que le mot /*/*/ appartient bien au langage $\\mathcal{L}(A_{fnd})$. Le mot /*/*/ est donc bien un commentaire.  La chaîne d\u0026rsquo;entrée /*/*/ est acceptée par notre automate, mais comment sait-on si une chaîne n\u0026rsquo;est pas dans le langage $\\mathcal{L}(A_{fnd})$, autrement dit comment sait-on si le mot n\u0026rsquo;est pas accepté ? Pour un automate non déterministe, il faut montrer qu\u0026rsquo;après avoir lu tous les caractères de la chaîne d\u0026rsquo;entrée, on ne peut pas être dans un état d\u0026rsquo;acceptation. Nous allons détailler dans la vidéo suivante comment détecter si un mot appartient ou non au langage engendré par un automate fini non déterministe.\n{{% notice note %}} Il nous semble plus aisé de construire l\u0026rsquo;automate fini non déterministe que nous venons de voir pour décrire le langage des commentaires que l\u0026rsquo;expression régulière $/*\\color{darkgreen}{(}*^{\\color{darkgreen}{+}}\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}\\ \\color{darkgreen}{|}\\ \\color{darkgreen}{(}a\\ |\\ b\\ |\\ /\\color{darkgreen}{)}\\color{darkgreen}{)}^{\\color{darkgreen}{*}}*^{\\color{darkgreen}{+}}/$ que nous avions vu dans la section précedente. Après, vous êtes peut-être des gourous de Perl4 et c\u0026rsquo;est juste trop facile pour vous . {{% /notice %}}\n}} -- Questions {{%expand \u0026ldquo;Soit l\u0026rsquo;alphabet ${a, b}$. Construire un automate qui reconnait le langage : ${ w \\in { a, b}^*\\ |\\ w$ contient le mot $aba$ $}$. Par example, $aba$ est dans le langage, ainsi que $bbbbbaabaaaabb$, mais pas $babbbaaa$.\u0026rdquo; %}} {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_question1.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\nNotons que cet automate calque vraiment l\u0026rsquo;expression régulière $\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}aba\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}$. {{% /expand%}}\n{{%expand \u0026ldquo;Soit l\u0026rsquo;alphabet ${a, b}$. Construire un automate qui reconnait le langage : ${ w \\in { a, b}^*\\ |\\ w$ ne contient pas le mot $aba$ sauf s\u0026rsquo;il est précédé par le mot $bbb$ $}$. Par exemple, $aaabbbaabaa$ est dans le langage, $abba$ aussi, mais pas $bbababbb$.\u0026rdquo; %}} {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/nfa_question2.svg\u0026rdquo; width=\u0026ldquo;600px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n La partie haute de l\u0026rsquo;automate, les états 1, 2, 3 et 4, permet de reconnaître une suite de trois b suivie de n\u0026rsquo;importe quoi. La partie basse s\u0026rsquo;occupe de reconnaître tout sauf aba. L\u0026rsquo;état 5 indique que l\u0026rsquo;on a pas encore vu de a ou bien que l\u0026rsquo;on vient de rencontrer une séquence se terminant par bb (on est donc sûr de ne pas avoir vu une séquence se terminant par ab). L\u0026rsquo;état 6 indique qu\u0026rsquo;on est en train d\u0026rsquo;analyser une suite d\u0026rsquo;au moins un a et l\u0026rsquo;état 7 qu\u0026rsquo;on vient de voir ab, donc qu\u0026rsquo;on ne doit pas avoir un a maintenant). À partir des états 5, 6 et 7 on peut rejoindre la partie haute de l\u0026rsquo;automate car on vient d\u0026rsquo;analyser un préfixe correcte et on peut vouloir ajouter aba dans la suite (en ajoutant bbb avant).\nComment être sûr que la partie basse reconnaît bien tout sauf aba ? Pour la partie haute, il est assez facile de se convaincre qu\u0026rsquo;elle reconnaît bien $bbb\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}$. Mais ce n\u0026rsquo;est pas si évident de se convaincre que la partie basse décrit bien tout sauf la chaîne aba. Quand on veut vraiment être sûr, il n\u0026rsquo;y a qu\u0026rsquo;un moyen, c\u0026rsquo;est faire une preuve !5\nOn va faire une preuve par récurrence sur la longueur de la chaîne. Pour une chaîne de longueur 0 ($\\epsilon$) de longueur 1 ($a$ et $b$) et de longueur 2 ($aa$, $ab$, $ba$ et $bb$), on peut suivre les transitions à partir de l\u0026rsquo;état 0 vers la partie basse et voir qu\u0026rsquo;on les reconnaît toutes et elles n\u0026rsquo;ont pas aba dedans (car la longueur de la chaîne est inférieure ou égale à 2). Supposons que la propriété est vraie pour les chaînes de longueur $n \\ge 2$, est-ce vraie pour les chaînes de longueur $n + 1$ ? Regardons les deux derniers caractères de la chaîne m de longueur $n$.\n m se termine par aa. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 6 comme indiqué ci-dessus. On peut ajouter un a et accepter la nouvelle chaîne ma car on reste dans l\u0026rsquo;état 6 qui est un état d\u0026rsquo;acceptation, et on peut aussi ajouter un b et accepter la chaîne mb car on se retrouve dans l\u0026rsquo;état 7 qui est aussi un état d\u0026rsquo;acceptation.\n m se termine par ab. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 7 comme indiqué ci-dessus. On ne peut pas ajouter de a car il n\u0026rsquo;y a aucune transition sur un a à partir de l\u0026rsquo;état 7 et donc on ne reconnaîtra pas une chaîne contenant aba. On peut par contre ajouter un b et bien reconnaître la chaîne de longueur $n+1$ mb.\n m se termine par ba. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 6 comme indiqué ci-dessus et on peut ajouter un a ou bien un b pour obtenir la chaîne de longueur $n+1$ ma ou mb.\n m se termine par bb. Dans ce cas on doit forcément se trouver dans l\u0026rsquo;état 5 comme indiqué ci-dessus et on peut ajouter un a ou bien un b pour obtenir la chaîne de longueur $n+1$ ma ou mb.\n  En supposant donc qu\u0026rsquo;on peut générer tous les mots de longueur $n$ ne contenant pas aba, on vient de montrer qu\u0026rsquo;on peut générer tous les mots de longueur $n+1$ ne contenant pas aba.\n{{% /expand%}}\nAutomates finis déterministes {{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/dfa_comments.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\nPassage d\u0026rsquo;un automate à une expression régulière Nous allons décrire plus en détail les liens entre expressions régulières et automates dans les vidéos ci-dessous, mais nous pouvons retrouver l\u0026rsquo;expression régulière permettant de décrire les commentaires en C automatiquement à partir d\u0026rsquo;un automate fini (déterministe ou non-déterministe). Nous montrons ci-dessous une suite de transformations permettant de passer de l\u0026rsquo;automate fini déterministe vu plus haut vers une expression régulière équivalente. On peut voir sur les transitions apparaître des expressions régulières au fur et à mesure des transformations. Pour ne pas confondre le caractère * avec l\u0026rsquo;opérateur *, nous avons écrit l\u0026rsquo;opérateur en vert.\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/automata_to_regex1.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/automata_to_regex2.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/automata_to_regex3.svg\u0026rdquo; width=\u0026ldquo;300px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/dfa_comments.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/dfa_comments_to_regex1.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/dfa_comments_to_regex2.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\n{{\u0026lt; figure src=\u0026ldquo;/images/minijava/scanner/dfa_comments_to_regex3.svg\u0026rdquo; width=\u0026ldquo;800px\u0026rdquo; height=\u0026ldquo;auto\u0026rdquo;\u0026gt;}}\nIdentification de motifs Analyseur lexical avec ocamllex Ressources {{% notice info %}} Jouer avec les expressions régulières\nTester des expressions régulières\n{{% /notice %}}\n Le mot vide est l\u0026rsquo;équivalent de la chaîne de caractères \u0026quot;\u0026quot;. [return] Une expression régulière doit être de taille finie. [return] fnd pour fini non déterministe. [return] Perl signifie Practical Extraction and Report Language, ou Pathologically Eclectic Rubbish Lister . [return] Vous me direz qu\u0026rsquo;il faut encore qu\u0026rsquo;elle soit correcte. C\u0026rsquo;est pas faux , mais dans une preuve il faut juste se convaincre que chaque étape élémentaire est correcte. [return]   "
},
{
	"uri": "/fr/tags/bash/",
	"title": "Bash",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/c/",
	"title": "C",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/compilation/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/compiler/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": "De manière abstraite, un compilateur est un programme qui transforme un fichier d\u0026rsquo;entrée contenant une certaine représentation en un fichier de sortie contenant une autre représentation.\ngraph LR; subgraph fichier d'entrée A[Représentation A] end A[Représentation A] -- C(fa:fa-tools Compilateur) C -- B subgraph fichier de sortie B[Représentation B] end  Généralement, le fichier d\u0026rsquo;entrée sera un fichier contenant un langage de programmation (fichier en langage C par exemple) et le fichier de sortie sera un fichier contenant une représentation exécutable directement par la machine (avec l\u0026rsquo;aide du système d\u0026rsquo;exploitation) ou par une machine virtuelle. Un compilateur va généralement produire plusieurs représentations intermédiaires avant de produire la représentation finale. Le compilateur pourra effectuer, selon le langage source, de l\u0026rsquo;analyse statique de types pour essayer de détecter des erreurs avant l\u0026rsquo;exécution du programme et pourra transformer le programme source, sans changer sa sémantique, en un code plus efficace que ce que l\u0026rsquo;utilisateur avait écrit : cette transformation est appelée optimisation.\n Dans la partie MiniJava nous allons étudier une sorte de compilateur qui se nomme transpileur, aussi appelé compilateur source à source, dans lequel la représentation d\u0026rsquo;entrée sera un langage de programmation (le langage MiniJava), et la représentation de sortie sera elle aussi un langage de programmation (le langage C). Nous pourrons ainsi profiter de l\u0026rsquo;existence d\u0026rsquo;un compilateur pour le langage C et nous concentrer seulement sur l\u0026rsquo;analyse statique du fichier source et sur la génération en C des éléments liés à l\u0026rsquo;orientation objet.\nCe premier compilateur nous permettra de rentrer plus en douceur dans le domaine de la compilation tout en montrant une approche très pratique pour écrire plus rapidement un compilateur sans avoir à se soucier de la difficulté de générer du code machine optimisé pour une architecture particulière.  "
},
{
	"uri": "/fr/tags/langage-%C3%A0-objets/",
	"title": "Langage À Objets",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/menhir/",
	"title": "Menhir",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/minijava/",
	"title": "Minijava",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/",
	"title": "MrCodeur",
	"tags": [],
	"description": "",
	"content": " MrCodeur \u0026ldquo;C\u0026rsquo;est en forgeant qu\u0026rsquo;on devient forgeron.\u0026rdquo;\nObjectif Ce petit coin du web est dédié à l\u0026rsquo;apprentissage de l\u0026rsquo;informatique avec pour principe de coder pour apprendre. Nous parcourrons ensemble, pas à pas, différents thèmes de l\u0026rsquo;informatique, construisant tout au long des logiciels pour comprendre en profondeur les différents sujets. J\u0026rsquo;espère que ce site sera utile pour certains d\u0026rsquo;entre vous et que vous vous amuserez tout en apprenant.\nStructure du site Je vais utiliser du texte, des vidéos et du code pour expliquer les différents sujets:\n Les vidéos seront en français avec des sous-titres anglais. Le code sera sur github.  Choisissez votre sujet sur le panneau de gauche ou parmis les thèmes ci-dessous, et nous allons pouvoir commencer à explorer ensemble le monde vaste et passionnant de l\u0026rsquo;informatique !\nThèmes abordés  MiniJava transpileur  Nous transformons un fichier source contenant un programme écrit dans un sous-ensemble du langage Java, le langage MiniJava, en un fichier en langage C. Nous utilisons ensuite gcc pour traduire le fichier en langage C en un fichier exécutable.\nPour effectuer cette transpilation, nous faisons d\u0026rsquo;abord une analyse lexicale du fichier source, puis une analyse syntaxique, puis une vérification du typage (analyse statique) et enfin une génération du code C à partir de l\u0026rsquo;arbre syntaxique abstrait de MiniJava. Les difficultés principales pour la génération du code C sont la représentation des classes, l\u0026rsquo;implémentation de la liaison dynamique et l\u0026rsquo;ajout du ramasse miettes.\nLe transpileur est écrit en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.   "
},
{
	"uri": "/fr/tags/ocaml/",
	"title": "Ocaml",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/ramasse-miettes/",
	"title": "Ramasse Miettes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/transpileur/",
	"title": "Transpileur",
	"tags": [],
	"description": "",
	"content": ""
}]