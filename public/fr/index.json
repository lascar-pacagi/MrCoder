[
{
	"uri": "/fr/compiler/minijava/",
	"title": "MiniJava",
	"tags": ["compilation", "transpileur", "ramasse miettes", "langage à objets", "MiniJava", "C", "OCaml", "Menhir", "Bash"],
	"description": "",
	"content": " MiniJava Le compilateur que nous allons étudier dans cette partie est un transpileur permettant de passer du langage MiniJava au langage C. Il sera réalisé en en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.\nPour télécharger le code : git clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git.\n"
},
{
	"uri": "/fr/compiler/minijava/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Nous allons réaliser un transpileur, ou compilateur source à source, pour un sous-ensemble du langage Java, le langage MiniJava. La représentation d\u0026rsquo;entrée pour notre compilateur sera donc le langage MiniJava. La représentation en sortie de notre compilateur sera le langage C.\nUne exemple de programme permettant de calculer une factorielle est donné ci-dessous.\nclass Factorial { public static void main(String[] a) { System.out.println(new Fac().computeFac(10)); } } class Fac { public int computeFac(int num) { int numAux; if (num \u0026lt; 1) numAux = 1; else numAux = num * (this.computeFac(num-1)); return numAux; } } Comme Minijava est un sous-ensemble de Java, nous pourrons compiler nos fichiers MiniJava en utilisant le compilateur Java javac ce qui sera pratique pour tester la validité de nos traductions en langage C. En effet, nous pourrons comparer la sortie du programme obtenu en utilisant le compilateur Java, avec la sortie obtenue par l\u0026rsquo;exécutable obtenu grâce à notre transpileur.\n Vue d\u0026rsquo;ensemble du transpileur Nous allons considérer le programme MiniJava suivant pour illustrer cette section.  class Print42 { public static void main(String[] a) { System.out.println(35 + 2 * 3 + 1); } }\nLa figure suivante montre les différentes étapes permettant de passer du fichier source en MiniJava au fichier source transpilé en C.\ngraph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C]  Nous allons maintenant décrire les différentes étapes de la figure ci-dessus.\nPour suivre les démos dans les différentes vidéos qui vont suivre, commencer par installer les dépendances comme indiqué ici. Télécharger ensuite le code en faisant\ngit clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git cd MiniJava git checkout v1.0 make La branche master est la version avec le ramasse miettes et le tag v1.0 est une version sans ramasse miettes. Si vous voulez apporter des modifications à la version 1.0, vous pouvez créer une nouvelle branche (from_v1.0 par exemple) en faisant\ngit checkout -b from_v1.0 v1.0 Le code que je vais utiliser pendant les démos se trouve ci-dessous.\n  Pièces jointes   demo_code.tgz  (3 ko)    Analyse lexicale La première étape est l\u0026rsquo;analyse lexicale qui va permettre de découper un flot de caractères en mots. Ces mots sont appelés unités lexicales. On obtient alors une information plus structurée où les mots clés du langage, les identifiants, les entiers et les booléens ont été identifiés. Cette phase va aussi nous permettre de supprimer les commentaires et les blancs (espaces et retours à la ligne).\nPour le programme ci-dessus, l\u0026rsquo;analyse lexicale va produire le flot d\u0026rsquo;unités lexicales suivantes. On peut voir, par exemple, que le mot clé CLASS a été identifié, que la constante entière INT_CONST 35 aussi.\nCLASS IDENT ‘Print42‘ LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET IDENT ‘a‘ RPAREN LBRACE SYSO LPAREN INT_CONST ‘35‘ PLUS INT_CONST ‘2‘ TIMES INT_CONST ‘3‘ PLUS INT_CONST ‘1‘ RPAREN SEMICOLON RBRACE RBRACE EOF   Analyse syntaxique La deuxième étape, l\u0026rsquo;analyse syntaxique, prend en entrée le flot d\u0026rsquo;unités lexicales et va construire un arbre syntaxique abstrait permettant de représenter la structure du programme sous la forme d\u0026rsquo;un arbre.\nPour le programme ci-dessus, on obtient l\u0026rsquo;arbre suivant. On peut y voir, par exemple, l\u0026rsquo;expression arithmétique avec de manière explicite la priorité des opérateurs (plus c\u0026rsquo;est bas dans l\u0026rsquo;arbre et plus c\u0026rsquo;est prioritaire).\nprogram ├name Print42 ├main_args a └main └ISyso └EBinOp OpAdd ├EBinOp OpAdd │ ├EConst (ConstInt 35) │ └EBinOp OpMul │ ├EConst (ConstInt 2) │ └EConst (ConstInt 3) └EConst (ConstInt 1) L\u0026rsquo;analyse syntaxique a besoin de connaître la structure d\u0026rsquo;un programme MiniJava. Cette structure est donnée sous la forme d\u0026rsquo;une grammaire. La grammaire de MiniJava, dans sa forme EBNF est donnée ci-dessous. Une version sûrement plus lisible pour nous en diagramme syntaxique est donnée ici.1\nProgram = MainClass { ClassDeclaration } \u0026#39;eof\u0026#39; ; MainClass = \u0026#39;class\u0026#39; Identifier \u0026#39;{\u0026#39; \u0026#39;public\u0026#39; \u0026#39;static\u0026#39; \u0026#39;void\u0026#39; \u0026#39;main\u0026#39; \u0026#39;(\u0026#39; \u0026#39;String\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; Identifier \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; Statement \u0026#39;}\u0026#39; \u0026#39;}\u0026#39; ; ClassDeclaration = \u0026#39;class\u0026#39; Identifier [ \u0026#39;extends\u0026#39; Identifier ] \u0026#39;{\u0026#39; { VarDeclaration } { MethodDeclaration } \u0026#39;}\u0026#39; ; VarDeclaration = Type Identifier \u0026#39;;\u0026#39; ; MethodDeclaration = \u0026#39;public\u0026#39; Type Identifier \u0026#39;(\u0026#39; [ Type Identifier { \u0026#39;,\u0026#39; Type Identifier } ] \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; { VarDeclaration } { Statement } \u0026#39;return\u0026#39; Expression \u0026#39;;\u0026#39; \u0026#39;}\u0026#39; ; Type = \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; | \u0026#39;boolean\u0026#39; | \u0026#39;int\u0026#39; | Identifier ; Statement = \u0026#39;{\u0026#39; { Statement } \u0026#39;}\u0026#39; | \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement \u0026#39;else\u0026#39; Statement | \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement | \u0026#39;System.out.println\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; \u0026#39;;\u0026#39; | Identifier \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; | Identifier \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; ; Expression = Expression ( \u0026#39;\u0026amp;\u0026amp;\u0026#39; | \u0026#39;\u0026lt;\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; ) Expression | Expression \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | Expression \u0026#39;.\u0026#39; \u0026#39;length\u0026#39; | Expression \u0026#39;.\u0026#39; Identifier \u0026#39;(\u0026#39; [Expression {\u0026#39;,\u0026#39; Expression}] \u0026#39;)\u0026#39; | Integer | \u0026#39;true\u0026#39; | \u0026#39;false\u0026#39; | Identifier | \u0026#39;this\u0026#39; | \u0026#39;new\u0026#39; \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | \u0026#39;new\u0026#39; Identifier \u0026#39;(\u0026#39; \u0026#39;)\u0026#39; | \u0026#39;!\u0026#39; Expression | \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; ; Letter = \u0026#39;A\u0026#39; | \u0026#39;B\u0026#39; | \u0026#39;C\u0026#39; | \u0026#39;D\u0026#39; | \u0026#39;E\u0026#39; | \u0026#39;F\u0026#39; | \u0026#39;G\u0026#39; | \u0026#39;H\u0026#39; | \u0026#39;I\u0026#39; | \u0026#39;J\u0026#39; | \u0026#39;K\u0026#39; | \u0026#39;L\u0026#39; | \u0026#39;M\u0026#39; | \u0026#39;N\u0026#39; | \u0026#39;O\u0026#39; | \u0026#39;P\u0026#39; | \u0026#39;Q\u0026#39; | \u0026#39;R\u0026#39; | \u0026#39;S\u0026#39; | \u0026#39;T\u0026#39; | \u0026#39;U\u0026#39; | \u0026#39;V\u0026#39; | \u0026#39;W\u0026#39; | \u0026#39;X\u0026#39; | \u0026#39;Y\u0026#39; | \u0026#39;Z\u0026#39; | \u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39; | \u0026#39;d\u0026#39; | \u0026#39;e\u0026#39; | \u0026#39;f\u0026#39; | \u0026#39;g\u0026#39; | \u0026#39;h\u0026#39; | \u0026#39;i\u0026#39; | \u0026#39;j\u0026#39; | \u0026#39;k\u0026#39; | \u0026#39;l\u0026#39; | \u0026#39;m\u0026#39; | \u0026#39;n\u0026#39; | \u0026#39;o\u0026#39; | \u0026#39;p\u0026#39; | \u0026#39;q\u0026#39; | \u0026#39;r\u0026#39; | \u0026#39;s\u0026#39; | \u0026#39;t\u0026#39; | \u0026#39;u\u0026#39; | \u0026#39;v\u0026#39; | \u0026#39;w\u0026#39; | \u0026#39;x\u0026#39; | \u0026#39;y\u0026#39; | \u0026#39;z\u0026#39; ; Digit = \u0026#39;0\u0026#39; | \u0026#39;1\u0026#39; | \u0026#39;2\u0026#39; | \u0026#39;3\u0026#39; | \u0026#39;4\u0026#39; | \u0026#39;5\u0026#39; | \u0026#39;6\u0026#39; | \u0026#39;7\u0026#39; | \u0026#39;8\u0026#39; | \u0026#39;9\u0026#39; ; Integer = Digit { Digit } ; Character = Letter | Digit | \u0026#39;_\u0026#39; ; Identifier = Letter { Letter | Digit | \u0026#39;_\u0026#39; } ;    Typage La troisième étape, l\u0026rsquo;analyse de types, va prendre en entrée l\u0026rsquo;arbre abstrait et va vérifier si le typage est correct. Par exemple, on va vérifier qu\u0026rsquo;on utilise les méthodes avec le bon nombre de paramètres, que les opérateurs + et * sont utilisés avec des opérandes entières, qu\u0026rsquo;une classe est compatible avec une autre via la relation d\u0026rsquo;héritage, \u0026hellip;\n  Génération de code La dernière étape va consister à générer le code en C. On va de nouveau parcourir l\u0026rsquo;arbre syntaxique abstrait pour générer ce code. Pour notre example, on obtient le fichier C ci-dessous.\n#include \u0026lt;stdio.h\u0026gt;int main(int argc, char *argv[]) { printf(\u0026#34;%d\\n\u0026#34;, ((35 + (2 * 3)) + 1)); return 0; }   Sémantique de MiniJava La sémantique de MiniJava est donnée par sa sémantique en tant que programme Java 2. Les principales restrictions sont\n Les classes n\u0026rsquo;héritent pas de la classe Object. Le mot clé super n\u0026rsquo;existe pas. Il y a simplement un constructeur par défaut. Les seuls types autorisés sont,  int. boolean. int[]. Les classes définies par l\u0026rsquo;utilisateur.  La surcharge d\u0026rsquo;opérateurs n\u0026rsquo;est pas autorisée. L\u0026rsquo;instruction System.out.printl() ne peut imprimer que des entiers. Toutes les méthodes doivent retourner une valeur. Il n\u0026rsquo;y a pas d\u0026rsquo;interface, d\u0026rsquo;exception, de généricité, de lambda.  Nous expliquons dans la vidéo suivante les principales différences entre MiniJava et Java.\n  Nous avons décrit rapidement l\u0026rsquo;initialisation par défaut en Java (et MiniJava) dans la vidéo. Nous apportons quelques précisions ci-dessous. Vous pouvez regarder ici pour tous les détails.\nSoit le programme Java Init.java suivant.\n1class Init { 2 public static void main(String[] args) { 3 int i; 4 boolean b; 5 int[] a; 6 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 7 } 8} Si on le compile, on obtient les messages d\u0026rsquo;erreur suivants.\n$ javac Init.java Init.java:6: error: variable i might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable b might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable a might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ 3 errors En effet, les trois variables i, b et a sont situées sur la pile, et leurs valeurs vont dépendre des valeurs qui sont situées sur la pile lors de l\u0026rsquo;appel du main. Java n\u0026rsquo;initialisant pas les variables locales avec une valeur par défaut, le compilateur refuse le programme en nous indiquant que l\u0026rsquo;on cherche à utiliser des variables non initialisées.\nPar contre, le programme suivant est correct car les attributs ont des valeurs par défaut.\n1class Init { 2 public static void main(String[] args) { 3 new Default().print(); 4 } 5} 6 7class Default { 8 private int i; 9 private boolean b; 10 private int[] a; 11 12 public void print() { 13 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 14 } 15} Et on obtient la sortie suivante.\n$ javac Init.java $ java Init 0 false null Rappels sur la liaison dynamique en Java Nous allons faire quelques rappels sur la liaison dynamique en Java dans la vidéo ci-dessous, car la gestion de la liaison dynamique sera un des points les plus difficiles à gérer dans notre transpileur.\n  Questions Reprenons la grammaire de MiniJava. Nous voudrions ajouter la possibilité d\u0026rsquo;avoir\n L\u0026rsquo;opérateur de comparaison ==. Des constructeurs. Des constructeurs et méthodes private.    Quelles sont les modifications à apporter à cette grammaire pour incorporer ces nouveaux éléments ?   Grammaire de MiniJava modifiée.\n    Dans la question précédente, quels terminaux avez-vous dû ajouter à la grammaire (un terminal dans la grammaire deviendra une unité lexicale) ?   == et private.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6} 7 8class B extends A { 9 public boolean m1(int n) { 10 System.out.println(\u0026#34;boolean B:m1(int n)\u0026#34;); 11 return false; 12 } 13}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, à la ligne 9, la méthode m1 est une redéfinition de la méthode m1 de la ligne 2 : elle à le même nom et les mêmes paramètres. Par contre, pour être une redéfinition correcte, il aurait fallu que le type de retour boolean soit compatible avec le type de retour int, mais ce n\u0026rsquo;est pas le cas.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(int n) { 7 System.out.println(\u0026#34;boolean A:m1(int n)\u0026#34;); 8 return false; 9 } 10}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, le type de retour ne permet pas de différentier deux méthodes. Donc même si les méthodes aux lignes 2 et 6 ont des types de retour différents, comme elles se nomment pareil et ont les mêmes paramètres, on a pas une surcharge et il y a donc une erreur.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(A a) { 3 System.out.println(\u0026#34;int A:m1(A a)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(B b) { 7 System.out.println(\u0026#34;boolean A:m1(B b)\u0026#34;); 8 return false; 9 } 10} 11 12class B extends A { 13}   Ce code compile-t-il ?   Ce code compile. Cette fois-ci, la méthode à la ligne 6 est bien une surcharge de la méthode à la ligne 2 car le paramètre est d\u0026rsquo;un type différent.\n  Ressources Cours sur Java de Coursera partie 1\nCours sur Java de Coursera partie 2\nCours sur Java de Coursera partie 3\nCours sur Java de Princeton\nSpécifications du langage Java\nPage de MiniJava\nDiagramme syntaxique de MiniJava\nCours sur le langage C partie 1\nCours sur le langage C partie 2\nCours sur le langage C partie 3\nCours sur le langage C partie 4\nApprendre le C en construisant un Lisp\nCours sur le C moderne\nSpécifications du langage C (norme C11)\n  La description de la grammaire qui permet de générer le diagramme ne suit pas strictement la forme EBNF. Les détails sont donnés ici. [return] Voir ici pour la sémantique du langage Java. [return]   "
},
{
	"uri": "/fr/compiler/minijava/scanner/",
	"title": "Analyse lexicale",
	"tags": [],
	"description": "",
	"content": " graph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C] classDef green fill:#74B559,stroke:#222723,stroke-width:5px; class B green  Nous allons décrire l\u0026rsquo;analyseur lexical de MiniJava qui va permettre de découper les caractères du fichier source en unités lexicales. Ces unités lexicales seront ensuite utilisées par l\u0026rsquo;analyseur syntaxique.\nAvant de décrire cet analyseur lexical, nous allons présenter les expressions régulières qui seront utilisées pour décrire les unités lexicales. Nous étudierons aussi les automates qui permettront d\u0026rsquo;implémenter la reconnaissance des expressions régulières.\nExpressions régulières Les expressions régulières vont nous permettre de décrire succintement et assez intuitivement les unités lexicales de MiniJava et seront utilisées dans le générateur d\u0026rsquo;analyseur lexical ocamllex que nous allons utiliser dans notre transpiler.\nDéfinition Une expression régulière va décrire un ensemble de mots sur un vocabulaire donné. Nous allons prendre comme exemple le vocabulaire $\\mathcal{V} = \\{0, 1\\}$ constitué simplement de deux éléments : 0 et 1. Nous décrivons ci-dessous de manière informelle les éléments de base et les opérateurs permettant de créer des expressions régulières et les mots qu\u0026rsquo;elles décrivent.\n Expressions régulières de base :\n L\u0026rsquo;expression régulière $\\color{green}\\epsilon$ génère l\u0026rsquo;ensemble contenant simplement le mot vide1: $\\{\\epsilon\\}$. Pour $c \\in \\mathcal{V}$, l\u0026rsquo;expression régulière $\\color{green}c$ représente l\u0026rsquo;ensemble contenant un seul mot : $\\{c\\}$. -- --\n   Expression Ensemble de mots     $\\color{green}0$ $\\{0\\}$   $\\color{green}1$ $\\{1\\}$     Expressions régulières composées :\n On peut utiliser des parenthèses pour regrouper des expressions régulières. Soit $\\color{green}{r}$ une expression régulière, alors $\\color{green}{(r)}$ représente le même ensemble de mots que l\u0026rsquo;expression $\\color{green}{r}$.\n   Expression Ensemble de mots     $\\color{green}{(0)}$ $\\{0\\}$    L\u0026rsquo;opérateur de concaténation permet de juxtaposer les mots engendrés par deux expressions régulières. Soit $\\color{green}{r_1}$ et $\\color{green}{r_2}$ deux expressions régulières. La concaténation de ces deux expressions régulières est notée : $\\color{green}{r_1r_2}$. L\u0026rsquo;ensemble des mots décrit par cette expression régulière est la concaténation des mots décrit par $\\color{green}{r_1}$ avec ceux décrit par $\\color{green}{r_2}$.\nNotons que cet opérateur est associatif, c\u0026rsquo;est-à-dire que pour toute expression régulière $\\color{green}{r_1}$, $\\color{green}{r_2}$ et $\\color{green}{r_3}$, on a $\\color{green}{(r_1r_2)r_3} = \\color{green}{r_1(r_2r_3)}$ que l\u0026rsquo;on notera simplement $\\color{green}{r_1r_2r_3}$.\n   Expression Ensemble de mots     $\\color{green}{\\epsilon1}$ $\\{1\\}$   $\\color{green}{10}$ $\\{10\\}$   $\\color{green}{(10)1}$ $\\{101\\}$   $\\color{green}{1(01)}$ $\\{101\\}$   $\\color{green}{101}$ $\\{101\\}$    L\u0026rsquo;opérateur d\u0026rsquo;union permet de faire l\u0026rsquo;union des mots engendrés par deux expressions régulières. Soit $\\color{green}{r_1}$ et $\\color{green}{r_2}$ deux expressions régulières. L\u0026rsquo;union de ces deux expressions régulières est notée : $\\color{green}{r_1 | \\ r_2}$. L\u0026rsquo;ensemble des mots décrit par cette expression régulière est l\u0026rsquo;union des mots décrit par $\\color{green}{r_1}$ avec ceux décrit par $\\color{green}{r_2}$.\nNotons que cet opérateur est commutatif, c\u0026rsquo;est-à-dire que $\\color{green}{r_1\\ |\\ r_2} = \\color{green}{r_2\\ |\\ r_1}$. Il est aussi associatif, c\u0026rsquo;est-à-dire que pour toute expression régulière $\\color{green}{r_1}$, $\\color{green}{r_2}$ et $\\color{green}{r_3}$, on a $\\color{green}{(r_1\\ |\\ r_2)\\ |\\ r_3} = \\color{green}{r_1\\ |\\ (r_2\\ |\\ r_3)}$ que l\u0026rsquo;on notera simplement $\\color{green}{r_1\\ |\\ r_2\\ |\\ r_3}$.\n   Expression Ensemble de mots     $\\color{green}{\\epsilon \\ | \\ 1}$ $\\{\\epsilon, 1\\}$   $\\color{green}{(00) \\ | \\ (10)}$ $\\{00, 10\\}$   $\\color{green}{(10) \\ | \\ (00)}$ $\\{00, 10\\}$   $\\color{green}{(0 \\ | \\ 1)\\ |\\ (10)}$ $\\{0, 1, 10\\}$   $\\color{green}{0\\ |\\ (1 \\ | \\ (10))}$ $\\{0, 1, 10\\}$   $\\color{green}{0 \\ | \\ 1\\ |\\ (10)}$ $\\{0, 1, 10\\}$   $\\color{green}{(0\\ |\\ 1)(0\\ |\\ 1)}$ $\\{00, 01, 10, 11\\}$    L\u0026rsquo;opérateur d\u0026rsquo;itération noté * permet de juxtaposer $0$ ou plusieurs fois les mots engendrés par une expression régulières. Soit $\\color{green}{r}$ une expression régulière, alors l\u0026rsquo;expression régulière $\\color{green}{r^*}$ représente l\u0026rsquo;hypothétique2 expression régulière $\\color{green}{\\epsilon \\ |\\ r\\ |\\ rr\\ |\\ rrr\\ |\\ rrrr\\ |\\ \\cdots}$.\n   Expression Ensemble de mots     $\\color{green}{0^*}$ $\\{\\epsilon, 0, 00, 000, 0000, \\cdots\\}$   $\\color{green}{(0\\ | \\ 1)^*}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \\cdots\\}$      Pour éviter trop de parenthèses, il existe une priorité entre les différents opérateurs : les parenthèses ont la plus grande priorité, ensuite l\u0026rsquo;opérateur $\\color{green}{*}$, puis l\u0026rsquo;opérateur de concaténation et enfin l\u0026rsquo;opérateur $\\color{green}{|}$. On a vu aussi ci-dessus que les opérateurs de concaténation et d\u0026rsquo;union sont associatifs, ce qui nous permet de supprimer d\u0026rsquo;avantage de parenthèses.\nAinsi, l\u0026rsquo;expression régulière $\\color{green}{10^*1\\ |\\ 11\\ |\\ \\epsilon}$ se lit $\\color{green}{(((1(0^ *))1)\\ |\\ (11))\\ |\\ \\epsilon}$\n Examples Nous donnons ci-dessous quelques examples d\u0026rsquo;expressions régulières toujours sur le vocabulaire $\\mathcal{V} = \\{0, 1\\}$.\n-- --    Description Expression Ensemble de mots     Les nombres binaires (sans zéro non significatif) $\\color{green}{0\\ | \\ 1(0\\ | \\ 1)^*}$ $\\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \\cdots\\}$   Les nombres binaires impairs $\\color{green}{1\\ | \\ 1(0\\ | \\ 1)^*1}$ $\\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \\cdots\\}$   Les chaînes de bits ne contenant que des zeros et des uns alternés $\\color{green}{10(10)^* \\ | \\ 01(01)^*}$ $\\{10, 01, 1010, 0101, 101010, 010101, \\cdots\\}$   Les chaînes de bits dont la longueur est multiple de 3 $\\color{green}{((0\\ | \\ 1)(0\\ | \\ 1)(0\\ | \\ 1))^*}$ $\\{\\epsilon, 000, 001, 010, 011, 100, \\cdots, 111000, 111001, \\cdots, 101011110, \\cdots \\}$   Les chaînes de bits ne contenant pas la sous-chaîne $11$ $\\color{green}{0^* ( 100^* )^* (1\\ | \\ \\epsilon)}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \\cdots\\}$    Vous pouvez vous amuser en utilisant les expressions régulières sur Regex Crossword .\n     Questions On utilisera la notation $\\{a,b\\}^*$ dans les questions ci-dessous : $\\{a,b\\}^*$ représente le langage engendré par l\u0026rsquo;expression régulière $\\color{green}{(a\\ |\\ b)^*}$.\n  Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner une expression régulière permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient les mots $aa$ ou $bb$ $\\}$.       Cette question même si on pourrait penser qu\u0026#39;elle ressemble beaucoup à la précédente n\u0026#39;est pas facile. Vous pouvez revenir sur cette question après avoir vu la section suivante sur les automates. Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner une expression régulière permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ ne contient pas les mots $aa$ ou $bb$ $\\}$.     On veut se déplacer dans la grille ci-dessous en utilisant les deux actions : \u0026ldquo;aller à droite\u0026rdquo; et \u0026ldquo;aller en haut\u0026rdquo;. On part du coin inférieur gauche et on veut arriver au coin supérieur droit. Un chemin possible est indiqué dans la figure de droite.\n    Écrire une expression régulière permettant de décrire toutes les actions permettant d\u0026#39;aller du coin inférieur gauche au coin supérieur droit.   On ne peut pas écrire succintement cette expression régulière sans utiliser des extensions. On va devoir énumérer les différentes configurations. Le nombre de possibilités est le nombre de combinaisons de 3 éléments parmis 6 : ${{6}\\choose{3}} = 20$. En effet, il faut 6 actions pour aller du départ jusqu\u0026rsquo;à l\u0026rsquo;arrivée. Parmis ces 6 actions, 3 doivent aller vers la droite et 3 vers le haut. On va donc créer une expression régulière avec 20 parties. Nous utilisons D pour allez à droite et H pour allez en haut.\n$$ \\scriptsize \\color{green}{HHHDDD\\ |\nHHDHDD\\ |\nHHDDHD\\ |\nHHDDDH\\ |\nHDHHDD\\ |\nHDHDHD\\ |\nHDHDDH\\ |\nHDDHHD\\ |\nHDDHDH\\ |\nHDDDHH\\ |\nDHHHDD\\ |\nDHHDHD\\ |\nDHHDDH\\ |\nDHDHHD\\ |\nDHDHDH\\ |\nDHDDHH\\ |\nDDHHHD\\ |\nDDHHDH\\ |\nDDHDHH\\ |\nDDDHHH } $$\nNous avons généré les combinaisons ci-dessus grâce au programme suivant.\n#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const string HAUT = \u0026#34;H\u0026#34;; const string DROITE = \u0026#34;D\u0026#34;; void combos(int nH, int nD, string res) { if (!nH \u0026amp;\u0026amp; !nD) { cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } if (nH) { combos(nH - 1, nD, res + HAUT); } if (nD) { combos(nH, nD - 1, res + DROITE); } } int main(int argc, char *argv[]) { combos(3, 3, \u0026#34;\u0026#34;); }  En utilisant les extensions des expressions régulières on peut obtenir la forme plus concise suivante.\n^(?!(.*H.*){4}|(.*D.*){4})(H|D){6}$ Dans cette expression, l\u0026rsquo;opérateur (?!(.*H.*){4}|(.*D.*){4}) exprime qu\u0026rsquo;il ne faut pas réussir à trouver quatre H ou quatre D dans la suite de la ligne. L\u0026rsquo;expression (H|D){6} exprime qu\u0026rsquo;il faut reconnaître six caractères parmis H et D. On exprime donc qu\u0026rsquo;il faut reconnaître six caractères parmis H et D, mais on ne doit pas trouver quatre H ou quatre D. On doit donc avoir exactement trois H et trois D.\n    Cette question n\u0026#39;est pas facile. Vous pouvez revenir sur cette question après avoir vu la section suivante sur les automates. Soit l\u0026#39;alphabet $\\{a, b\\}$. Donner une expression régulière permettant de décrire le langage : $\\{ w \\in \\{ a, b\\}^*\\ |\\ w$ contient un nombre pair de $a$ et un nombre impair de $b$ $\\}$.       Soit l\u0026#39;alphabet $\\{0, 1\\}$. Quel est le langage décrit par l\u0026#39;expression régulière suivante : $\\color{green}{0^*10^*10^*(10^*\\ |\\ \\epsilon)}$ ?   Le langage contenant deux ou trois 1.\n  Automates Dans la section précédente nous avons présenté les expressions régulières qui permettent de décrire les langages dit réguliers. Cette notation est pratique pour décrire les langages réguliers, et nous l\u0026rsquo;utiliserons pour décrire les unités lexicales dans l\u0026rsquo;analyseur lexical de MiniJava. Par contre, pour la reconnaissance, c\u0026rsquo;est-à-dire pour savoir si un mot donné appartient bien au langage décrit par une expression régulière, il n\u0026rsquo;est pas facile d\u0026rsquo;utiliser directement une expression régulière.\nNous allons décrire maintenant les automates finis, non-déterministes et déterministes, qui permettent de répondre plus facilement à la question de savoir si un mot donné appartient bien à un langage régulier donné. Nous nous servirons de ces automates dans la section suivante pour construire un logiciel permettant de tester efficacement, si un mot donné appartient bien au langage engendré par une expression régulière donnée.\nNotons que les langages décrits par les automates finis (non-déterministes ou déterministes) sont les langages réguliers, les expressions régulières et les automates sont donc deux façons équivalentes permettant de décrire les mêmes langages.\nAutomates finis non-déterministes La figure suivante représente un automate fini non-déterministe qui décrit les commentaires en C de type /*...*/. On suppose, pour simplifier, que notre vocabulaire est $\\mathcal{V} = \\{ a, b, /, * \\}$. Sur cette figure on peut voir les éléments suivants :\n Des états, les cercles sur la figure, numérotés de 0 à 7 pour cet exemple. On peut y voir l\u0026rsquo;état de départ, l\u0026rsquo;état 0, qui possède une flèche qui arrive sur l\u0026rsquo;état 0 mais qui part d\u0026rsquo;aucun autre état. L\u0026rsquo;état 7 est un état d\u0026rsquo;acceptation, il est représenté par un double cercle.\n Des transitions entre états, les flèches sur la figure.\n    Automates finis déterministes   Passage d\u0026rsquo;un automate à une expression régulière Nous allons décrire plus en détail les liens entre expressions régulières et automates dans les vidéos ci-dessous, mais nous pouvons retrouver l\u0026rsquo;expression régulière permettant de décrire les commentaires en C automatiquement à partir d\u0026rsquo;un automate fini (déterministe ou non-déterministe). Nous montrons ci-dessous une suite de transformations permettant de passer de l\u0026rsquo;automate fini déterministe vu plus haut vers une expression régulière équivalente. On peut voir sur les transitions apparaître des expressions régulières au fur et à mesure des transformations. Pour ne pas confondre le caractère * avec l\u0026rsquo;opérateur *, nous avons écrit l\u0026rsquo;opérateur en vert.\n     --         Identification de motifs Analyseur lexical avec ocamllex Ressources Jouer avec les expressions régulières\nTester des expressions régulières\n  Le mot vide est l\u0026rsquo;équivalent de la chaîne de caractères \u0026quot;\u0026quot;. [return] Une expression régulière doit être de taille finie. [return]   "
},
{
	"uri": "/fr/tags/bash/",
	"title": "Bash",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/c/",
	"title": "C",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/compilation/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/compiler/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": "De manière abstraite, un compilateur est un programme qui transforme un fichier d\u0026rsquo;entrée contenant une certaine représentation en un fichier de sortie contenant une autre représentation.\ngraph LR; subgraph fichier d'entrée A[Représentation A] end A[Représentation A] -- C(fa:fa-tools Compilateur) C -- B subgraph fichier de sortie B[Représentation B] end  Généralement, le fichier d\u0026rsquo;entrée sera un fichier contenant un langage de programmation (fichier en langage C par exemple) et le fichier de sortie sera un fichier contenant une représentation exécutable directement par la machine (avec l\u0026rsquo;aide du système d\u0026rsquo;exploitation) ou par une machine virtuelle. Un compilateur va généralement produire plusieurs représentations intermédiaires avant de produire la représentation finale. Le compilateur pourra effectuer, selon le langage source, de l\u0026rsquo;analyse statique de types pour essayer de détecter des erreurs avant l\u0026rsquo;exécution du programme et pourra transformer le programme source, sans changer sa sémantique, en un code plus efficace que ce que l\u0026rsquo;utilisateur avait écrit : cette transformation est appelée optimisation.\n Dans la partie MiniJava nous allons étudier une sorte de compilateur qui se nomme transpileur, aussi appelé compilateur source à source, dans lequel la représentation d\u0026rsquo;entrée sera un langage de programmation (le langage MiniJava), et la représentation de sortie sera elle aussi un langage de programmation (le langage C). Nous pourrons ainsi profiter de l\u0026rsquo;existence d\u0026rsquo;un compilateur pour le langage C et nous concentrer seulement sur l\u0026rsquo;analyse statique du fichier source et sur la génération en C des éléments liés à l\u0026rsquo;orientation objet.\nCe premier compilateur nous permettra de rentrer plus en douceur dans le domaine de la compilation tout en montrant une approche très pratique pour écrire plus rapidement un compilateur sans avoir à se soucier de la difficulté de générer du code machine optimisé pour une architecture particulière.  "
},
{
	"uri": "/fr/tags/langage-%C3%A0-objets/",
	"title": "Langage À Objets",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/menhir/",
	"title": "Menhir",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/minijava/",
	"title": "Minijava",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/",
	"title": "MrCodeur",
	"tags": [],
	"description": "",
	"content": " MrCodeur \u0026ldquo;C\u0026rsquo;est en forgeant qu\u0026rsquo;on devient forgeron.\u0026rdquo;\nObjectif Ce petit coin du web est dédié à l\u0026rsquo;apprentissage de l\u0026rsquo;informatique avec pour principe de coder pour apprendre. Nous parcourrons ensemble, pas à pas, différents thèmes de l\u0026rsquo;informatique, construisant tout au long des logiciels pour comprendre en profondeur les différents sujets. J\u0026rsquo;espère que ce site sera utile pour certains d\u0026rsquo;entre vous et que vous vous amuserez tout en apprenant.\nStructure du site Je vais utiliser du texte, des vidéos et du code pour expliquer les différents sujets:\n Les vidéos seront en français avec des sous-titres anglais. Le code sera sur github.  Choisissez votre sujet sur le panneau de gauche ou parmis les thèmes ci-dessous, et nous allons pouvoir commencer à explorer ensemble le monde vaste et passionnant de l\u0026rsquo;informatique !\nThèmes abordés  MiniJava transpileur  Nous transformons un fichier source contenant un programme écrit dans un sous-ensemble du langage Java, le langage MiniJava, en un fichier en langage C. Nous utilisons ensuite gcc pour traduire le fichier en langage C en un fichier exécutable.\nPour effectuer cette transpilation, nous faisons d\u0026rsquo;abord une analyse lexicale du fichier source, puis une analyse syntaxique, puis une vérification du typage (analyse statique) et enfin une génération du code C à partir de l\u0026rsquo;arbre syntaxique abstrait de MiniJava. Les difficultés principales pour la génération du code C sont la représentation des classes, l\u0026rsquo;implémentation de la liaison dynamique et l\u0026rsquo;ajout du ramasse miettes.\nLe transpileur est écrit en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.   "
},
{
	"uri": "/fr/tags/ocaml/",
	"title": "Ocaml",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/ramasse-miettes/",
	"title": "Ramasse Miettes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/transpileur/",
	"title": "Transpileur",
	"tags": [],
	"description": "",
	"content": ""
}]