[
{
	"uri": "/fr/compiler/minijava/",
	"title": "MiniJava",
	"tags": ["compilation", "transpileur", "ramasse miettes", "langage à objets", "MiniJava", "C", "OCaml", "Menhir", "Bash"],
	"description": "",
	"content": " MiniJava Le compilateur que nous allons étudier dans cette partie est un transpileur permettant de passer du langage MiniJava au langage C. Il sera réalisé en en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.\nPour télécharger le code : git clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git.\n"
},
{
	"uri": "/fr/compiler/minijava/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Description de MiniJava Nous allons réaliser un transpileur, ou compilateur source à source, pour un sous-ensemble du langage Java, le langage MiniJava. La représentation d\u0026rsquo;entrée pour notre compilateur sera donc le langage MiniJava. La représentation en sortie de notre compilateur sera le langage C.\nUne exemple de programme permettant de calculer une factorielle est donné ci-dessous.\nclass Factorial { public static void main(String[] a) { System.out.println(new Fac().computeFac(10)); } } class Fac { public int computeFac(int num) { int numAux; if (num \u0026lt; 1) numAux = 1; else numAux = num * (this.computeFac(num-1)); return numAux; } } Comme Minijava est un sous-ensemble de Java, nous pourrons compiler nos fichiers MiniJava en utilisant le compilateur Java javac ce qui sera pratique pour tester la validité de nos traductions en langage C. En effet, nous pourrons comparer la sortie du programme obtenu en utilisant le compilateur Java, avec la sortie obtenue par l\u0026rsquo;exécutable obtenu grâce à notre transpileur.\n La grammaire de MiniJava, dans sa forme EBNF est donnée ci-dessous. Une version sûrement plus lisible pour nous en diagramme syntaxique est donnée ici.1\nProgram = MainClass { ClassDeclaration } \u0026#39;eof\u0026#39; ; MainClass = \u0026#39;class\u0026#39; Identifier \u0026#39;{\u0026#39; \u0026#39;public\u0026#39; \u0026#39;static\u0026#39; \u0026#39;void\u0026#39; \u0026#39;main\u0026#39; \u0026#39;(\u0026#39; \u0026#39;String\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; Identifier \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; Statement \u0026#39;}\u0026#39; \u0026#39;}\u0026#39; ; ClassDeclaration = \u0026#39;class\u0026#39; Identifier [ \u0026#39;extends\u0026#39; Identifier ] \u0026#39;{\u0026#39; { VarDeclaration } { MethodDeclaration } \u0026#39;}\u0026#39; ; VarDeclaration = Type Identifier \u0026#39;;\u0026#39; ; MethodDeclaration = \u0026#39;public\u0026#39; Type Identifier \u0026#39;(\u0026#39; [ Type Identifier { \u0026#39;,\u0026#39; Type Identifier } ] \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; { VarDeclaration } { Statement } \u0026#39;return\u0026#39; Expression \u0026#39;;\u0026#39; \u0026#39;}\u0026#39; ; Type = \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; | \u0026#39;boolean\u0026#39; | \u0026#39;int\u0026#39; | Identifier ; Statement = \u0026#39;{\u0026#39; { Statement } \u0026#39;}\u0026#39; | \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement \u0026#39;else\u0026#39; Statement | \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement | \u0026#39;System.out.println\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; \u0026#39;;\u0026#39; | Identifier \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; | Identifier \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; ; Expression = Expression ( \u0026#39;\u0026amp;\u0026amp;\u0026#39; | \u0026#39;\u0026lt;\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; ) Expression | Expression \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | Expression \u0026#39;.\u0026#39; \u0026#39;length\u0026#39; | Expression \u0026#39;.\u0026#39; Identifier \u0026#39;(\u0026#39; [Expression {\u0026#39;,\u0026#39; Expression}] \u0026#39;)\u0026#39; | Integer | \u0026#39;true\u0026#39; | \u0026#39;false\u0026#39; | Identifier | \u0026#39;this\u0026#39; | \u0026#39;new\u0026#39; \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | \u0026#39;new\u0026#39; Identifier \u0026#39;(\u0026#39; \u0026#39;)\u0026#39; | \u0026#39;!\u0026#39; Expression | \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; ; Letter = \u0026#39;A\u0026#39; | \u0026#39;B\u0026#39; | \u0026#39;C\u0026#39; | \u0026#39;D\u0026#39; | \u0026#39;E\u0026#39; | \u0026#39;F\u0026#39; | \u0026#39;G\u0026#39; | \u0026#39;H\u0026#39; | \u0026#39;I\u0026#39; | \u0026#39;J\u0026#39; | \u0026#39;K\u0026#39; | \u0026#39;L\u0026#39; | \u0026#39;M\u0026#39; | \u0026#39;N\u0026#39; | \u0026#39;O\u0026#39; | \u0026#39;P\u0026#39; | \u0026#39;Q\u0026#39; | \u0026#39;R\u0026#39; | \u0026#39;S\u0026#39; | \u0026#39;T\u0026#39; | \u0026#39;U\u0026#39; | \u0026#39;V\u0026#39; | \u0026#39;W\u0026#39; | \u0026#39;X\u0026#39; | \u0026#39;Y\u0026#39; | \u0026#39;Z\u0026#39; | \u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39; | \u0026#39;d\u0026#39; | \u0026#39;e\u0026#39; | \u0026#39;f\u0026#39; | \u0026#39;g\u0026#39; | \u0026#39;h\u0026#39; | \u0026#39;i\u0026#39; | \u0026#39;j\u0026#39; | \u0026#39;k\u0026#39; | \u0026#39;l\u0026#39; | \u0026#39;m\u0026#39; | \u0026#39;n\u0026#39; | \u0026#39;o\u0026#39; | \u0026#39;p\u0026#39; | \u0026#39;q\u0026#39; | \u0026#39;r\u0026#39; | \u0026#39;s\u0026#39; | \u0026#39;t\u0026#39; | \u0026#39;u\u0026#39; | \u0026#39;v\u0026#39; | \u0026#39;w\u0026#39; | \u0026#39;x\u0026#39; | \u0026#39;y\u0026#39; | \u0026#39;z\u0026#39; ; Digit = \u0026#39;0\u0026#39; | \u0026#39;1\u0026#39; | \u0026#39;2\u0026#39; | \u0026#39;3\u0026#39; | \u0026#39;4\u0026#39; | \u0026#39;5\u0026#39; | \u0026#39;6\u0026#39; | \u0026#39;7\u0026#39; | \u0026#39;8\u0026#39; | \u0026#39;9\u0026#39; ; Integer = Digit { Digit } ; Character = Letter | Digit | \u0026#39;_\u0026#39; ; Identifier = Letter { Letter | Digit | \u0026#39;_\u0026#39; } ; La sémantique de MiniJava est donnée par sa sémantique en tant que programme Java. Les principales restrictions sont\n Les classes n\u0026rsquo;héritent pas de la classe Object. Le mot clé super n\u0026rsquo;existe pas. Il y a simplement un constructeur par défaut. Les seuls types autorisés sont,  int. boolean. int[]. Les classes définies par l\u0026rsquo;utilisateur.  La surcharge d\u0026rsquo;opérateurs n\u0026rsquo;est pas autorisée. L\u0026rsquo;instruction System.out.printl() ne peut imprimer que des entiers. Toutes les méthodes doivent retourner une valeur. Il n\u0026rsquo;y a pas d\u0026rsquo;interface, d\u0026rsquo;exception, de généricité, de lambda.  Vue d\u0026rsquo;ensemble du transpileur Nous allons considérer le programme MiniJava suivant pour illustrer cette section.  class Print42 { public static void main(String[] a) { System.out.println(35 + 2 * 3 + 1); } }\nLa figure suivante montre les différentes étapes permettant de passer du fichier source en MiniJava au fichier source transpilé en C.\ngraph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C]   La première étape est l\u0026rsquo;analyse lexicale qui va permettre de découper un flot de caractères en mots. Ces mots sont appelés unités lexicales. On obtient alors une information plus structurée où les mots clés du langage, les identifiants, les entiers et les booléens ont été identifiés. Cette phase va aussi nous permettre de supprimer les commentaires et les blancs (espaces et retours à la ligne).\nPour le programme ci-dessus, l\u0026rsquo;analyse lexicale va produire le flot d\u0026rsquo;unités lexicales suivantes. On peut voir, par exemple, que le mot clé CLASS a été identifié, que la constante entière INT_CONST 35 aussi.  CLASS IDENT ‘Print42‘ LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET IDENT ‘a‘ RPAREN LBRACE SYSO LPAREN INT_CONST ‘35‘ PLUS INT_CONST ‘2‘ TIMES INT_CONST ‘3‘ PLUS INT_CONST ‘1‘ RPAREN SEMICOLON RBRACE RBRACE EOF  La deuxième étape, l\u0026rsquo;analyse syntaxique, prend en entrée le flot d\u0026rsquo;unités lexicales et va construire un arbre syntaxique abstrait permettant de représenter la structure du programme sous la forme d\u0026rsquo;un arbre.\nPour le programme ci-dessus, on obtient l\u0026rsquo;arbre suivant. On peut y voir, par exemple, l\u0026rsquo;expression arithmétique avec de manière explicite la priorité des opérateurs (plus c\u0026rsquo;est bas dans l\u0026rsquo;arbre et plus c\u0026rsquo;est prioritaire).  program ├name Print42 ├main_args a └main └ISyso └EBinOp OpAdd ├EBinOp OpAdd │ ├EConst (ConstInt 35) │ └EBinOp OpMul │ ├EConst (ConstInt 2) │ └EConst (ConstInt 3) └EConst (ConstInt 1)  La troisième étape, l\u0026rsquo;analyse de types, va prendre en entrée l\u0026rsquo;arbre abstrait et va vérifier si le typage est correct. Par exemple, on va vérifier qu\u0026rsquo;on utilise les méthodes avec le bon nombre de paramètres, que les opérateurs + et * sont utilisés avec des opérandes entières, qu\u0026rsquo;une classe est compatible avec une autre via la relation d\u0026rsquo;héritage, \u0026hellip;\n La dernière étape va consister à générer le code en C. On va de nouveau parcourir l\u0026rsquo;arbre syntaxique abstrait pour générer ce code. Pour notre example, on obtient le fichier C ci-dessous.\n  #include \u0026lt;stdio.h\u0026gt;int main(int argc, char *argv[]) { printf(\u0026#34;%d\\n\u0026#34;, ((35 + (2 * 3)) + 1)); return 0; } Vidéos Pour suivre les démos dans les vidéos, commencer par installer les dépendances comme indiqué ici. Télécharger ensuite le code en faisant\ngit clone --recurse-submodules git@github.com:lascar-pacagi/MiniJava.git cd MiniJava git checkout v1.0 make La branche master est la version avec le ramasse miettes et le tag v1.0 est une version sans ramasse miettes. Si vous voulez apporter des modifications à la version 1.0, vous pouvez créer une nouvelle branche (from_v1.0 par exemple) en faisant\ngit checkout -b from_v1.0 v1.0 Le code que je vais utiliser pendant les démos se trouve ci-dessous.\n  Pièces jointes   demo_code.tgz  (3 ko)    Analyse lexicale   Analyse syntaxique   Typage   Génération de code   Principales différences entre MiniJava et Java Rappels sur la liaison dynamique en Java Questions Reprenons la grammaire de MiniJava. Nous voudrions ajouter la possibilité d\u0026rsquo;avoir\n L\u0026rsquo;opérateur de comparaison ==. Des constructeurs. Des constructeurs et méthodes private.    Quelles sont les modifications à apporter à cette grammaire pour incorporer ces nouveaux éléments ?   Grammaire de MiniJava modifiée.\n    Dans la question précédente, quels terminaux avez-vous dû ajouter à la grammaire (un terminal dans la grammaire deviendra une unité lexicale) ?   == et private.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6} 7 8class B extends A { 9 public boolean m1(int n) { 10 System.out.println(\u0026#34;boolean B:m1(int n)\u0026#34;); 11 return false; 12 } 13}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, à la ligne 9, la méthode m1 est une redéfinition de la méthode m1 de la ligne 2 : elle à le même nom et les mêmes paramètres. Par contre, pour être une redéfinition correcte, il aurait fallu que le type de retour boolean soit compatible avec le type de retour int, mais ce n\u0026rsquo;est pas le cas.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(int n) { 7 System.out.println(\u0026#34;boolean A:m1(int n)\u0026#34;); 8 return false; 9 } 10}   Ce code compile-t-il ?   Ce code ne compile pas. En effet, le type de retour ne permet pas de différentier deux méthodes. Donc même si les méthodes aux lignes 2 et 6 ont des types de retour différents, comme elles se nomment pareil et ont les mêmes paramètres, on a pas une surcharge et il y a donc une erreur.\n  Soit le programme Java suivant.\n1class A { 2 public int m1(A a) { 3 System.out.println(\u0026#34;int A:m1(A a)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(B b) { 7 System.out.println(\u0026#34;boolean A:m1(B b)\u0026#34;); 8 return false; 9 } 10} 11 12class B extends A { 13}   Ce code compile-t-il ?   Ce code compile. Cette fois-ci, la méthode à la ligne 6 est bien une surcharge de la méthode à la ligne 2 car le paramètre est d\u0026rsquo;un type différent.\n  Ressources Cours sur Java de Coursera partie 1\nCours sur Java de Coursera partie 2\nCours sur Java de Coursera partie 3\nCours sur Java de Princeton\nSpécifications du langage Java\nPage de MiniJava\nDiagramme syntaxique de MiniJava\nCours sur le langage C partie 1\nCours sur le langage C partie 2\nCours sur le langage C partie 3\nCours sur le langage C partie 4\nSpécifications du langage C (norme C11)\n  La description de la grammaire qui permet de générer le diagramme ne suit pas strictement la forme EBNF. Les détails sont donnés ici. [return]   "
},
{
	"uri": "/fr/compiler/minijava/scanner/",
	"title": "Analyse lexicale",
	"tags": [],
	"description": "",
	"content": " graph LR; A[source en MiniJava] --|caractères| B(fa:fa-tools Analyse  lexicale) B --|unités lexicales| C(fa:fa-tools  Analyse  syntaxique) C --|arbre syntaxique abstrait| D(fa:fa-tools  Analyse  de types) D --|arbre syntaxique abstrait| E(fa:fa-tools  Générateur  de code C) E --|caractères| F[source en C] classDef green fill:#74B559,stroke:#222723,stroke-width:5px; class B green  Expressions régulières Analyseur lexical Vidéos Questions Ressources "
},
{
	"uri": "/fr/tags/bash/",
	"title": "Bash",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/c/",
	"title": "C",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/compilation/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/compiler/",
	"title": "Compilation",
	"tags": [],
	"description": "",
	"content": "De manière abstraite, un compilateur est un programme qui transforme un fichier d\u0026rsquo;entrée contenant une certaine représentation en un fichier de sortie contenant une autre représentation.\ngraph LR; subgraph fichier d'entrée A[Représentation A] end A[Représentation A] -- C(fa:fa-tools Compilateur) C -- B subgraph fichier de sortie B[Représentation B] end  Généralement, le fichier d\u0026rsquo;entrée sera un fichier contenant un langage de programmation (fichier en langage C par exemple) et le fichier de sortie sera un fichier contenant une représentation exécutable directement par la machine (avec l\u0026rsquo;aide du système d\u0026rsquo;exploitation) ou par une machine virtuelle. Un compilateur va généralement produire plusieurs représentations intermédiaires avant de produire la représentation finale. Le compilateur pourra effectuer, selon le langage source, de l\u0026rsquo;analyse statique de types pour essayer de détecter des erreurs avant l\u0026rsquo;exécution du programme et pourra transformer le programme source, sans changer sa sémantique, en un code plus efficace que ce que l\u0026rsquo;utilisateur avait écrit : cette transformation est appelée optimisation.\n Dans la partie MiniJava nous allons étudier une sorte de compilateur qui se nomme transpileur, aussi appelé compilateur source à source, dans lequel la représentation d\u0026rsquo;entrée sera un langage de programmation (le langage MiniJava), et la représentation de sortie sera elle aussi un langage de programmation (le langage C). Nous pourrons ainsi profiter de l\u0026rsquo;existence d\u0026rsquo;un compilateur pour le langage C et nous concentrer seulement sur l\u0026rsquo;analyse statique du fichier source et sur la génération en C des éléments liés à l\u0026rsquo;orientation objet.\nCe premier compilateur nous permettra de rentrer plus en douceur dans le domaine de la compilation tout en montrant une approche très pratique pour écrire plus rapidement un compilateur sans avoir à se soucier de la difficulté de générer du code machine optimisé pour une architecture particulière.  "
},
{
	"uri": "/fr/tags/langage-%C3%A0-objets/",
	"title": "Langage À Objets",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/menhir/",
	"title": "Menhir",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/minijava/",
	"title": "Minijava",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/",
	"title": "MrCodeur",
	"tags": [],
	"description": "",
	"content": " MrCodeur \u0026ldquo;C\u0026rsquo;est en forgeant qu\u0026rsquo;on devient forgeron\u0026rdquo;\nObjectif Ce petit coin du web est dédié à l\u0026rsquo;apprentissage de l\u0026rsquo;informatique avec pour principe de coder pour apprendre. Nous parcourrons ensemble, pas à pas, différents thèmes de l\u0026rsquo;informatique, construisant tout au long des logiciels pour comprendre en profondeur les différents sujets. J\u0026rsquo;espère que ce site sera utile pour certains d\u0026rsquo;entre vous et que vous vous amuserez tout en apprenant.\nStructure du site Je vais utiliser du texte, des vidéos et du code pour expliquer les différents sujets:\n Les vidéos seront en français avec des sous-titres anglais. Le code sera sur github.  Choisissez votre sujet sur le panneau de gauche ou parmis les thèmes ci-dessous, et nous allons pouvoir commencer à explorer ensemble le monde vaste et passionnant de l\u0026rsquo;informatique !\nThèmes abordés  MiniJava transpileur  Nous transformons un fichier source contenant un programme écrit dans un sous-ensemble du langage Java, le langage MiniJava, en un fichier en langage C. Nous utilisons ensuite gcc pour traduire le fichier en langage C en un fichier exécutable.\nPour effectuer cette transpilation, nous faisons d\u0026rsquo;abord une analyse lexicale du fichier source, puis une analyse syntaxique, puis une vérification du typage (analyse statique) et enfin une génération du code C à partir de l\u0026rsquo;arbre syntaxique abstrait de MiniJava. Les difficultés principales pour la génération du code C sont la représentation des classes, l\u0026rsquo;implémentation de la liaison dynamique et l\u0026rsquo;ajout du ramasse miettes.\nLe transpileur est écrit en OCaml en utilisant Menhir pour l\u0026rsquo;analyse syntaxique.   "
},
{
	"uri": "/fr/tags/ocaml/",
	"title": "Ocaml",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/ramasse-miettes/",
	"title": "Ramasse Miettes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/fr/tags/transpileur/",
	"title": "Transpileur",
	"tags": [],
	"description": "",
	"content": ""
}]