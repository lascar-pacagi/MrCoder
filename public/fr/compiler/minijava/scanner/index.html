<!DOCTYPE html>
<html lang="fr" class="js csstransforms3d">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.40.1" />
    <meta name="description" content="">


    <link rel="icon" href="/images/favicon.png" type="image/png">

    <title>Analyse lexicale :: MrCodeur</title>

    
    <link href="/css/nucleus.css?1574358075" rel="stylesheet">
    <link href="/css/fontawesome-all.min.css?1574358075" rel="stylesheet">
    <link href="/css/hybrid.css?1574358075" rel="stylesheet">
    <link href="/css/featherlight.min.css?1574358075" rel="stylesheet">
    <link href="/css/perfect-scrollbar.min.css?1574358075" rel="stylesheet">
    <link href="/css/auto-complete.css?1574358075" rel="stylesheet">
    <link href="/css/atom-one-dark-reasonable.css?1574358075" rel="stylesheet">
    <link href="/css/theme.css?1574358075" rel="stylesheet">
    <link href="/css/hugo-theme.css?1574358075" rel="stylesheet">
    
      <link href="/css/theme-green.css?1574358075" rel="stylesheet">
    

    <script src="/js/jquery-3.3.1.min.js?1574358075"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
        :not(pre) > code + span.copy-to-clipboard {
            display: none;
        }
      
    </style>
    
  </head>
  <body class="" data-url="/fr/compiler/minijava/scanner/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <a id="logo" href="/">
    <img src="/images/logo.png">
</a>
    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Rechercher...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="/js/lunr.min.js?1574358075"></script>
<script type="text/javascript" src="/js/auto-complete.js?1574358075"></script>
<script type="text/javascript">
    
        var baseurl = "\/\/fr";
    
</script>
<script type="text/javascript" src="/js/search.js?1574358075"></script>

    
  </div>

    <div class="highlightable">
    <ul class="topics">

        
          
          


 
  
    
    <li data-nav-id="/fr/compiler/" title="Compilation" class="dd-item 
        parent
        
        
        ">
      <a href="/fr/compiler/">
          Compilation
          
      </a>
      
      
        <ul>
          
          
            
          
          
          
        
          
            
            


 
  
    
    <li data-nav-id="/fr/compiler/minijava/" title="MiniJava" class="dd-item 
        parent
        
        
        ">
      <a href="/fr/compiler/minijava/">
          MiniJava
          
      </a>
      
      
        <ul>
          
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/fr/compiler/minijava/introduction/" title="Introduction" class="dd-item ">
        <a href="/fr/compiler/minijava/introduction/">
        Introduction
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/fr/compiler/minijava/scanner/" title="Analyse lexicale" class="dd-item active">
        <a href="/fr/compiler/minijava/scanner/">
        Analyse lexicale
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
         
    </ul>

    
    
      <section id="shortcuts">
        <h3>Contact</h3>
        <ul>
          
              <li> 
                  <a class="padding" href="https://github.com/lascar-pacagi"><i class='fab fa-fw fa-github'></i>dépôt GitHub</a>
              </li>
          
              <li> 
                  <a class="padding" href="https://protonmail.com/"><i class='far fa-fw fa-envelope'></i> lascar.pacagi@protonmail.com</a>
              </li>
          
              <li> 
                  <a class="padding" href="https://kiwiirc.com/nextclient/irc.freenode.net/#mrcoder"><b>IRC</b> freenode #mrcoder</a>
              </li>
          
        </ul>
      </section>
    

    
    <section id="prefooter">
      <hr/>
      <ul>
      
        <li>
          <a class="padding">
            <i class="fas fa-language fa-fw"></i>
          <div class="select-style">
            <select id="select-language" onchange="location = this.value;">
          
          
          
              
              
                  
                    
                    
                      <option id="en" value="/en/compiler/minijava/scanner/">English</option>
                    
                  
              
                  
              
          
              
              
                  
              
                  
                    
                    
                      <option id="fr" value="/fr/compiler/minijava/scanner/" selected>Français</option>
                    
                  
              
          
        </select>
        <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          width="255px" height="255px" viewBox="0 0 255 255" style="enable-background:new 0 0 255 255;" xml:space="preserve">
          <g>
            <g id="arrow-drop-down">
              <polygon points="0,63.75 127.5,191.25 255,63.75 		" />
            </g>
          </g>
        </svg>
        </div>
        </a>
        </li>
      
      
      
      </ul>
    </section>
    
    <section id="footer">
      <p><i class="fas fa-mug-hot fa-2x"></i></p>

    </section>
  </div>
</nav>





        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
          
          
            
            
          
          
            
            
          
          
            
            
          
          
            <a href='/fr/'>MrCodeur</a> > <a href='/fr/compiler/'>Compilation</a> > <a href='/fr/compiler/minijava/'>MiniJava</a> > Analyse lexicale
          
         
          
         
          
         
          
        
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#expressions-régulières">Expressions régulières</a>
<ul>
<li><a href="#définition">Définition</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#questions">Questions</a></li>
</ul></li>
<li><a href="#automates">Automates</a>
<ul>
<li><a href="#automates-finis-non-déterministes">Automates finis non-déterministes</a>
<ul>
<li><a href="#test-de-l-appartenance-d-un-mot-au-langage-décrit-par-l-automate">Test de l&rsquo;appartenance d&rsquo;un mot au langage décrit par l&rsquo;automate</a></li>
<li><a href="#questions-1">Questions</a></li>
</ul></li>
<li><a href="#automates-finis-déterministes">Automates finis déterministes</a></li>
<li><a href="#passage-d-un-automate-à-une-expression-régulière">Passage d&rsquo;un automate à une expression régulière</a></li>
</ul></li>
<li><a href="#identification-de-motifs">Identification de motifs</a></li>
<li><a href="#analyseur-lexical-avec-ocamllex">Analyseur lexical avec ocamllex</a></li>
<li><a href="#ressources">Ressources</a></li>
</ul></li>
</ul>
</nav>
    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
                
                Analyse lexicale
            </h1>
            

            
            <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
 MathJax.Hub.Config({
     tex2jax: {
         inlineMath: [['$','$'], ['\\(','\\)']],
         displayMath: [['$$','$$']],
         processEscapes: true,
         processEnvironments: true,
         skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
         TeX: { equationNumbers: { autoNumber: "AMS" },
                extensions: ["AMSmath.js", "AMSsymbols.js"] }
     }
 });
 MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
 });

 MathJax.Hub.Config({
     
     TeX: { equationNumbers: { autoNumber: "AMS" } }
 });
</script>




<p>{{<mermaid align="center">}}
graph LR;
A[source en MiniJava] &ndash;&gt;|caractères| B(fa:fa-tools<br/> Analyse <br/> lexicale)
B &ndash;&gt;|unités lexicales| C(fa:fa-tools <br/> Analyse <br/> syntaxique)
C &ndash;&gt;|arbre syntaxique abstrait| D(fa:fa-tools <br/> Analyse <br/> de types)
D &ndash;&gt;|arbre syntaxique abstrait| E(fa:fa-tools <br/> Générateur <br/> de code C)
E &ndash;&gt;|caractères| F[source en C]</p>

<p>classDef green fill:#74B559,stroke:#222723,stroke-width:5px;
class B green
{{&lt; /mermaid &gt;}}</p>

<p>Nous allons décrire l&rsquo;analyseur lexical de MiniJava qui va permettre de découper les caractères
du fichier source en unités lexicales. Ces unités lexicales seront ensuite utilisées par l&rsquo;analyseur
syntaxique.<br />
Avant de décrire cet analyseur lexical, nous allons présenter les expressions régulières qui seront utilisées
pour décrire les unités lexicales. Nous étudierons aussi les automates qui permettront d&rsquo;implémenter
la reconnaissance des expressions régulières.
<a name="regular_expressions"></a></p>

<h2 id="expressions-régulières">Expressions régulières</h2>

<p>Les expressions régulières vont nous permettre de décrire succintement et assez intuitivement
les unités lexicales de MiniJava et seront utilisées dans le générateur d&rsquo;analyseur lexical <code>ocamllex</code> que nous
allons utiliser dans notre transpiler.</p>

<h3 id="définition">Définition</h3>

<p>Une expression régulière va décrire un ensemble de mots sur un vocabulaire donné. Nous allons prendre comme exemple
le vocabulaire $\mathcal{V} = \{0, 1\}$ constitué simplement de deux éléments : <code>0</code> et <code>1</code>. Nous décrivons ci-dessous de manière
informelle les éléments de base et les opérateurs permettant de créer des expressions régulières et les mots qu&rsquo;elles
décrivent.</p>

<ul>
<li><p>Expressions régulières de base :</p>

<ul>
<li>L&rsquo;expression régulière $\color{green}\epsilon$ génère l&rsquo;ensemble contenant simplement le mot vide<sup class="footnote-ref" id="fnref:Le-mot-vide-est"><a href="#fn:Le-mot-vide-est">1</a></sup>: $\{\epsilon\}$.</li>

<li><p>Pour $c \in \mathcal{V}$, l&rsquo;expression régulière $\color{green}c$ représente l&rsquo;ensemble contenant un seul mot : $\{c\}$.
<!--  <style> -->
<!-- table { -->
<!--     width:50%; -->
<!-- } -->
<!-- </style> --></p>

<table>
<thead>
<tr>
<th align="center"><center>Expression</center></th>
<th align="center"><center>Ensemble de mots</center></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">$\color{green}0$</td>
<td align="center">$\{0\}$</td>
</tr>

<tr>
<td align="center">$\color{green}1$</td>
<td align="center">$\{1\}$</td>
</tr>
</tbody>
</table></li>
</ul></li>

<li><p>Expressions régulières composées :</p>

<ul>
<li><p>On peut utiliser des parenthèses pour regrouper des expressions régulières. Soit $\color{green}{r}$ une expression régulière, alors $\color{green}{(r)}$ représente le même ensemble de
mots que l&rsquo;expression $\color{green}{r}$.</p>

<table>
<thead>
<tr>
<th align="center"><center>Expression</center></th>
<th align="center"><center>Ensemble de mots</center></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">$\color{green}{(0)}$</td>
<td align="center">$\{0\}$</td>
</tr>
</tbody>
</table></li>

<li><p>L&rsquo;opérateur de concaténation permet de juxtaposer les mots engendrés par deux expressions régulières. Soit $\color{green}{r_1}$ et $\color{green}{r_2}$ deux expressions régulières.
La concaténation de ces deux expressions régulières est notée : $\color{green}{r_1r_2}$. L&rsquo;ensemble des mots décrit par cette expression régulière est
la concaténation des mots décrit par $\color{green}{r_1}$ avec ceux décrit par $\color{green}{r_2}$.<br />
Notons que cet opérateur est associatif, c&rsquo;est-à-dire que pour toute
expression régulière $\color{green}{r_1}$, $\color{green}{r_2}$ et $\color{green}{r_3}$, on a
$\color{green}{(r_1r_2)r_3} = \color{green}{r_1(r_2r_3)}$ que l&rsquo;on notera simplement $\color{green}{r_1r_2r_3}$.</p>

<table>
<thead>
<tr>
<th align="center"><center>Expression</center></th>
<th align="center"><center>Ensemble de mots</center></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">$\color{green}{\epsilon1}$</td>
<td align="center">$\{1\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{10}$</td>
<td align="center">$\{10\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{(10)1}$</td>
<td align="center">$\{101\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{1(01)}$</td>
<td align="center">$\{101\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{101}$</td>
<td align="center">$\{101\}$</td>
</tr>
</tbody>
</table></li>

<li><p>L&rsquo;opérateur d&rsquo;union permet de faire l&rsquo;union des mots engendrés par deux expressions régulières. Soit $\color{green}{r_1}$ et $\color{green}{r_2}$ deux expressions régulières.
L&rsquo;union de ces deux expressions régulières est notée : $\color{green}{r_1 | \ r_2}$. L&rsquo;ensemble des mots décrit par cette expression régulière est
l&rsquo;union des mots décrit par $\color{green}{r_1}$ avec ceux décrit par $\color{green}{r_2}$.<br />
Notons que cet opérateur est commutatif, c&rsquo;est-à-dire que
$\color{green}{r_1\ |\ r_2} = \color{green}{r_2\ |\ r_1}$. Il est aussi associatif, c&rsquo;est-à-dire que pour toute
expression régulière $\color{green}{r_1}$, $\color{green}{r_2}$ et $\color{green}{r_3}$, on a
$\color{green}{(r_1\ |\ r_2)\ |\ r_3} = \color{green}{r_1\ |\ (r_2\ |\ r_3)}$ que l&rsquo;on notera simplement $\color{green}{r_1\ |\ r_2\ |\ r_3}$.</p>

<table>
<thead>
<tr>
<th align="center"><center>Expression</center></th>
<th align="center"><center>Ensemble de mots</center></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">$\color{green}{\epsilon \ | \ 1}$</td>
<td align="center">$\{\epsilon, 1\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{(00) \ | \ (10)}$</td>
<td align="center">$\{00, 10\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{(10) \ | \ (00)}$</td>
<td align="center">$\{00, 10\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{(0 \ | \ 1)\ |\ (10)}$</td>
<td align="center">$\{0, 1, 10\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{0\ |\ (1 \ | \ (10))}$</td>
<td align="center">$\{0, 1, 10\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{0 \ | \ 1\ |\ (10)}$</td>
<td align="center">$\{0, 1, 10\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{(0\ |\ 1)(0\ |\ 1)}$</td>
<td align="center">$\{00, 01, 10, 11\}$</td>
</tr>
</tbody>
</table></li>

<li><p>L&rsquo;opérateur d&rsquo;itération noté <code>*</code> permet de juxtaposer $0$ ou plusieurs fois les mots engendrés par une expression régulières. Soit $\color{green}{r}$ une expression régulière, alors
l&rsquo;expression régulière $\color{green}{r^*}$ représente l&rsquo;hypothétique<sup class="footnote-ref" id="fnref:Une-expression-r"><a href="#fn:Une-expression-r">2</a></sup> expression régulière
$\color{green}{\epsilon \ |\ r\ |\ rr\ |\ rrr\ |\ rrrr\ |\ \cdots}$.</p>

<table>
<thead>
<tr>
<th align="center"><center>Expression</center></th>
<th align="center"><center>Ensemble de mots</center></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">$\color{green}{0^*}$</td>
<td align="center">$\{\epsilon, 0, 00, 000, 0000, \cdots\}$</td>
</tr>

<tr>
<td align="center">$\color{green}{(0\ | \ 1)^*}$</td>
<td align="center">$\{\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \cdots\}$</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>

<p>{{% notice note %}}
Pour éviter trop de parenthèses, il existe une priorité entre les différents opérateurs : les parenthèses ont la plus grande priorité,
ensuite l&rsquo;opérateur $\color{green}{*}$, puis l&rsquo;opérateur de concaténation et enfin l&rsquo;opérateur $\color{green}{|}$. On a vu aussi ci-dessus que les opérateurs
de concaténation et d&rsquo;union sont associatifs, ce qui nous permet de supprimer d&rsquo;avantage de parenthèses.
Ainsi, l&rsquo;expression régulière $\color{green}{10^*1\ |\ 11\ |\ \epsilon}$ se lit $\color{green}{(((1(0^ *))1)\ |\ (11))\ |\ \epsilon}$
{{% /notice %}}</p>

<h3 id="examples">Examples</h3>

<p>Nous donnons ci-dessous quelques examples d&rsquo;expressions régulières toujours sur le vocabulaire $\mathcal{V} = \{0, 1\}$.</p>

<!--  <style> -->

<!-- table { -->

<!--     width:100%; -->

<!-- } -->

<!-- </style> -->

<table>
<thead>
<tr>
<th align="center"><center>Description</center></th>
<th align="center"><center>Expression</center></th>
<th align="center"><center>Ensemble de mots</center></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">Les nombres binaires (sans zéro non significatif)</td>
<td align="center">$\color{green}{0\ | \ 1(0\ | \ 1)^*}$</td>
<td align="center">$\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \cdots\}$</td>
</tr>

<tr>
<td align="center">Les nombres binaires impairs</td>
<td align="center">$\color{green}{1\ | \ 1(0\ | \ 1)^*1}$</td>
<td align="center">$\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \cdots\}$</td>
</tr>

<tr>
<td align="center">Les chaînes de bits ne contenant que des zeros et des uns alternés</td>
<td align="center">$\color{green}{10(10)^* \ | \ 01(01)^*}$</td>
<td align="center">$\{10, 01, 1010, 0101, 101010, 010101, \cdots\}$</td>
</tr>

<tr>
<td align="center">Les chaînes de bits dont la longueur est multiple de 3</td>
<td align="center">$\color{green}{((0\ | \ 1)(0\ | \ 1)(0\ | \ 1))^*}$</td>
<td align="center">$\{\epsilon, 000, 001, 010, 011, 100, \cdots, 111000, 111001, \cdots, 101011110, \cdots \}$</td>
</tr>

<tr>
<td align="center">Les chaînes de bits ne contenant pas la sous-chaîne $11$</td>
<td align="center">$\color{green}{0^* ( 100^* )^* (1\ | \ \epsilon)}$</td>
<td align="center">$\{\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \cdots\}$</td>
</tr>
</tbody>
</table>

<p>{{% notice info %}}
<a href="https://regexcrossword.com/">Vous pouvez vous amuser en utilisant les expressions régulières sur Regex Crossword <i class="far fa-smile-beam"></i>.</a>
{{% /notice %}}</p>

<p>{{&lt; youtube 5VNKh7aaZ-g &gt;}}</p>

<p>{{&lt; youtube Wl8FXqv6dak &gt;}}</p>

<h3 id="questions">Questions</h3>

<p>On utilisera la notation $\{a,b\}^*$ dans les questions ci-dessous : $\{a,b\}^*$ représente le langage engendré par l&rsquo;expression
régulière $\color{green}{(a\ |\ b)^*}$.</p>

<hr />

<p>{{%expand &ldquo;Soit l&rsquo;alphabet ${a, b}$. Donner une expression régulière permettant de décrire le langage : ${ w \in { a, b}^*\ |\ w$ contient les mots $aa$ ou $bb$ $}$.&rdquo; %}}</p>

<p>{{% /expand%}}</p>

<hr />

<p>{{%expand &ldquo;Cette question même si on pourrait penser qu&rsquo;elle ressemble beaucoup à la précédente n&rsquo;est pas facile. Vous pouvez revenir sur cette question après avoir vu la section suivante sur les automates. Soit l&rsquo;alphabet ${a, b}$. Donner une expression régulière permettant de décrire le langage : ${ w \in { a, b}^*\ |\ w$ ne contient pas les mots $aa$ ou $bb$ $}$.&rdquo; %}}</p>

<p>{{% /expand%}}</p>

<hr />

<p>On veut se déplacer dans la grille ci-dessous en utilisant les deux actions : &ldquo;aller à droite&rdquo; et &ldquo;aller en haut&rdquo;. On part du coin inférieur gauche et
on veut arriver au coin supérieur droit. Un chemin possible est indiqué dans la figure de droite.</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/scanner_question_grid3.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>{{%expand &ldquo;Écrire une expression régulière permettant de décrire toutes les actions permettant d&rsquo;aller du coin inférieur gauche au coin supérieur droit.&rdquo; %}}</p>

<p>On ne peut pas écrire succintement cette expression régulière sans utiliser des extensions. On va devoir énumérer les différentes configurations.
Le nombre de possibilités est le nombre de combinaisons de 3 éléments parmis 6 : ${{6}\choose{3}} = 20$. En effet, il faut 6 actions pour aller du départ jusqu&rsquo;à l&rsquo;arrivée.
Parmis ces 6 actions, 3 doivent aller vers la droite et 3 vers le haut. On va donc créer une expression régulière avec 20 parties. Nous utilisons <code>D</code> pour allez
à droite et <code>H</code> pour allez en haut.</p>

<p>$$
\scriptsize
\color{green}{HHHDDD\ |<br />
HHDHDD\ |<br />
HHDDHD\ |<br />
HHDDDH\ |<br />
HDHHDD\ |<br />
HDHDHD\ |<br />
HDHDDH\ |<br />
HDDHHD\ |<br />
HDDHDH\ |<br />
HDDDHH\ |<br />
DHHHDD\ |<br />
DHHDHD\ |<br />
DHHDDH\ |<br />
DHDHHD\ |<br />
DHDHDH\ |<br />
DHDDHH\ |<br />
DDHHHD\ |<br />
DDHHDH\ |<br />
DDHDHH\ |<br />
DDDHHH
}
$$</p>

<p>Nous avons généré les combinaisons ci-dessus grâce au programme suivant.</p>

<p>{{&lt; highlight cpp&gt;}}
#include <string>
#include <iostream></p>

<p>using namespace std;</p>

<p>const string HAUT = &ldquo;H&rdquo;;
const string DROITE = &ldquo;D&rdquo;;</p>

<p>void combos(int nH, int nD, string res)
{
    if (!nH &amp;&amp; !nD) {
        cout &lt;&lt; res &lt;&lt; &ldquo;\n&rdquo;;
        return;
    }
    if (nH) {
        combos(nH - 1, nD, res + HAUT);
    }
    if (nD) {
        combos(nH, nD - 1, res + DROITE);
    }
}</p>

<p>int main(int argc, char *argv[])
{
    combos(3, 3, &ldquo;&rdquo;);
}
{{&lt; /highlight &gt;}}</p>

<p>En utilisant les extensions des expressions régulières on peut obtenir la forme plus concise suivante.</p>

<p>{{&lt; highlight julia&gt;}}
^(?!(.<em>H.</em>){4}|(.<em>D.</em>){4})(H|D){6}$
{{&lt; /highlight&gt;}}</p>

<p>Dans cette expression, l&rsquo;opérateur <code>(?!(.*H.*){4}|(.*D.*){4})</code> exprime qu&rsquo;il ne faut pas réussir à trouver quatre <code>H</code> ou quatre <code>D</code> dans la suite de la ligne.
L&rsquo;expression <code>(H|D){6}</code> exprime qu&rsquo;il faut reconnaître six caractères parmis <code>H</code> et <code>D</code>. On exprime donc qu&rsquo;il faut reconnaître six caractères parmis <code>H</code> et <code>D</code>,
mais on ne doit pas trouver quatre <code>H</code> ou quatre <code>D</code>. On doit donc avoir exactement trois <code>H</code> et trois <code>D</code>.</p>

<p>{{% /expand%}}</p>

<hr />

<p>{{%expand &ldquo;Cette question n&rsquo;est pas facile. Vous pouvez revenir sur cette question après avoir vu la section suivante sur les automates. Soit l&rsquo;alphabet ${a, b}$. Donner une expression régulière permettant de décrire le langage : ${ w \in { a, b}^*\ |\ w$ contient un nombre pair de $a$ et un nombre impair de $b$ $}$.&rdquo; %}}</p>

<p>{{% /expand%}}</p>

<hr />

<p>{{%expand &ldquo;Soit l&rsquo;alphabet ${0, 1}$. Quel est le langage décrit par l&rsquo;expression régulière suivante : $\color{green}{0^*10^<em>10^</em>(10^*\ |\ \epsilon)}$ ?&rdquo; %}}
Le langage contenant deux ou trois <code>1</code>.
{{% /expand%}}</p>

<h2 id="automates">Automates</h2>

<p>Dans la section précédente nous avons présenté les expressions régulières qui permettent de décrire les langages dit réguliers.
Cette notation est pratique pour décrire les langages réguliers, et nous l&rsquo;utiliserons pour décrire les unités lexicales dans l&rsquo;analyseur lexical de MiniJava.
Par contre, pour la reconnaissance, c&rsquo;est-à-dire pour savoir si un mot donné appartient bien au langage décrit par une expression régulière, il n&rsquo;est pas facile
d&rsquo;utiliser directement une expression régulière.</p>

<p>Nous allons décrire maintenant les automates finis, non-déterministes et déterministes, qui permettent de répondre plus facilement à la question de savoir si un mot
donné appartient bien à un langage régulier donné. Nous nous servirons de ces automates dans la section suivante pour construire un logiciel permettant de tester
efficacement, si un mot donné appartient bien au langage engendré par une expression régulière donnée.</p>

<p>Notons que les langages décrits par les automates finis (non-déterministes ou déterministes) sont les langages réguliers, les expressions régulières et les automates
sont donc deux moyens équivalents permettant de décrire les mêmes langages.</p>

<h3 id="automates-finis-non-déterministes">Automates finis non-déterministes</h3>

<p>La figure suivante représente un automate fini non-déterministe, que nous appellerons $A_{fnd}$<sup class="footnote-ref" id="fnref:fnd-pour-fini-no"><a href="#fn:fnd-pour-fini-no">3</a></sup>, qui décrit les commentaires en C de type <code>/*...*/</code>. On suppose, pour simplifier, que notre vocabulaire
est $\mathcal{V} = \{ a, b, /, * \}$.
Sur cette figure on peut voir les éléments suivants :</p>

<ul>
<li><p>Des <span style="color:green"><strong>états</strong></span>, les cercles sur la figure, numérotés de <code>0</code> à <code>7</code> pour cet exemple.
On peut y voir l&rsquo;<span style="color:green"><strong>état de départ</strong></span> (ou état initial), l&rsquo;état <code>0</code>, qui possède une flèche qui arrive sur lui,
mais qui ne part d&rsquo;aucun autre état. L&rsquo;état <code>7</code> est un <span style="color:green"><strong>état d&rsquo;acceptation</strong></span> (ou état final), il est représenté par un double cercle.</p></li>

<li><p>Des <span style="color:green"><strong>transitions</strong></span> entre états, les flèches sur la figure. Sur les transitions il y a des symboles
appartenant au vocabulaire $\mathcal{V}$ ou bien le symbole $\epsilon$. Notons que sur certaines transitions, par exemple la transition entre l&rsquo;état <code>3</code> et
l&rsquo;état <code>2</code>, nous avons mis plusieurs symboles sur la transition (sur cette transition il y a les deux symboles <code>a</code> et  <code>b</code>).
Formellement, nous aurions dû écrire deux transitions au lieu d&rsquo;une, avec chacune un des deux symboles, mais faire comme nous l&rsquo;avons fait permet d&rsquo;écrire plus succinctement l&rsquo;automate.</p></li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>L&rsquo;automate va nous permettre de savoir si un mot <code>m</code> construit à partir du vocabulaire $\mathcal{V}$ appartient au langage décrit par l&rsquo;automate (on note ce langage $\mathcal{L}(A_{fnd})$).</p>

<h4 id="test-de-l-appartenance-d-un-mot-au-langage-décrit-par-l-automate">Test de l&rsquo;appartenance d&rsquo;un mot au langage décrit par l&rsquo;automate</h4>

<p>Soit <code>/*/*/</code> un mot, que nous appellerons <code>m</code>, appartenant à $\mathcal{V}^*$.
Comment savoir si ce mot est décrit par l&rsquo;automate $A_{fnd}$ ?</p>

<p>On va partir de l&rsquo;état initial, l&rsquo;état <code>0</code>, et on va suivre les transitions,
caractères après caractères, en cherchant un chemin qui nous mène vers l&rsquo;état d&rsquo;acceptation <code>7</code> après avoir lu tous les caractères du mot <code>m</code>.</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments1.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>À Partir de l&rsquo;état <code>0</code>, il n&rsquo;y a qu&rsquo;une seule transition, il n&rsquo;y a donc pas le choix. Le mot doit donc forcément commencer par <code>/</code>, car c&rsquo;est le symbole sur cette transition.
Une fois cette transition passée, on se trouve dans l&rsquo;état <code>1</code> et il nous reste à analyser la partie <code>*/*/</code> de <code>m</code>.</li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments2.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>À Partir de l&rsquo;état <code>1</code>, il n&rsquo;y a aussi qu&rsquo;une seule transition possible. On doit donc forcément avoir le symbole <code>*</code> dans ce qu&rsquo;il nous reste à analyser <code>*/*/</code>,
car c&rsquo;est le symbole sur la seule transition partant de l&rsquo;état <code>1</code>.
Une fois cette transition passée, on se trouve dans l&rsquo;état <code>2</code> et il nous reste à analyser la partie <code>/*/</code> de <code>m</code>.</li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments3.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>L&rsquo;état <code>2</code> possède trois transitions sortantes. Elles sont toutes les trois labelées avec le symbole $\epsilon$. Ce symbole signifie que l&rsquo;on ne modifie pas l&rsquo;entrée lorsque
l&rsquo;on passe par une telle transition. On peut voir maintenant pourquoi l&rsquo;automate est non déterministe car sur le même symbole, ici $\epsilon$, on a le choix entre plusieurs transitions.
Comment faire pour s&rsquo;orienter ? On va supposer pour le moment que l&rsquo;on a des dons de clairvoyance et que l&rsquo;on va choisir la bonne transition, qui est celle vers l&rsquo;état <code>4</code>. On verra dans
les vidéos comment automatiser cela.</li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments4.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>Dans l&rsquo;état <code>4</code> nous avons encore le choix entre deux transitions : ne pas consommer un caractère de l&rsquo;entrée en prenant la transition $\epsilon$, ou consommer le caractère <code>/</code>
en bouclant sur l&rsquo;état <code>4</code>. Comme nous sommes devin, nous allons boucler sur l&rsquo;état <code>4</code> et consommer le <code>/</code>.</li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments5.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>Maintenant, l&rsquo;entrée qu&rsquo;il nous reste à consommer est <code>*/</code>. Nous allons prendre la transition $\epsilon$ jusqu&rsquo;à l&rsquo;état <code>2</code>, puis la transition $\epsilon$ de l&rsquo;état <code>2</code> vers l&rsquo;état <code>3</code>. Encore
une fois on ne se préoccupe pas pour l&rsquo;instant du comment faire les bons choix de transitions lorsqu&rsquo;il y a plus d&rsquo;une possibilité. Nous nous retrouvons dans la configuration ci-dessous, où le curseur sous la chaîne
d&rsquo;entrée n&rsquo;a pas bougé.</li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments6.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>Dans l&rsquo;état <code>5</code>, nous n&rsquo;avons qu&rsquo;une transition sortante sur le caractère <code>*</code>. Le curseur sur l&rsquo;entrée est placé sur le <code>*</code>, on peut donc
prendre cette transition et déplacer le curseur vers la droite. Il nous reste maintenant simplement à reconnaître le <code>/</code>.</li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments7.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>Dans l&rsquo;état <code>6</code>, il n&rsquo;y a là aussi qu&rsquo;une seule transition sur le symbole <code>/</code>. Comme le curseur sur l&rsquo;entrée pointe sur un caractère <code>/</code>, on peut prendre cette transition et se placer
sur l&rsquo;état final <code>7</code>.</li>
</ul>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_comments8.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<ul>
<li>Comme la chaîne d&rsquo;entrée est maintenant vide et que nous sommes dans un état d&rsquo;acceptation, on peut conclure que le mot <code>/*/*/</code> appartient bien au langage $\mathcal{L}(A_{fnd})$.
Le mot <code>/*/*/</code> est donc bien un commentaire.</li>
</ul>

<p>La chaîne d&rsquo;entrée <code>/*/*/</code> est acceptée par notre automate, mais comment sait-on si une chaîne n&rsquo;est pas dans le langage $\mathcal{L}(A_{fnd})$, autrement dit
comment sait-on si le mot n&rsquo;est pas accepté ?
Pour un automate non déterministe, il faut montrer qu&rsquo;après avoir lu tous les caractères de la chaîne d&rsquo;entrée, on ne peut pas être dans un état d&rsquo;acceptation.
Nous allons détailler dans la vidéo suivante comment détecter si un mot appartient ou non au langage engendré par un automate fini non déterministe.</p>

<p>{{% notice note %}}
Il nous semble plus aisé de construire l&rsquo;automate fini non déterministe que nous venons de voir pour décrire le langage des commentaires que l&rsquo;expression régulière
<em>$/*\color{darkgreen}{(}*^{\color{darkgreen}{+}}\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}\ \color{darkgreen}{|}\ \color{darkgreen}{(}a\ |\ b\ |\ /\color{darkgreen}{)}\color{darkgreen}{)}^{\color{darkgreen}{*}}*^{\color{darkgreen}{+}}/$</em> que nous avions vu dans la section <a href="#regular_expressions">précedente</a>.
Après, vous êtes peut-être des gourous de <a href="https://fr.wikipedia.org/wiki/Perl_(langage)">Perl</a><sup class="footnote-ref" id="fnref:Perl-signifie-Pr"><a href="#fn:Perl-signifie-Pr">4</a></sup>
et c&rsquo;est juste trop facile pour vous <i class="far fa-smile-beam"></i>.
{{% /notice %}}</p>

<!-- {{< https://youtu.be/rZGSM0vvz58 >}} -->

<h4 id="questions-1">Questions</h4>

<p>{{%expand &ldquo;Soit l&rsquo;alphabet ${a, b}$. Construire un automate qui reconnait le langage : ${ w \in { a, b}^*\ |\ w$ contient le mot $aba$ $}$. Par example, $aba$ est dans le langage, ainsi que $bbbbbaabaaaabb$, mais pas $babbbaaa$.&rdquo; %}}
 {{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_question1.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>Notons que cet automate calque vraiment l&rsquo;expression régulière $\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{*}}aba\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{*}}$.
{{% /expand%}}</p>

<p>{{%expand &ldquo;Soit l&rsquo;alphabet ${a, b}$. Construire un automate qui reconnait le langage : ${ w \in { a, b}^*\ |\ w$ ne contient pas le mot $aba$ sauf s&rsquo;il est précédé par le mot $bbb$ $}$. Par exemple, $aaabbbaabaa$ est dans le langage, $abba$ aussi, mais pas $bbababbb$.&rdquo; %}}
{{&lt; figure src=&ldquo;/images/minijava/scanner/nfa_question2.svg&rdquo; width=&ldquo;600px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p><a name="nfa_question2_states"></a>
La partie haute de l&rsquo;automate, les états <code>1</code>, <code>2</code>, <code>3</code> et <code>4</code>, permet de reconnaître une suite de trois <code>b</code> suivie de n&rsquo;importe quoi. La partie basse s&rsquo;occupe de reconnaître tout sauf <code>aba</code>.
L&rsquo;état <code>5</code> indique que l&rsquo;on a pas encore vu de <code>a</code> ou bien que l&rsquo;on vient de rencontrer une séquence se terminant par <code>bb</code> (on est donc sûr de ne pas avoir vu une séquence se terminant par <code>ab</code>).
L&rsquo;état <code>6</code> indique qu&rsquo;on est en train d&rsquo;analyser une suite d&rsquo;au moins un <code>a</code>
et l&rsquo;état <code>7</code> qu&rsquo;on vient de voir <code>ab</code>, donc qu&rsquo;on ne doit pas avoir un <code>a</code> maintenant). À partir des états <code>5</code>, <code>6</code> et <code>7</code> on peut rejoindre la partie haute de l&rsquo;automate car on vient d&rsquo;analyser un préfixe correcte et on peut vouloir ajouter <code>aba</code> dans la suite (en ajoutant <code>bbb</code> avant).</p>

<p>Comment être sûr que la partie basse reconnaît bien tout sauf <code>aba</code> ? Pour la partie haute, il est assez facile de se convaincre qu&rsquo;elle reconnaît bien $bbb\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{*}}$.
Mais ce n&rsquo;est pas si évident de se convaincre que la partie basse décrit bien tout sauf la chaîne <code>aba</code>. Quand on veut vraiment être sûr, il n&rsquo;y a qu&rsquo;un moyen,
c&rsquo;est faire une preuve !<sup class="footnote-ref" id="fnref:Vous-me-direz-qu"><a href="#fn:Vous-me-direz-qu">5</a></sup></p>

<p>On va faire une preuve par récurrence sur la longueur de la chaîne. Pour une chaîne de longueur 0 ($\epsilon$) de longueur 1 ($a$ et $b$) et de longueur 2 ($aa$, $ab$, $ba$ et $bb$), on peut suivre les transitions
à partir de l&rsquo;état 0 vers la partie basse et voir qu&rsquo;on les reconnaît toutes et elles n&rsquo;ont pas <code>aba</code> dedans (car la longueur de la chaîne est inférieure ou égale à 2). Supposons
que la propriété est vraie pour les chaînes de longueur $n \ge 2$, est-ce vraie pour les chaînes de longueur $n + 1$ ? Regardons les deux derniers caractères de la chaîne <code>m</code> de longueur $n$.</p>

<ul>
<li><p><code>m</code> se termine par <code>aa</code>. Dans ce cas on doit forcément se trouver dans l&rsquo;état <code>6</code> <a href="#nfa_question2_states">comme indiqué ci-dessus</a>. On peut ajouter un <code>a</code> et accepter
la nouvelle chaîne <code>ma</code> car on reste dans l&rsquo;état <code>6</code> qui est un état d&rsquo;acceptation, et on peut aussi ajouter un <code>b</code> et accepter la chaîne <code>mb</code> car on se retrouve dans l&rsquo;état <code>7</code> qui est aussi
un état d&rsquo;acceptation.</p></li>

<li><p><code>m</code> se termine par <code>ab</code>. Dans ce cas on doit forcément se trouver dans l&rsquo;état <code>7</code> <a href="#nfa_question2_states">comme indiqué ci-dessus</a>. On ne peut pas ajouter de <code>a</code> car il n&rsquo;y a aucune
transition sur un <code>a</code> à partir de l&rsquo;état <code>7</code> et donc on ne reconnaîtra pas une chaîne contenant <code>aba</code>. On peut par contre ajouter un <code>b</code> et bien reconnaître la chaîne de longueur $n+1$ <code>mb</code>.</p></li>

<li><p><code>m</code> se termine par <code>ba</code>. Dans ce cas on doit forcément se trouver dans l&rsquo;état <code>6</code> <a href="#nfa_question2_states">comme indiqué ci-dessus</a> et on peut ajouter un <code>a</code> ou bien un <code>b</code> pour obtenir la
chaîne de longueur $n+1$ <code>ma</code> ou <code>mb</code>.</p></li>

<li><p><code>m</code> se termine par <code>bb</code>. Dans ce cas on doit forcément se trouver dans l&rsquo;état <code>5</code> <a href="#nfa_question2_states">comme indiqué ci-dessus</a> et on peut ajouter un <code>a</code> ou bien un <code>b</code> pour obtenir la
chaîne de longueur $n+1$ <code>ma</code> ou <code>mb</code>.</p></li>
</ul>

<p>En supposant donc qu&rsquo;on peut générer tous les mots de longueur $n$ ne contenant pas <code>aba</code>, on vient de montrer qu&rsquo;on peut générer tous les mots de longueur $n+1$ ne contenant pas <code>aba</code>.</p>

<p>{{% /expand%}}</p>

<h3 id="automates-finis-déterministes">Automates finis déterministes</h3>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/dfa_comments.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<h3 id="passage-d-un-automate-à-une-expression-régulière">Passage d&rsquo;un automate à une expression régulière</h3>

<p>Nous allons décrire plus en détail les liens entre expressions régulières et automates dans les vidéos ci-dessous, mais nous
pouvons retrouver l&rsquo;expression régulière permettant de décrire les commentaires en C automatiquement à partir d&rsquo;un automate fini (déterministe ou non-déterministe).
Nous montrons ci-dessous une suite de transformations permettant de passer de l&rsquo;automate fini déterministe vu plus haut vers une expression régulière équivalente.
On peut voir sur les transitions apparaître des expressions régulières au fur et à mesure des transformations. Pour ne pas confondre le caractère <code>*</code> avec l&rsquo;opérateur
<span style="color:green">*</span>, nous avons écrit l&rsquo;opérateur en vert.</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/automata_to_regex1.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/automata_to_regex2.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/automata_to_regex3.svg&rdquo; width=&ldquo;300px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/dfa_comments.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/dfa_comments_to_regex1.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/dfa_comments_to_regex2.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<p>{{&lt; figure src=&ldquo;/images/minijava/scanner/dfa_comments_to_regex3.svg&rdquo; width=&ldquo;800px&rdquo; height=&ldquo;auto&rdquo;&gt;}}</p>

<h2 id="identification-de-motifs">Identification de motifs</h2>

<h2 id="analyseur-lexical-avec-ocamllex">Analyseur lexical avec ocamllex</h2>

<h2 id="ressources">Ressources</h2>

<p>{{% notice info %}}
<a href="https://regexcrossword.com/">Jouer avec les expressions régulières</a><br />
<a href="https://regex101.com/">Tester des expressions régulières</a><br />
{{% /notice %}}</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:Le-mot-vide-est">Le mot vide est l&rsquo;équivalent de la chaîne de caractères <code>&quot;&quot;</code>. <a class="footnote-return" href="#fnref:Le-mot-vide-est"><sup>[return]</sup></a></li>
<li id="fn:Une-expression-r">Une expression régulière doit être de taille finie. <a class="footnote-return" href="#fnref:Une-expression-r"><sup>[return]</sup></a></li>
<li id="fn:fnd-pour-fini-no"><code>fnd</code> pour <em>fini non déterministe</em>. <a class="footnote-return" href="#fnref:fnd-pour-fini-no"><sup>[return]</sup></a></li>
<li id="fn:Perl-signifie-Pr"><code>Perl</code> signifie <em>Practical Extraction and Report Language</em>, ou <em>Pathologically Eclectic Rubbish Lister</em> <i class="far fa-smile-wink"></i>. <a class="footnote-return" href="#fnref:Perl-signifie-Pr"><sup>[return]</sup></a></li>
<li id="fn:Vous-me-direz-qu">Vous me direz qu&rsquo;il faut encore qu&rsquo;elle soit correcte. C&rsquo;est pas faux <i class="far fa-smile-beam"></i>, mais dans une preuve il faut juste se convaincre que chaque étape élémentaire est correcte. <a class="footnote-return" href="#fnref:Vous-me-direz-qu"><sup>[return]</sup></a></li>
</ol>
</div>


<footer class=" footline" >
	
</footer>


        
        </div> 
        

      </div>

    <div id="navigation">
        
        
        
        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
            
        
                    
            
        
        
        


	 
	 
		
			<a class="nav nav-prev" href="/fr/compiler/minijava/introduction/" title="Introduction"> <i class="fa fa-chevron-left"></i></a>
		
		
			<a class="nav nav-next" href="/fr/compiler/minijava/introduction/" title="Introduction" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
		
	
    </div>

    </section>
    
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="/js/clipboard.min.js?1574358075"></script>
    <script src="/js/perfect-scrollbar.min.js?1574358075"></script>
    <script src="/js/perfect-scrollbar.jquery.min.js?1574358075"></script>
    <script src="/js/jquery.sticky.js?1574358075"></script>
    <script src="/js/featherlight.min.js?1574358075"></script>
    <script src="/js/html5shiv-printshiv.min.js?1574358075"></script>
    <script src="/js/highlight.pack.js?1574358075"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/js/modernizr.custom-3.6.0.js?1574358075"></script>
    <script src="/js/learn.js?1574358075"></script>
    <script src="/js/hugo-learn.js?1574358075"></script>

    <link href="/mermaid/mermaid.css?1574358075" rel="stylesheet" />
    <script src="/mermaid/mermaid.js?1574358075"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
    

  </body>
</html>

