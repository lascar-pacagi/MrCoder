[
{
	"uri": "http://localhost:1313/MrCoder/en/compiler/minijava/",
	"title": "MiniJava",
	"tags": ["compiler", "transpiler", "garbage collector", "object oriented language", "MiniJava", "C", "OCaml", "Menhir", "Bash"],
	"description": "",
	"content": "MiniJava The compiler we study in this part is a transpiler that goes from the MiniJava language to the C language. We will construct this transpiler using the OCaml language and Menhir for the syntactic analysis.\nTo download the code : git clone --recurse-submodules https://github.com/lascar-pacagi/MiniJava.git.\n"
},
{
	"uri": "http://localhost:1313/MrCoder/en/compiler/minijava/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "We will build a transpiler, or source to source compiler, for a subset of Java, the MiniJava language. The input representation for our compiler is the MiniJava language and the output representation is the C language.\nA sample program which computes the factorial of a given number is given below.\nclass Factorial { public static void main(String[] a) { System.out.println(new Fac().computeFac(10)); } } class Fac { public int computeFac(int num) { int numAux; if (num \u0026lt; 1) numAux = 1; else numAux = num * (this.computeFac(num-1)); return numAux; } } As Minijava is a subset of Java, we will be able to compile our MiniJava programs using the Java compiler javac. This will be very usefull to test the validity of our translations in C. Indeed, we will be able to compare the output of the program compiled with the Java compiler with the output of the program obtained by our transpiler.\nOverview of the Transpiler We will use the following MiniJava program as a running example for this section. class Print42 { public static void main(String[] a) { System.out.println(35 + 2 * 3 + 1); } }\nThe following figure shows the main steps to transform a MiniJava program to a transpiled C source file.\ngraph LR; A[MiniJava source file] --\u003e|characters| B(fa:fa-tools Lexical analysis) B --\u003e|tokens| C(fa:fa-tools Syntactic analysis) C --\u003e|abstract syntax tree| D(fa:fa-tools Typechecker) D --\u003e|abstract syntax tree| E(fa:fa-tools C code generator) E --\u003e|characters| F[C source file] We will now describe the different steps shown on the figure above.\\\nTo follow along with the videos that follow, start to install the dependencies as stated here. Then download the code\ngit clone --recurse-submodules https://github.com/lascar-pacagi/MiniJava.git cd MiniJava git checkout v1.0 make The master branch is the version with a garbage collector and the tag v1.0 is a version without a garbage collector. If you want to modify the version 1.0, you can create a new branch (from_v1.0 for example)\ngit checkout -b from_v1.0 v1.0 The code we use during the videos is given below.\nAttachments demo_code.tgz (3 ko) Lexical Analysis The first step is the lexical analysis. This phase will group characters into words. Those words are called tokens. After this step we get a more structured information where the keywords of MiniJava, the identifiers, the integer constants and the boolean constants have been recognized. This is in this phase that commentaries and whitespaces are suppressed.\nFor the program given above, the scanner, the program responsible of the lexical analysis phase, will produce the following stream of tokens. For example, we can see that the keyword CLASS has been recognized, as the integer constant INT_CONST 35.\nCLASS IDENT ‘Print42‘ LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET IDENT ‘a‘ RPAREN LBRACE SYSO LPAREN INT_CONST ‘35‘ PLUS INT_CONST ‘2‘ TIMES INT_CONST ‘3‘ PLUS INT_CONST ‘1‘ RPAREN SEMICOLON RBRACE RBRACE EOF In the following video, we give an overview of the transpiler and we present the lexical analyzer.\nSyntactic Analysis The second step, the syntactic analysis, takes as input the stream of tokens and produces an abstract syntax tree which represents the structure of the program with a tree data structure.\nFor the program given above, the parser, the program responsible of the syntactic analysis phase, will produce the following tree. We can see the arithmetic expression with the operators precedence explicitly stated (expressions deeper in the tree have more priority).\nprogram ├name Print42 ├main_args a └main └ISyso └EBinOp OpAdd ├EBinOp OpAdd │ ├EConst (ConstInt 35) │ └EBinOp OpMul │ ├EConst (ConstInt 2) │ └EConst (ConstInt 3) └EConst (ConstInt 1) The syntactic analyser needs to know the structure of a MiniJava program. This structure is given in the form of a grammar. The MiniJava grammar, in its EBNF form is given below. Another version, certainly easier to read for us, using syntax diagrams is given here.^[The description of the grammar used to generate the diagram does not follow exactly the EBNF form. Details are given here.]\nProgram = MainClass { ClassDeclaration } \u0026#39;eof\u0026#39; ; MainClass = \u0026#39;class\u0026#39; Identifier \u0026#39;{\u0026#39; \u0026#39;public\u0026#39; \u0026#39;static\u0026#39; \u0026#39;void\u0026#39; \u0026#39;main\u0026#39; \u0026#39;(\u0026#39; \u0026#39;String\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; Identifier \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; Statement \u0026#39;}\u0026#39; \u0026#39;}\u0026#39; ; ClassDeclaration = \u0026#39;class\u0026#39; Identifier [ \u0026#39;extends\u0026#39; Identifier ] \u0026#39;{\u0026#39; { VarDeclaration } { MethodDeclaration } \u0026#39;}\u0026#39; ; VarDeclaration = Type Identifier \u0026#39;;\u0026#39; ; MethodDeclaration = \u0026#39;public\u0026#39; Type Identifier \u0026#39;(\u0026#39; [ Type Identifier { \u0026#39;,\u0026#39; Type Identifier } ] \u0026#39;)\u0026#39; \u0026#39;{\u0026#39; { VarDeclaration } { Statement } \u0026#39;return\u0026#39; Expression \u0026#39;;\u0026#39; \u0026#39;}\u0026#39; ; Type = \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; \u0026#39;]\u0026#39; | \u0026#39;boolean\u0026#39; | \u0026#39;int\u0026#39; | Identifier ; Statement = \u0026#39;{\u0026#39; { Statement } \u0026#39;}\u0026#39; | \u0026#39;if\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement \u0026#39;else\u0026#39; Statement | \u0026#39;while\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; Statement | \u0026#39;System.out.println\u0026#39; \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; \u0026#39;;\u0026#39; | Identifier \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; | Identifier \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; \u0026#39;=\u0026#39; Expression \u0026#39;;\u0026#39; ; Expression = Expression ( \u0026#39;\u0026amp;\u0026amp;\u0026#39; | \u0026#39;\u0026lt;\u0026#39; | \u0026#39;+\u0026#39; | \u0026#39;-\u0026#39; | \u0026#39;*\u0026#39; ) Expression | Expression \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | Expression \u0026#39;.\u0026#39; \u0026#39;length\u0026#39; | Expression \u0026#39;.\u0026#39; Identifier \u0026#39;(\u0026#39; [Expression {\u0026#39;,\u0026#39; Expression}] \u0026#39;)\u0026#39; | Integer | \u0026#39;true\u0026#39; | \u0026#39;false\u0026#39; | Identifier | \u0026#39;this\u0026#39; | \u0026#39;new\u0026#39; \u0026#39;int\u0026#39; \u0026#39;[\u0026#39; Expression \u0026#39;]\u0026#39; | \u0026#39;new\u0026#39; Identifier \u0026#39;(\u0026#39; \u0026#39;)\u0026#39; | \u0026#39;!\u0026#39; Expression | \u0026#39;(\u0026#39; Expression \u0026#39;)\u0026#39; ; Letter = \u0026#39;A\u0026#39; | \u0026#39;B\u0026#39; | \u0026#39;C\u0026#39; | \u0026#39;D\u0026#39; | \u0026#39;E\u0026#39; | \u0026#39;F\u0026#39; | \u0026#39;G\u0026#39; | \u0026#39;H\u0026#39; | \u0026#39;I\u0026#39; | \u0026#39;J\u0026#39; | \u0026#39;K\u0026#39; | \u0026#39;L\u0026#39; | \u0026#39;M\u0026#39; | \u0026#39;N\u0026#39; | \u0026#39;O\u0026#39; | \u0026#39;P\u0026#39; | \u0026#39;Q\u0026#39; | \u0026#39;R\u0026#39; | \u0026#39;S\u0026#39; | \u0026#39;T\u0026#39; | \u0026#39;U\u0026#39; | \u0026#39;V\u0026#39; | \u0026#39;W\u0026#39; | \u0026#39;X\u0026#39; | \u0026#39;Y\u0026#39; | \u0026#39;Z\u0026#39; | \u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39; | \u0026#39;d\u0026#39; | \u0026#39;e\u0026#39; | \u0026#39;f\u0026#39; | \u0026#39;g\u0026#39; | \u0026#39;h\u0026#39; | \u0026#39;i\u0026#39; | \u0026#39;j\u0026#39; | \u0026#39;k\u0026#39; | \u0026#39;l\u0026#39; | \u0026#39;m\u0026#39; | \u0026#39;n\u0026#39; | \u0026#39;o\u0026#39; | \u0026#39;p\u0026#39; | \u0026#39;q\u0026#39; | \u0026#39;r\u0026#39; | \u0026#39;s\u0026#39; | \u0026#39;t\u0026#39; | \u0026#39;u\u0026#39; | \u0026#39;v\u0026#39; | \u0026#39;w\u0026#39; | \u0026#39;x\u0026#39; | \u0026#39;y\u0026#39; | \u0026#39;z\u0026#39; ; Digit = \u0026#39;0\u0026#39; | \u0026#39;1\u0026#39; | \u0026#39;2\u0026#39; | \u0026#39;3\u0026#39; | \u0026#39;4\u0026#39; | \u0026#39;5\u0026#39; | \u0026#39;6\u0026#39; | \u0026#39;7\u0026#39; | \u0026#39;8\u0026#39; | \u0026#39;9\u0026#39; ; Integer = Digit { Digit } ; Character = Letter | Digit | \u0026#39;_\u0026#39; ; Identifier = Letter { Letter | Digit | \u0026#39;_\u0026#39; } ; The following video presents the syntactic analyzer of MiniJava.\nTypechecker The third step, the typechecker, takes as input the abstract syntax tree and will check if the types are correct. For example, the typechecker will check if we call a method with the correct number of arguments, that the operators + and * are used with integer operands, that a class is compatible with another one using the class hierarchy, \u0026hellip;\nThe following video presents an overview of the MiniJava typechecker.\nCode Generation The last step is the code generator phase. We will again visit the abstract syntax tree to generate C code. For our running example, we get the following C source file.\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { printf(\u0026#34;%d\\n\u0026#34;, ((35 + (2 * 3)) + 1)); return 0; } The following video briefly describes the C code generation in MiniJava.\nSemantic of a MiniJava Program The semantic of a MiniJava program is given by its semantic as a Java program^[See here for the semantic of the Java language.]. The main restrictions are\nNo class has Object as a superclass. No super keyword. Only a default constructor. The only types available are int. boolean. int[]. User defined classes. No overloading. All methods return a value. The return statement is at the end. System.out.println() only prints integers. No interfaces, no exceptions, no generic types, no lambdas. We explain in the following video the main differences between Java and MiniJava.\nWe described briefly in the video the default initialization mechanism in Java (and MiniJava). We give further details below. You can look here for all the details.\nLet\u0026rsquo;s consider the following Java program Init.java.\n1class Init { 2 public static void main(String[] args) { 3 int i; 4 boolean b; 5 int[] a; 6 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 7 } 8} When we compile it, we get the following error messages.\n$ javac Init.java Init.java:6: error: variable i might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable b might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ Init.java:6: error: variable a might not have been initialized System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); ^ 3 errors Indeed, the three variables i, b and a are put on the stack when main is called. Java does not initialize local variables, and their values are whatever was currently in those locations on the stack. The compiler rejects this program because of the arbitrary values that go into those variables, by telling us that those variables have not been initialized.\nOn the other hand, the following program is correct, because attributes have a default value.\n1class Init { 2 public static void main(String[] args) { 3 new Default().print(); 4 } 5} 6 7class Default { 8 private int i; 9 private boolean b; 10 private int[] a; 11 12 public void print() { 13 System.out.println(i + \u0026#34; \u0026#34; + b + \u0026#34; \u0026#34; + a); 14 } 15} And we get the following output.\n$ javac Init.java $ java Init 0 false null Review of Java\u0026rsquo;s Dynamic Binding We will review dynamic binding in Java in the following video, because the management of dynamic binding will be a difficult point to handle in our transpiler.\nQuestions Let\u0026rsquo;s have a look again at the MiniJava grammar. We would like to add to the language\nThe == operator. Constructors. private methods and constructors. How to update the grammar to add those new elements? MiniJava grammar updated.\nIn the previous question, what terminals did you add to the grammar (a terminal in the grammar will become a token for the scanner)? == and private.\nConsider the following Java program.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6} 7 8class B extends A { 9 public boolean m1(int n) { 10 System.out.println(\u0026#34;boolean B:m1(int n)\u0026#34;); 11 return false; 12 } 13} Does this code compile? This code doesn\u0026rsquo;t compile. Indeed, on line 9, the m1 method overrides the m1 method of line 2: It has the same name and the same parameters. But to correctly overrides the m1 method of line 2, the return type must be compatible, and boolean is not compatible with int.\nConsider the following Java program.\n1class A { 2 public int m1(int n) { 3 System.out.println(\u0026#34;int A:m1(int n)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(int n) { 7 System.out.println(\u0026#34;boolean A:m1(int n)\u0026#34;); 8 return false; 9 } 10} Does this code compile? This code doesn\u0026rsquo;t compile. Indeed, the return type is not used to differentiate methods. Therefore, even if the methods on lines 2 and 6 have different return types, because they have the same name and the same parameters, this is not overloading and so we have an error.\nConsider the following Java program.\n1class A { 2 public int m1(A a) { 3 System.out.println(\u0026#34;int A:m1(A a)\u0026#34;); 4 return 0; 5 } 6 public boolean m1(B b) { 7 System.out.println(\u0026#34;boolean A:m1(B b)\u0026#34;); 8 return false; 9 } 10} 11 12class B extends A { 13} Does this code compile? This code compiles. This time, the method on line 6 overloads the method on line 2 because the parameter is of a different type.\nRessources Java language course from Princeton\nJava language course from Microsoft\nJava language specifications\nMiniJava page\nMiniJava syntactic diagram\nC language course part 1\nC language course part 2\nC language course part 3\nC language course part 4\nLearn C by building a Lisp\nmodern C\nC language specifications (C11 norm)\n"
},
{
	"uri": "http://localhost:1313/MrCoder/en/compiler/minijava/scanner/",
	"title": "Lexical Analysis",
	"tags": [],
	"description": "",
	"content": " graph LR; A[MiniJava source file] --\u003e|characters| B(fa:fa-tools Lexical analysis) B --\u003e|tokens| C(fa:fa-tools Syntactic analysis) C --\u003e|abstract syntax tree| D(fa:fa-tools Typechecker) D --\u003e|abstract syntax tree| E(fa:fa-tools C code generator) E --\u003e|characters| F[C source file] classDef green fill:#74B559,stroke:#222723,stroke-width:5px; class B green We will describe the MiniJava lexical analyzer, also called scanner, which will group the characters of the source file into lexical units also called tokens. These lexical units will then be given to the syntactic analyzer in the following phase of the transpiler.\nBefore describing the lexical analyzer of MiniJava, we will present regular expressions that will be used to describe tokens. We will also study automata, a kind of graph, and use them to match regular expressions. Regular Expressions Regular expressions will allow us to describe succinctly and quite intuitively the MiniJava lexical units and will be used in the ocamllex lexical analyzer generator that we will be using in our transpiler.\nA regular expression describes a set of words from a given vocabulary. We will take as an example the vocabulary $\\mathcal{V} = \\{0, 1\\}$ consisting simply of two elements: 0 and 1. We describe below the basic elements and operators for creating regular expressions and the words that they describe.\nBasic regular expressions:\nThe regular expression $\\color{green}\\epsilon$ generates the set containing only the empty word1: $\\{\\epsilon\\}$.\nFor $c \\in \\mathcal{V}$, the regular expression $\\color{green}c$ represents the set containing a single word: $\\{c\\}$.\nExpression Set of words $\\color{green}0$ $\\{0\\}$ $\\color{green}1$ $\\{1\\}$ Compound regular expressions:\nParentheses can be used to group together regular expressions. Let $\\color{green}{r}$ be a regular expression, then $\\color{green}{(r)}$ represents the same set of words as the expression $\\color{\\green}{r}$.\nExpression Set of words $\\color{green}{(0)}$ $\\{0\\}$ The concatenation operator allows to juxtapose the words generated by two regular expressions. Let $\\color{green}{r_1}$ and $\\color{green}{r_2}$ be two regular expressions. The concatenation of these two regular expressions is noted: $\\color{green}{r_1r_2}$. The set of words described by this regular expression is the concatenation of the words described by $\\color{green}{r_1}$ with those described by $\\color{green}{r_2}$.\nNote that this operator is associative, which means that for any regular expression $\\color{green}{r_1}$, $\\color{green}{r_2}$ and $\\color{green}{r_3}$, we have $\\color{green}{(r_1r_2)r_3} = \\color{green}{r_1(r_2r_3)}$ that we will simply write down as $\\color{green}{r_1r_2r_3}$. Expression Set of words $\\color{green}{\\epsilon1}$ $\\{1\\}$ $\\color{green}{10}$ $\\{10\\}$ $\\color{green}{(10)1}$ $\\{101\\}$ $\\color{green}{1(01)}$ $\\{101\\}$ $\\color{green}{101}$ $\\{101\\}$ The union operator is used to get the union of the words generated by two regular expressions. Let $\\color{green}{r_1}$ and $\\color{green}{r_2}$ be two regular expressions. The union of these two regular expressions is noted: $\\color{green}{r_1\\ |\\ r_2}$. The set of words described by this regular expression is the union of the words described by $\\color{green}{r_1}$ with those described by $\\color{green}{r_2}$.\nNote that this operator is commutative, that is $\\color{green}{r_1\\ |\\ r_2} = \\color{green}{r_2\\ |\\ r_1}$. It\u0026rsquo;s also associative, meaning that for every regular expression $\\color{green}{r_1}$, $\\color{green}{r_2}$ and $\\color{green}{r_3}$, we have $\\color{green}{(r_1\\ |\\ r_2)\\ |\\ r_3} = \\color{green}{r_1\\ |\\ (r_2\\ |\\ r_3)}$ that we will simply write down as $\\color{green}{r_1\\ |\\ r_2\\ |\\ r_3}$. Expression Set of words $\\color{green}{\\epsilon \\ | \\ 1}$ $\\{\\epsilon, 1\\}$ $\\color{green}{(00) \\ | \\ (10)}$ $\\{00, 10\\}$ $\\color{green}{(10) \\ | \\ (00)}$ $\\{00, 10\\}$ $\\color{green}{(0 \\ | \\ 1)\\ |\\ (10)}$ $\\{0, 1, 10\\}$ $\\color{green}{0\\ |\\ (1 \\ | \\ (10))}$ $\\{0, 1, 10\\}$ $\\color{green}{0 \\ | \\ 1\\ |\\ (10)}$ $\\{0, 1, 10\\}$ $\\color{green}{(0\\ |\\ 1)(0\\ |\\ 1)}$ $\\{00, 01, 10, 11\\}$ The iteration operator noted * allows to juxtapose $0$ or several times the words generated by a regular expression. Let $\\color{green}{r}$ be a regular expression, then the regular expression $\\color{green}{r^*}$ represents the hypothetical2 regular expression $\\color{\\green}{\\epsilon\\ |\\ rr\\ |\\ rrr\\ |\\ rrrr\\ |\\ \\cdots}$. Expression Set of words $\\color{green}{0^*}$ $\\{\\epsilon, 0, 00, 000, 0000, \\cdots\\}$ $\\color{green}{(0\\ | \\ 1)^*}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \\cdots\\}$ To avoid too many parentheses, there is a priority between the different operators: the parentheses have the highest priority, then the $\\color{green}{*}$ operator, then the concatenation operator and finally the $\\color{green}{|}$ operator. We have also seen above that the concatenation and union operators are associative, which allows us to remove more brackets. Thus, the regular expression $\\color{green}{10^*1\\ |\\ 11\\ |\\ \\epsilon}$ reads $\\color{green}{(((1(0^ *))1)\\ |\\ (11))\\ |\\ \\epsilon}$.\nExamples We give below some examples of regular expressions still on the vocabulary $\\mathcal{V} = \\{0, 1\\}$.\nDescription Expression Set of words Binary numbers (without leading zeros) $\\color{green}{0\\ | \\ 1(0\\ | \\ 1)^*}$ $\\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \\cdots\\}$ Odd binary numbers $\\color{green}{1\\ | \\ 1(0\\ | \\ 1)^*1}$ $\\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \\cdots\\}$ Bit strings of even length containing alternating zeros and ones $\\color{green}{(10)^* \\ | \\ (01)^*}$ $\\{\\epsilon, 10, 01, 1010, 0101, 101010, 010101, \\cdots\\}$ Bit strings whose length is a multiple of 3 $\\color{green}{((0\\ | \\ 1)(0\\ | \\ 1)(0\\ | \\ 1))^*}$ $\\{\\epsilon, 000, 001, 010, 011, 100, \\cdots, 111000, 111001, \\cdots, 101011110, \\cdots \\}$ Bit strings that do not contain the sub-string $11$ $\\color{green}{0^* ( 100^* )^* (1\\ | \\ \\epsilon)}$ $\\{\\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \\cdots\\}$ You can have fun using regular expressions on Regex Crossword .\nIn the following video, we will formally define regular expressions and the languages they generate. We will also see how they are defined in ocamllex.\nThe following video will give examples of regular expressions found in MiniJava and show some extensions of regular expressions.\nQuestions We will use the notation $\\{a,b\\}^*$ in the questions below: $\\{a,b\\}^*$ represents the language generated by the regular expression $\\color{\\green}{(a\\ |\\ b)^*}$.\nLet\u0026#39;s consider the alphabet $\\{a, b\\}$. Give a regular expression to describe the language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ contains the words $aa$ or $bb$ $\\}$. A regular expression representing this language is as follows: ${\\color{green}{(}}a\\ {\\color{green}{|}}\\ b{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}aa\\ {\\color{green}{|}}\\ bb{\\color{green}{)}}{\\color{green}{(}}a\\ {\\color{green}{|}}\\ b{\\color{green}{)}}^{\\color{green}{*}}$\nTo test your regular expression, you can use the following site, which allows you to generate words recognized by your regular expression, and words that are not recognized.\nThis question, although one might think that it is very similar to the previous one, is not so easy. You can come back to this question after studying the next section on automata. Let\u0026#39;s consider the alphabet $\\{a, b\\}$. Give a regular expression to describe the language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ does not contain the words $aa$ or $bb\\}$. Since you cannot have two $a$ or two $b$ following each other, you have to alternate $a$ and $b$. This is the idea behind the following regular expression.\n${\\color{green}{(}}ab{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}a\\ {\\color{green}{|}}\\ \\epsilon{\\color{green}{)}}\\ {\\color{green}{|}}\\ {\\color{green}{(}}ba{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}b\\ {\\color{green}{|}}\\ \\epsilon{\\color{green}{)}}$\nAnother regular expression representing the same language, which we obtained using techniques we will see in the next section, is given below.\n$\\epsilon\\ {\\color{green}{|}}\\ a\\ {\\color{green}{|}}\\ {\\color{green}{(}}b\\ {\\color{green}{|}}\\ ab{\\color{green}{)}}{\\color{green}{(}}ab{\\color{green}{)}}^{\\color{green}{*}}{\\color{green}{(}}a\\ {\\color{green}{|}}\\ \\epsilon{\\color{green}{)}}$\nWe want to move in the grid below using the two actions: \u0026ldquo;go right\u0026rdquo; and \u0026ldquo;go up\u0026rdquo;. We start from the lower left corner and we want to get to the top right corner. A possible path is shown in the figure on the right.\nWrite a regular expression to describe all the actions that lead from the lower left corner to the upper right corner. This regular expression cannot be written succinctly without using extensions. We will have to list the different configurations. The number of possibilities is the number of combinations of 3 elements among 6: ${{6}\\choose{3}} = 20$. Indeed, it takes 6 actions to go from the start to the finish. Among these 6 actions, 3 must go to the right and 3 must go up. So we are going to create a regular expression with 20 parts. We use D to go to the right and H to the top.\nHHHDDD | HHDHDD | HHDDHD | HHDDDH | HDHHDD | HDHDHD | HDHDDH | HDDHHD | HDDHDH | HDDDHH | DHHHDD | DHHDHD | DHHDDH | DHDHHD | DHDHDH | DHDDHH | DDHHHD | DDHHDH | DDHDHH | DDDHHH We have generated the above combinations with the following program.\n#include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; const string UP = \u0026#34;H\u0026#34;; const string RIGHT = \u0026#34;D\u0026#34;; void combos(int nH, int nD, string res) { if (!nH \u0026amp;\u0026amp; !nD) { cost \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return; } if (nH) { combos(nH - 1, nD, res + TOP); } if (nD) { combos(nH, nD - 1, res + RIGHT); } } int main(int argc, char *argv[]) { combos(3, 3, \u0026#34;\u0026#34;); } By using regular expressions extensions we can obtain the following more concise form.\n^(?!(.*H.*){4}|(.*D.*){4})(H|D){6}$ In this expression, the operator (?!(.*H.*){4}|(.*D.*){4}) expresses that one should not be able to find four H or four D down the line. The expression (H|D){6} expresses that six characters must be recognized between H and D. It expresses that six characters must be recognized among H and D, but we cannot find four H or four D. So we need to have exactly three H and three D.\nThis question is not too easy. You can come back to this question after studying the next section on automata. Let\u0026#39;s consider the alphabet $\\{a, b\\}$. Give a regular expression to describe the language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ contains an even number of $a\\}$. A regular expression representing this language is as follows.\n${\\color{green}{(}}b\\ {\\color{green}{|}}\\ ab^{\\color{green}{*}}a{\\color{green}{)}}^{\\color{green}{*}}$\nThe $ab^{\\color{\\green}{*}}a$ part of the regular expression ensures that the number of $a$ is even. The word $\\epsilon$ is not forgotten thanks to the iteration operator on the whole alternative. The first part of the alternative, in conjunction with the iteration operator, allows you to put $b$ to the left or to the right of the $ab^{\\color{green}{*}}a$ part and also allows you to have only $b$.\nNote that we obtained this regular expression using techniques from the following section by first going through an automaton.\nLet\u0026#39;s consider the alphabet $\\{0, 1\\}$. What is the language described by the following regular expression: $\\color{green}{0^*10^*10^*(10^*\\ |\\ \\epsilon)}$? It describes the language containing two or three 1.\nAutomata In the previous section, we presented the regular expressions used to describe the so-called regular languages. This notation is useful to describe regular languages, and we will use it to describe lexical units in the MiniJava lexical analyzer. On the other hand, for recognition, i.e. to know whether a given word belongs to the language described by a regular expression, it is not easy to use a regular expression directly.\nWe will now describe finite, non-deterministic and deterministic automata, which make it easier to answer the question of whether a given word belongs to a given regular language. We will use these automata in the following section to build a software to test effectively, if a given word belongs to the language generated by a given regular expression.\nNote that the languages described by finite automata (non-deterministic or deterministic) are regular languages, regular expressions and the automata are therefore two equivalent ways of describing the same languages.\nNon-deterministic Finite Automata The following figure represents a non-deterministic finite automaton, which we will call $A_{ndf}$3, which describes C comments of type /*...*/. To simplify, we assume that our vocabulary is $\\mathcal{V} = \\{ a, b, /, * \\}$. In this figure we can see the following:\nstates, the circles on the figure, numbered from 0 to 7 for this example. You can see the starting state (or initial state), the 0 state, which has an arrow coming at it, but which doesn\u0026rsquo;t start from any state. The 7 state is an accepting state (or final state), it is represented by a double circle.\ntransitions between states, the arrows on the figure. On the arrows, there are symbols belonging to the vocabulary $\\mathcal{V}$ or the symbol $\\epsilon$. Note that on some transitions, for example the transition between state 3 and state 2, we put several symbols on the transition (on this transition there are the two symbols a and b). Formally, we should have written two transitions instead of one, each with one of the two symbols, but doing as we did allows us to write the automaton more succinctly.\nThe automaton will allow us to know if a word m constructed from the vocabulary $\\mathcal{V}$ belongs to the language described by the automaton (we note this language $\\mathcal{L}(A_{ndf})$).\nLet\u0026rsquo;s consider the word /*/*/, which we will call m, that belongs to $\\mathcal{V}^*$. How do we know if this word is described by the $A_{ndf}$ automaton?\nWe will start from the initial state, the state 0, and we will follow the transitions, character after character, looking for a path that leads us to the accepting state 7 after reading all the characters of the word m.\nStarting from state 0, there is only one transition, so there is no choice. The word must therefore begin with /, because that is the symbol on that transition. Once this transition is passed, we are in state 1 and we still have to analyze the */*/ part of m. Starting from state 1, there is also only one possible transition. We must therefore have the symbol * in the remaining part */*/ of m, because it is the symbol on the only transition from state 1. Once this transition is done, we are in state 2 and we still have to analyze the /*/ part of m. The state 2 has three outgoing transitions. All three are labeled with the $\\epsilon$ symbol. This symbol means that the input is not modified when you go through such a transition. We can see now why the automaton is non-deterministic because on the same symbol, here $\\epsilon$, we have the choice between several transitions. How do we choose the transition to follow? We are going to assume for the moment that we have the skill of clairvoyance and that we are going to choose the right transition, which is the one towards state 4. We will see in the videos how to automate this. In state 4 we still have the choice between two transitions: we can choose not to consume a character in the input by taking the $\\epsilon$ transition, or to consume the / character by looping back to state 4. As we are assuming that we can guess correctly, we will loop back to state 4 and consume the /. Now, the entry we have left to consume is */. We will take the $\\epsilon$ transition to state 2, then the $\\epsilon$ transition from state 2 to state 5. Once again, we do not worry for the moment about how to make the right transition choices when there is more than one possibility. We now find ourselves in the configuration below, where the cursor under the input string has not moved. In state 5, we only have an outgoing transition on the * character. The cursor on the input is placed on the *, so we can take this transition and move the cursor to the right. Now we just have to recognize the /. In state 6, there is also only one transition on the / symbol. Since the cursor on the input points to a / character, we can take this transition and move to the accepting state 7. Since the input string is now empty and we are in an accepting state, we can conclude that the word /*/*/ belongs to the $\\mathcal{L}(A_{ndf})$ language. The word /*/*/ is therefore a comment. The input string /*/*/ is accepted by our automaton, but how do we know if a string is not in the $\\mathcal{L}(A_{ndf})$ language, that is to say how do you know if the word is not accepted? For a non-deterministic automaton, it must be shown that after reading all the characters of the input string, one cannot be in an accepting state.\nIt seems easier to construct the non-deterministic finite automaton we have just seen to describe the language of comments than the regular expression $/*\\color{darkgreen}{(}*^{\\color{darkgreen}{+}}\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}\\ \\color{darkgreen}{|}\\ \\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\ \\color{darkgreen}{|}\\ /\\color{darkgreen}{)}\\color{darkgreen}{)}^{\\color{darkgreen}{*}}*^{\\color{darkgreen}{+}}/$ that we saw in the previous section. But you may be a Perl[^4] guru and it\u0026rsquo;s just too easy for you .\nIn the two following videos, we will detail non-deterministic finite automata, and how to detect if a word belongs or not to the language generated by a non-deterministic finite automaton.\nIn the following video, we will show how to go from a regular expression to a non-deterministic finite automaton.\nQuestions Let\u0026#39;s consider the alphabet $\\{a, b\\}$. Build an automaton that recognizes the following language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ contains the word $aba\\}$. For example, $aba$ is in the language, as well as $bbbbbaabaaaabb$, but not $babbbaaa$. We can see that this automaton actually mimics the regular expression $\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}aba\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}$.\nLet\u0026#39;s consider the alphabet $\\{a, b\\}$. Construct an automaton that recognizes the language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ does not contain the word $aba$ unless it is preceded by the word $bbb\\}$. For example, $aaabbbaabaa$ is in the language, $abba$ is in the language, but not $bbabab$. The upper part of the automaton, the states 1, 2, 3 and 4, is used to recognize a sequence of three b followed by anything. The lower part of the automaton is used to recognize anything but aba. The state 5 indicates that you haven\u0026rsquo;t yet seen an a or that you\u0026rsquo;ve just encountered a sequence ending in bb (so you\u0026rsquo;re sure you haven\u0026rsquo;t seen a sequence ending in ab). The state 6 indicates that we are analyzing a sequence of at least one a and state 7 that we just saw ab, so we must not have an a now. From states 5, 6 and 7 we can reach the upper part of the automaton because we have just analyzed a correct prefix and we may want to add aba in the following (adding bbb before).\nHow can we be sure that the lower part recognizes everything but aba? For the upper part, it is quite easy to convince yourself that it recognizes $bbb\\color{darkgreen}{(}a\\ \\color{darkgreen}{|}\\ b\\color{darkgreen}{)}^{\\color{darkgreen}{*}}$. But it\u0026rsquo;s not so easy to convince yourself that the bottom part describes everything but the aba chain. When you really want to be sure, there is only one way, you have to make a proof! Sure, You can tell me that it still has to be correct. You are right , but in a proof you just have to convince yourself that every elementary step is correct.\nWe will do a proof by induction on the length of the input string. For a string of length 0 ($\\epsilon$) of length 1 ($a$ and $b$) and of length 2 ($aa$, $ab$, $ba$ and $bb$), we can follow the transitions from state 0 to the lower part and see that they are all recognized and they do not have aba in them (because the string length is less than or equal to 2). Suppose that the property holds for strings of length $n \\ge 2$, is it still true for strings of length $n + 1$? Let\u0026rsquo;s look at the last two characters of the string m of length $n$.\nm ends with aa. In this case we must be in state 6 as shown above. We can add an a and accept the new ma string because we stay in state 6 which is an accepting state, and we can also add a b and accept the mb string because we are in state 7 which is also an accepting state.\nm ends with ab. In this case we must be in state 7 as indicated above. You cannot add an a because there is no transition on the character a from state 7 and therefore a string containing aba will not be recognized. However, you can add a b and still recognize the string of length $n+1$ mb.\nm ends with ba. In this case we must be in state 6 as indicated above and we can add an a or a b to get the strings of length $n+1$ ma or mb.\nm ends with bb. In this case we must be in state 5 as above and we can add an a or b to get the strings of length $n+1$ ma or mb.\nSo assuming that we can generate all words of length $n$ not containing aba, we have just shown that we can generate all words of length $n+1$ not containing aba.\nDeterministic Finite Automata Deterministic finite automata are a subset of the non-deterministic finite automata. The advantage of these automata is that they no longer need to \u0026ldquo;guess\u0026rdquo; the right transition to follow because, in a given state and for a given symbol of the input, there is at most one possible transition. As we have seen in the previous section, we can actually use a non-deterministic automaton without the need to guess. The algorithm we have seen actually allows us to dynamically construct a deterministic finite automaton. The advantage of starting directly from a deterministic automaton is that one does not need to reconstruct it each time. This will be all the more interesting for a lexical analyser because the regular expressions used to describe the lexical units will not change and we will gain efficiency by building once and for all the automata corresponding to the regular expressions.\nThe following automaton is a deterministic version of the non-deterministic automaton that recognizes the multiline comments in C in the previous section.\nSince deterministic finite automata are a restriction of non-deterministic finite automata, one could rightly believe that they allow us to describe fewer languages. In fact this is not the case and they are as powerful as non-deterministic finite automata.\nThe video below will describe deterministic finite automata and show how to transform a non-deterministic automaton into a deterministic one.\nThe code used in the previous video is available here.\nIn the following video, we will show how a lexical analyzer works and how to obtain a deterministic finite automaton of minimal size.\nIn the following videos, we will code in C++ a lexical analyzer for the small language fragment described in the previous video. The code used in these videos is available here.\nQuestions Let\u0026#39;s consider the alphabet $\\{a, b\\}$. Construct an automaton that recognizes the language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ contains an odd number of $a$ and an even number of $b \\}$. For example, $abb$ is in the language, as well as $bbabbaa$ and $aaaa$, but not $b$ nor $aabb$. In the above automaton, each state represents a possible configuration of the parity of the $a$ and $b$. For example, the accepting state $OE$ indicates that we have encountered an odd number of $a$ and an even number of $b$. The starting state $EE$ indicates that we saw an even number of $a$ and $b$ which is true at the very beginning as well, because then we did not meet any $a$ and $b$.\nLet\u0026#39;s consider the regular expression $\\color{darkgreen}{0^*(100^*)^*(1|\\epsilon)}$ that describes the bit strings on the alphabet $\\{0, 1\\}$ not containing the substring $11$. Transform this regular expression into a non-deterministic finite automaton, then transform it into a deterministic finite automaton and finally minimize it. The transformation of the regular expression into a non-deterministic finite automaton gives the following automaton. Note that we have taken some liberties with the transformations that we had seen in the video to reduce the size of the automaton a little bit, but the resulting automaton is very similar to what we had seen.\nThe corresponding deterministic finite automaton (using the transformation we have seen) is given below.\nIn this automaton, for example, the state $0$ corresponds to the set of states $\\{0,1,3,4,10,11\\}$ of the non-deterministic finite automaton and the state $4$ corresponds to the set $\\{8,7,9,4,10,11\\}$.\nNow we just need to minimize that automaton. First, we will make explicit the dead state that we are going to denote by D, which is implicit in the figure above representing the deterministic automaton. It is the state that is reached on a transition that is not indicated in the automaton of the above figure. If we make this state explicit, we get the following equivalent automaton:\nWe will first consider the two sets of states that we can immediately distinguish: the terminal states and non-terminal states. This gives us the following two groups.\n$G_1 = \\{0,1,2,3,4\\}$ $G_2 = \\{D\\}$ For the $G_1$ group, the states $0,1,3$ and $4$ have a transition to one of the $G_1$ group states on a 0 or 1. On the other hand, state $2$ have a transition to the $G_2$ group on a 1. So the group $G_1$ will have to be split. The group $G_2$ has only one element, so it remains unchanged. We now get the next three groups.\n$G_{1,1} = \\{0,1,3,4\\}$ $G_{1,2} = \\{2\\}$ $G_2 = \\{D\\}$ In the group $G_{1,1}$, we have\n$0 \\xrightarrow[]{0} G_{1,1}$ $1 \\xrightarrow[]{0} G_{1,1}$ $3 \\xrightarrow[]{0} G_{1,1}$ $4 \\xrightarrow[]{0} G_{1,1}$ $0 \\xrightarrow[]{1} G_{1,2}$ $1 \\xrightarrow[]{1} G_{1,2}$ $3 \\xrightarrow[]{1} G_{1,2}$ $4 \\xrightarrow[]{1} G_{1,2}$ The $G_{1,1}$ state does not need to be split any further because the transitions on 0 and 1 make each of the states of $G_{1,1}$ reach the same group. There is no more groups that can be split, so we are done minimizing. The states $0$, $1$, $3$ and $4$ will so be grouped together in one state. The automaton obtained after minimization is given below (we do not show the dead state).\nIf we interpret this automaton, we can see that state $0$ indicates that we have just seen a zero, or that we have not yet read anything. As for state $2$, it indicates that we have just encountered a $1$.\nTransformation from an Automaton to a Regular Expression We can automatically construct the regular expression corresponding to a finite automaton (deterministic or non-deterministic). We show below a series of transformations to go from the deterministic finite automaton corresponding to the comments in C seen above, to an equivalent regular expression. We will detail this transformation in the video below.\nWe can see, on the transitions, regular expressions appearing as the transformation progress. In order not to confuse the * character with the operator *, we write the operator in green.\nFirst of all, we will rewrite the automaton by making clear the regular expressions representing the alternatives on the transitions.\nWe are now going to eliminate one state at a time to arrive at an automaton containing only two states: the initial state and the accepting state.\nTo eliminate the state $q = \\{3,5,6\\}$, for each pair of states $(q_1, q_2)$, if there is an arc between $q_1$ and $q$ and between $q$ and $q_2$, we need to keep this information by modifying the arc between $q_1$ and $q_2$ accordingly.\nFor example, here, we will have to consider the path $\\{2,3,4,5\\} \\rightarrow q \\rightarrow \\{7\\}$ and add the regular expression $**^{\\color{darkgreen}{*}}/$ between the states $\\{2,3,4,5\\}$ and $\\{7\\}$ to keep the same information. We also need to consider the $\\{2,3,4,5\\} \\rightarrow q \\rightarrow \\{2,3,4,5\\}$ path and add the regular expression $**^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}a\\mbox{ }{\\color{darkgreen}{|}}\\mbox{ }b{\\color{darkgreen}{)}}$ on the loop on state $\\{2,3,4,5\\}$. We then get the following automaton.\nBy eliminating the state $\\{2,3,4,5\\}$ we get the next automaton.\nAnd finally, by eliminating state $\\{1\\}$, we get the final regular expression on the arc connecting the initial state to the accepting state.\nThe following video will detail this construction.\nThe next videos will detail a program in OCaml to transform an automaton into a regular expression using the Floyd-Warshall algorithm.\nThe following video presents the Floyd-Warshall transitive closure algorithm on a graph to present the concepts more simply before moving on to the next video to the automatic creation of a regular expression from an automaton. The code presented in the video can be found here.\nThe following video describes the code that can transform an automaton into a regular expression. The code can be found here, and the little python script that transforms our representation into the expected one on this site can be found here.\nQuestions Let\u0026#39;s consider the alphabet $\\{a, b\\}$. Find a deterministic automaton that describes the language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ contains an even number of $a\\}$. Then transform this automaton into a regular expression. We had already seen this language in the section on regular expressions in this question.\nThe following automaton describes the language, on the vocabulary $\\{a, b\\}$, where the number of $a$ is even.\nThe different steps of the transformation are given below.\nSo we get the regular expression ${\\color{darkgreen}{(}}b\\ {\\color{darkgreen}{|}}\\ ab^{\\color{darkgreen}{*}}a{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}$. This is the answer to this question. That is not surprising, because we did the same thing as we did here to obtain the regular expression .\nLet\u0026#39;s consider the alphabet $\\{a, b\\}$. Find a deterministic automaton to describe the language: $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ does not contain an odd number of $a$ or does not contain an even number of $b\\}$. Then, transform this automaton into a regular expression. Note that this language is complementary to the language $\\{ w \\in \\{a, b\\}^*\\ |\\ w$ contains an odd number of $a$ and an even number of $b\\}$ that we have already seen. The following automaton represents this language. Note that this automaton is the automaton we met in this question with the accepting states becoming normal states and normal states becoming accepting states.\nThe different steps of the transformation are given below.\nThe regular expression produced is therefore the following.\n${\\color{darkgreen}{(}}aa\\ {\\color{darkgreen}{|}}\\ bb\\ {\\color{darkgreen}{|}}\\ {\\color{darkgreen}{(}}ab\\ {\\color{darkgreen}{|}}\\ ba{\\color{darkgreen}{)}}{\\color{darkgreen}{(}}bb\\ {\\color{darkgreen}{|}}\\ aa{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}ba\\ {\\color{darkgreen}{|}}\\ ab{\\color{darkgreen}{)}}{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}\\epsilon\\ {\\color{darkgreen}{|}}\\ b\\ {\\color{darkgreen}{|}}\\ {\\color{darkgreen}{(}}ab\\ {\\color{darkgreen}{|}}\\ ba{\\color{darkgreen}{)}}{\\color{darkgreen}{(}}bb\\ {\\color{darkgreen}{|}}\\ aa{\\color{darkgreen}{)}}^{\\color{darkgreen}{*}}{\\color{darkgreen}{(}}\\epsilon\\ {\\color{darkgreen}{|}}\\ a{\\color{darkgreen}{)}}{\\color{darkgreen}{)}}$\nTo check that we did not make any errors during the transformation, we can use the following site and transform the regular expression to a minimal deterministic automaton to see if we can recognize our automaton. If you do this, you will see that you get the same automaton (with different state names).\nRegular Expressions Matching We are going to put into practice the notions we have just seen about regular expressions and automata by making a small application to test whether or not a string matches a pattern represented by a regular expression.\nWe will present a sequence of interactions in the OCaml interpreter that we will be able to do with this application.\n1utop # let re = RE.regex_from_string \u0026#34;0*(100*)*1?\u0026#34;;; 2val re : RE.regex = 3 RE.Concatenation (RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;), 4 RE.Concatenation 5 (RE.ZeroOrMore 6 (RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, 7 RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, 8 RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;)))), 9 RE.ZeroOrOne (RE.CharSet \u0026lt;abstr\u0026gt;))) On line 1, we create the regular expression $\\color{darkgreen}{0^*(100^*)^*(1|\\epsilon)}$ which allows us to describe the words that do not contain consecutive 1. Note that we use the notation 1? to represent $\\color{darkgreen}{(1|\\epsilon)}$.\nWe then create an equivalent non-deterministic finite automaton.\nutop # let nfa = NFA.init re;; val nfa : NFA.t = \u0026lt;abstr\u0026gt; We can then test if a string, here 101010, belongs or not to the language generated by the non-deterministic finite automaton and thus by the regular expression.\nutop # NFA.full_match nfa \u0026#34;101010\u0026#34;;; - : bool = true We can see in the following example, that the string 011111100100, containing consecutive 1, does not match the regular expression.\nutop # NFA.full_match nfa \u0026#34;011111100100\u0026#34;;; - : bool = false We can test if a substring is in a given string by surrounding an expression with .*. The . represents any character. The following example will define a regular expression to search for the substring Doc.\nutop # let re = RE.regex_from_string \u0026#34;.*Doc.*\u0026#34;;; val re : RE.regex = RE.Concatenation (RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;), RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, RE.Concatenation (RE.CharSet \u0026lt;abstr\u0026gt;, RE.ZeroOrMore (RE.CharSet \u0026lt;abstr\u0026gt;))))) utop # let dfa = DFA.init re;; val dfa : DFA.t = \u0026lt;abstr\u0026gt; utop # DFA.full_match dfa \u0026#34;Wait a minute, Doc. Ah... Are you telling me that you built a time machine... out of a DeLorean?\u0026#34;;; - : bool = true utop # DFA.full_match dfa \u0026#34;The way I see it, if you\u0026#39;re gonna build a time machine into a car, why not do it with some style?\u0026#34;;; - : bool = false The code that will be explained in the following videos can be found here.\nIn the following video, we will present an overview of the application and detail the code to go from a string representing a regular expression to an OCaml representation of this regular expression. The grammar describing regular expressions can be found here.\nIn the following video, we present the notion of programming with continuation that we will use in conjonction with backtracking in the pattern recognition module. The code to illustrate continuations can be found here.\nThere is the solution to one of the questions we ask in the video at the end of the listing on continuations.\nIn the following video, we will describe the pattern recognition module based on backtracking and continuations.\nIn the following video, we will describe the pattern recognition module based on non-deterministic finite automata.\nIn the following video, we will describe the pattern recognition module based on deterministic finite automata.\nIn the following video, we will show how we have tested our different modules.\nQuestions The code below describes the part of the regex_from_string function that handles concatenations.\n1and re1 l = 2 let e, l = re2 l in 3 let e, l = 4 let rec re1\u0026#39; e l = 5 match l with 6 | \u0026#39;?\u0026#39; :: r -\u0026gt; re1\u0026#39; (ZeroOrOne e) r 7 | \u0026#39;*\u0026#39; :: r -\u0026gt; re1\u0026#39; (ZeroOrMore e) r 8 | \u0026#39;+\u0026#39; :: r -\u0026gt; re1\u0026#39; (OneOrMore e) r 9 | _ -\u0026gt; e, l 10 in 11 re1\u0026#39; e l 12 in 13 match l with 14 | c :: _ when c \u0026lt;\u0026gt; \u0026#39;)\u0026#39; \u0026amp;\u0026amp; c \u0026lt;\u0026gt; \u0026#39;|\u0026#39; -\u0026gt; 15 let e\u0026#39;, l = re1 l in 16 Concatenation (e, e\u0026#39;), l 17 | _ -\u0026gt; 18 e, l During the video, we said that there were two cases to handle to see if there were no new concatenations. To do so, we test on line 17 if the next character is a vertical bar or the closing parenthesis but there is another case, which the code handles well, but which we have not talked about. What is this other case? If there are no more characters, i.e. if the list l is empty on line 13, there is no more possible concatenation. We take care of this case on line 17, because the test on line 14 requires at least one character to be successful.\nFor the backtracking pattern matching module, we saw that for the regular expression $\\color{green}{(a?)^{40}a^{40}}$ (the superscript 40 indicates that the string is repeated forty times) and the input string $a^{40}$ we got a prohibitive execution time. Can you find another regular expression and another input string that would also result in a very long execution time? For example, the regular expression $\\color{green}{a^{++}}$ results in a prohibitive execution time on the input string aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab.\nHow to explain this behaviour?\nWe can visualize the regular expression $\\color{green}{(a^+)^+}$ as the following hypothetical regular expression $\\color{green}{aa^*\\ |\\ aa^*aa^* \\ |\\ aa^*aa^*aa^*\\ |\\ aa^*aa^*aa^*aa^*\\ |\\ \\cdots}$. If we take the subexpression $\\color{\\green}{aa^*aa^*}$, the first $\\color{green}{aa^*}$ will first consume all the a and the second $\\color{green}{aa^*}$ will then fail because there is a b in the input. Now, the first $\\color{\\green}{aa^*}$ will leave only one a and the second will consume the last one and we will fail because there is still one b left in the input when we are done. Now, the first $\\color{green}{aa^*}$ will leave two a in the input and the second $\\color{green}{aa^*}$ will consume the last two and fail, then one and fail too. So, the first $\\color{green}{aa^*}$ will leave three a in the input and the second $\\color{green}{aa^*}$ will first consume all three a and fail, then try to consume only two a and fail, then only one a and fail as well. And now, the first $\\color{\\green}{aa^*}$ will leave four a and so on. The number of attempts is going to be even greater with the subexpression $\\color{green}{aa^*aa^*aa^*}$.\nNote that in our implementation of the Backtracking module, we have the following code.\n1| ZeroOrMore t1 -\u0026gt; 2 full_match t1 l (fun l\u0026#39; -\u0026gt; l \u0026lt;\u0026gt; l\u0026#39; \u0026amp;\u0026amp; full_match t l\u0026#39; k) 3 || k l Switching the lines 2 and 3 as below still gives rise to a prohibitive amount of time contrary to the expression $\\color{green}{(a?)^{40}a^{40}}$ and the input string $a^{40}$ when we did the same inversion for ZeroOrOne t1.\n1| ZeroOrMore t1 -\u0026gt; 2 k l 3 || full_match t1 l (fun l\u0026#39; -\u0026gt; l \u0026lt;\u0026gt; l\u0026#39; \u0026amp;\u0026amp; full_match t l\u0026#39; k) In our DFA module, we memoized the transitions already seen thanks to the Memo module whose definition is given below.\n1module Memo = 2 Map.Make( 3 struct 4 type t = S.t * char 5 let compare (s1, c1) (s2, c2) = 6 let res = compare c1 c2 in 7 if res = 0 then 8 S.compare s1 s2 9 else 10 res 11 end) The key comparison function in this table, defined from line 5 to line 10, may require to compare sets on line 8.\nWhen one is in a given state of the deterministic finite automaton, it is sufficient to look whether the transition on a particular character has already been seen. There is therefore no need to compare sets and to have for each transition from the same state, a key that contains a state and a character.\nTo avoid creating a table that requires a pair of state and character as a key, one should associate to each state of the deterministic finite automaton (which is a set of states of the non-deterministic finite automaton) a table. The keys of this table will be characters, and the table will allow to store the transitions already encountered.\nThe new module that we want to realize is the following.\nmodule DFA2 : Matching = struct (* TO DO *) end Your mission, if you choose to accept it, is to code the module to implement our new idea. A possible solution can be found here. The file to test this new module can be found here.\nLexical Analyzer with Ocamllex We will now describe the MiniJava lexical analyzer (or scanner) which is created using ocamllex. The tool ocamllex is a lexical analyzer generator. You give it a list of regular expressions with actions to perform when a regular expression is recognized. The tool will then automatically generate a lexical analyzer that looks roughly like the lexer.cpp program that have we studied above.\nThe following program shows a MiniJava program, Lexical.java, which is invalid, but is nevertheless lexically correct. class /*/*/ public 123MrC00der; while )( { int int42 [] // this sentence is false\nIf we execute the command ./mini-java --show-tokens-with-loc Lexical.java to run our mini-java transpiler with the option to output only the tokens produced by the lexical analyzer, we obtain the following tokens4.\nCLASS PUBLIC INT_CONST ‘123‘ IDENT ‘MrC00der‘ ▸ line 3, char 11 ◂ SEMICOLON WHILE RPAREN LPAREN LBRACE INTEGER IDENT ‘int42‘ ▸ line 6, char 1 ◂ LBRACKET RBRACKET EOF The tokens will be used by the syntax analyzer that we will study in the next chapter.\nThe following video will introduce ocamllex and describe the lexical analyzer of our transpiler. The code of the calculator in Reverse Polish Notation can be found here.\nQuestions Suppose that in the lexical analyzer, the longest matching rule (the regular expression that matches the maximum number of characters is selected) is not used, but instead, the shortest matching rule is used. Why cannot we correctly recognize the tokens of MiniJava? We can try this by modifying the lexer.mll file of our transpiler using the shortest matching rule option. We then replace the line\nrule get_token = parse with the line\nrule get_token = shortest Now let\u0026rsquo;s consider again the example we saw above. If we recompile our transpiler and execute the command below,\n./mini-java --show-tokens-with-loc Lexical.java we get the following output.\nIDENT ‘c‘ ▸ line 1, char 1 ◂ IDENT ‘l‘ ▸ line 1, char 2 ◂ IDENT ‘a‘ ▸ line 1, char 3 ◂ IDENT ‘s‘ ▸ line 1, char 4 ◂ IDENT ‘s‘ ▸ line 1, char 5 ◂ Lexical error file \u0026#34;Lexical.java\u0026#34;, line 2, character 1: Illegal character: /. Our lexical analyzer, with the shortest matching rule, recognizes each character of the keyword class as an identifier. When it gets to the /, the first character of the multiline comment, it cannot recognize an identifier, so it moves on to the next rule for matching a single character, which is the rule below.\n| _ as c { raise (Error (\u0026#34;Illegal character: \u0026#34; ^ String.make 1 c)) } We want to write a program, using ocamllex, that replaces tabulations by four spaces and removes spaces and tabulations just before the end of line. For example, suppose we have a file.txt file whose content is shown below using the unix cat command to display tabulations, represented by ^I, and line breaks represented by $.\ncat -ET file.txt I wish you^I ^I$ a very happy new^I^I year^I $ ^I$ $ If the ocamllex file is called clean.mll, it is compiled as shown below.\nocamllex clean.mll ocamlopt clean.ml -o clean We will then use the clean program on a file.txt file, for example, as follows.\n./clean \u0026lt; fichier.txt \u0026gt; res.txt We will then get in the res.txt file, the contents of the file.txt file where the tabulations have been transformed into four spaces, and where the spaces and tabulations right before the end of line have been removed.\ncat -ET res.txt I wish you$ a very happy new year$ $ $ Implement the program that replaces tabulations with four spaces and removes spaces and tabulations just before the end of line. The following ocamllex file answers the question.\nRessources Play with regular expressions\nTest regular expressions\nGenerate test-cases for regular expressions\nTransform regular expressions into automata\nRuss Cox on regular expression matching\nLearn OCaml\nTry OCaml\nFunctional programming course using OCaml\nOCaml documentation\nOcamllex documentation\nOcamllex in Real World OCaml\nISO C++\nC++ core guidelines\nC++ standard\\\nThe empty word is the equivalent of the string \u0026quot;\u0026quot;.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA regular expression must be of finite size.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nndf for non-deterministic finite.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMore precisely, we obtain a representation of the tokens.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"
},
{
	"uri": "http://localhost:1313/MrCoder/en/compiler/minijava/parser/",
	"title": "Syntactic Analysis",
	"tags": [],
	"description": "",
	"content": " graph LR; A[MiniJava source file] --\u003e|characters| B(fa:fa-tools Lexical analysis) B --\u003e|tokens| C(fa:fa-tools Syntactic analysis) C --\u003e|abstract syntax tree| D(fa:fa-tools Typechecker) D --\u003e|abstract syntax tree| E(fa:fa-tools C code generator) E --\u003e|characters| F[C source file] classDef green fill:#74B559,stroke:#222723,stroke-width:5px; class C green "
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/bash/",
	"title": "Bash",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/c/",
	"title": "C",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/compiler/",
	"title": "Compiler",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/compiler/",
	"title": "Compiler",
	"tags": [],
	"description": "",
	"content": "Abstractly a compiler is a program that takes as input a representation of some sort and transforms this representation into another one as its output.\ngraph LR; subgraph input file A[Representation A] end A[Representation A] --\u003e C(fa:fa-tools Compiler) C --\u003e B subgraph output file B[Representation B] end Usually, the input file contains a programming language source (a C source file for example) and the output file contains an executable file for the target machine or for a virtual machine. A compiler generally produces different kind of intermediate representations before producing the final representation. The compiler can, depending on the source language, do some static analysis to detect some errors before the execution of the program. The compiler can transform the source program, without modifying its semantic, into a more efficient code : this transformation is called optimisation.\nIn the MiniJava part, we will study a kind of compiler, a transpiler or source to source compiler, for which the input representation will be a programming language (the MiniJava language) and the output representation will be another programming language (the C language). In this way, we will be able to take advantage of the presence of a C compiler and focus only on the static type checking and the generation in C of the object orienting part of MiniJava.\nThis first compiler will be an easier step into compilation but still will be a very practical approach to compilation because we will produce quickly a compiler without the hard part of generating optimized machine code for a given architecture. "
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/garbage-collector/",
	"title": "Garbage Collector",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/menhir/",
	"title": "Menhir",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/minijava/",
	"title": "MiniJava",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/",
	"title": "MrCoder",
	"tags": [],
	"description": "",
	"content": "MrCoder \u0026ldquo;C\u0026rsquo;est en forgeant qu\u0026rsquo;on devient forgeron.\u0026rdquo; (french proverb)\nGoal This little corner of the web is dedicated to learn computer science by coding stuff. We will go together, step by step, through different themes of computer science, building along the way softwares to thoroughly understand the different subjects. I hope this will be helpful for some of you and that you will have fun learning.\nSite Structure I will use text, videos and code to explain the different subjects:\nVideos are in french with english subtitles (Hopefully with the help of the community for the translations ). Code is on github. Go to the left panel or look at the themes below to choose your subject and let\u0026rsquo;s dive into the vast and beautiful world of computer science!\nSubjects Overview MiniJava transpiler We transform a MiniJava source file, which is a subset of Java, into a C source file. We then use gcc to translate the C file into an executable one.\nTo do this transpiling, we first do a lexical analysis of the MiniJava source file, then a syntax analysis, then we typecheck the code and finally, we generate a C source file from the abstract syntax tree of MiniJava. The most difficult parts for the code generation are the class and dynamic binding representations and the inclusion of a garbage collector.\nThe transpiler is written in OCaml using Menhir for the parser. "
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/object-oriented-language/",
	"title": "Object Oriented Language",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/ocaml/",
	"title": "OCaml",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/MrCoder/en/tags/transpiler/",
	"title": "Transpiler",
	"tags": [],
	"description": "",
	"content": ""
}]