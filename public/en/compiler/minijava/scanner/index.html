<!DOCTYPE html>
<html lang="en" class="js csstransforms3d">
  <head><script src="/MrCoder/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=MrCoder/livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.138.0">
    <meta name="description" content="">


    <link rel="icon" href="/images/favicon.png" type="image/png">

    <title>Lexical Analysis :: MrCoder</title>

    
    <link href="/MrCoder/css/nucleus.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/fontawesome-all.min.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/hybrid.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/featherlight.min.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/perfect-scrollbar.min.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/auto-complete.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/atom-one-dark-reasonable.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/theme.css?1768208418" rel="stylesheet">
    <link href="/MrCoder/css/hugo-theme.css?1768208418" rel="stylesheet">
    
      <link href="/MrCoder/css/theme-green.css?1768208418" rel="stylesheet">
    

    <script src="/MrCoder/js/jquery-3.3.1.min.js?1768208418"></script>

    <style>
      :root #header + #content > #left > #rlblock_left{
          display:none !important;
      }
      
        :not(pre) > code + span.copy-to-clipboard {
            display: none;
        }
      
    </style>
    
  </head>
  <body class="" data-url="/MrCoder/en/compiler/minijava/scanner/">
    <nav id="sidebar" class="">



  <div id="header-wrapper">
    <div id="header">
      <a id="logo" href="/MrCoder/en">
    <img src="/MrCoder/images/logo.png">
</a>
    </div>
    
        <div class="searchbox">
    <label for="search-by"><i class="fas fa-search"></i></label>
    <input data-search-input id="search-by" type="search" placeholder="Search...">
    <span data-search-clear=""><i class="fas fa-times"></i></span>
</div>

<script type="text/javascript" src="/MrCoder/js/lunr.min.js?1768208418"></script>
<script type="text/javascript" src="/MrCoder/js/auto-complete.js?1768208418"></script>
<script type="text/javascript">
    
        var baseurl = "http:\/\/localhost:1313\/MrCoder\/\/en";
    
</script>
<script type="text/javascript" src="/MrCoder/js/search.js?1768208418"></script>

    
  </div>

    <div class="highlightable">
    <ul class="topics">

        
          
          


 
  
    
    <li data-nav-id="/MrCoder/en/compiler/" title="Compiler" class="dd-item
        parent
        
        
        ">
      <a href="/MrCoder/en/compiler/">
          Compiler
          
      </a>
      
      
        <ul>
          
          
            
          
          
          
        
          
            
            


 
  
    
    <li data-nav-id="/MrCoder/en/compiler/minijava/" title="MiniJava" class="dd-item
        parent
        
        
        ">
      <a href="/MrCoder/en/compiler/minijava/">
          MiniJava
          
      </a>
      
      
        <ul>
          
          
          
          
        
          
            
            


 
  
    
      <li data-nav-id="/MrCoder/en/compiler/minijava/introduction/" title="Introduction" class="dd-item ">
        <a href="/MrCoder/en/compiler/minijava/introduction/">
        Introduction
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/MrCoder/en/compiler/minijava/scanner/" title="Lexical Analysis" class="dd-item active">
        <a href="/MrCoder/en/compiler/minijava/scanner/">
        Lexical Analysis
        
        </a>
    </li>
     
  
 

            
          
            
            


 
  
    
      <li data-nav-id="/MrCoder/en/compiler/minijava/parser/" title="Syntactic Analysis" class="dd-item ">
        <a href="/MrCoder/en/compiler/minijava/parser/">
        Syntactic Analysis
        
        </a>
    </li>
     
  
 

            
          
        
        </ul>
              
    </li>
  
 

            
          
        
        </ul>
              
    </li>
  
 

          
         
    </ul>

    
    
      <section id="shortcuts">
        <h3>Contact</h3>
        <ul>
          
              <li> 
                  <a class="padding" href="https://github.com/lascar-pacagi"><i class='fab fa-fw fa-github'></i> GitHub repo</a>
              </li>
          
              <li> 
                  <a class="padding" href="https://protonmail.com/"><i class='far fa-fw fa-envelope'></i> lascar.pacagi@protonmail.com</a>
              </li>
          
              <li> 
                  <a class="padding" href="https://discord.gg/UX5XS44"><i class='fab fa-fw fa-discord'></i> <font face='Mono'>MrC00der</font></a>
              </li>
          
        </ul>
      </section>
    

    
    <section id="prefooter">
      <hr/>
      <ul>
      
        <li>
          <a class="padding">
            <i class="fas fa-language fa-fw"></i>
          <div class="select-style">
            <select id="select-language" onchange="location = this.value;">
          
          
          
              
              
                  
                    
                    
                      <option id="fr" value="http://localhost:1313/MrCoder/fr/compiler/minijava/scanner/">Fran√ßais</option>
                    
                  
              
                  
              
          
              
              
                  
              
                  
                    
                    
                      <option id="en" value="http://localhost:1313/MrCoder/en/compiler/minijava/scanner/" selected>English</option>
                    
                  
              
          
        </select>
        <svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
          width="255px" height="255px" viewBox="0 0 255 255" style="enable-background:new 0 0 255 255;" xml:space="preserve">
          <g>
            <g id="arrow-drop-down">
              <polygon points="0,63.75 127.5,191.25 255,63.75 		" />
            </g>
          </g>
        </svg>
        </div>
        </a>
        </li>
      
      
      
      </ul>
    </section>
    
    <section id="footer">
      <p><i class="fas fa-mug-hot fa-2x"></i></p>

    </section>
  </div>
</nav>





        <section id="body">
        <div id="overlay"></div>
        <div class="padding highlightable">
              
              <div>
                <div id="top-bar">
                
                
                <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
                    <span id="sidebar-toggle-span">
                        <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
                          <i class="fas fa-bars"></i>
                        </a>
                    </span>
                  
                  <span id="toc-menu"><i class="fas fa-list-alt"></i></span>
                  
                  <span class="links">
                 
                 
                    
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            <a href='/MrCoder/en/'>MrCoder</a> > <a href='/MrCoder/en/compiler/'>Compiler</a> > <a href='/MrCoder/en/compiler/minijava/'>MiniJava</a> > Lexical Analysis
            
            
            
            
            
            
            
            
                 
                  </span>
                </div>
                
                    <div class="progress">
    <div class="wrapper">
<nav id="TableOfContents">
  <ul>
    <li><a href="#regular-expressions">Regular Expressions</a>
      <ul>
        <li><a href="#examples">Examples</a></li>
        <li><a href="#questions">Questions</a></li>
      </ul>
    </li>
    <li><a href="#automata">Automata</a>
      <ul>
        <li><a href="#non-deterministic-finite-automata">Non-deterministic Finite Automata</a></li>
        <li><a href="#deterministic-finite-automata">Deterministic Finite Automata</a></li>
      </ul>
    </li>
    <li><a href="#regular-expressions-matching">Regular Expressions Matching</a>
      <ul>
        <li><a href="#questions-4">Questions</a></li>
      </ul>
    </li>
    <li><a href="#lexical-analyzer-with-ocamllex">Lexical Analyzer with Ocamllex</a>
      <ul>
        <li><a href="#questions-5">Questions</a></li>
      </ul>
    </li>
    <li><a href="#ressources">Ressources</a></li>
  </ul>
</nav>
    </div>
</div>

                
              </div>
            </div>
            
        <div id="head-tags">
        
        </div>
        
        <div id="body-inner">
          
            <h1>
                
                Lexical Analysis
            </h1>
            

            
            <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
 MathJax.Hub.Config({
     tex2jax: {
         inlineMath: [['$','$'], ['\\(','\\)']],
         displayMath: [['$$','$$']],
         processEscapes: true,
         processEnvironments: true,
         skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
         TeX: { equationNumbers: { autoNumber: "AMS" },
                extensions: ["AMSmath.js", "AMSsymbols.js"] }
     }
 });
 MathJax.Hub.Queue(function() {
     
     
     
     var all = MathJax.Hub.getAllJax(), i;
     for(i = 0; i < all.length; i += 1) {
         all[i].SourceElement().parentNode.className += ' has-jax';
     }
 });

 MathJax.Hub.Config({
     
     TeX: { equationNumbers: { autoNumber: "AMS" } }
 });
</script>



<div class="mermaid" align="center">
graph LR;
A[MiniJava source file] -->|characters| B(fa:fa-tools<br/> Lexical <br/> analysis)
B -->|tokens| C(fa:fa-tools <br/> Syntactic <br/> analysis)
C -->|abstract syntax tree| D(fa:fa-tools <br/> Typechecker)
D -->|abstract syntax tree| E(fa:fa-tools <br/> C code <br/> generator)
E -->|characters| F[C source file]
classDef green fill:#74B559,stroke:#222723,stroke-width:5px;
class B green
</div>

<p>We will describe the MiniJava lexical analyzer, also called scanner, which will group the characters
of the source file into lexical units also called tokens. These lexical units will then be given to the syntactic analyzer in the following phase of the transpiler.<br>
Before describing the lexical analyzer of MiniJava, we will present regular expressions that will be used
to describe tokens. We will also study automata, a kind of graph, and use them to match regular expressions.
<a name="regular_expressions"></a></p>
<h2 id="regular-expressions">Regular Expressions</h2>
<p>Regular expressions will allow us to describe succinctly and quite intuitively
the MiniJava lexical units and will be used in the <code>ocamllex</code> lexical analyzer generator that we
will be using in our transpiler.</p>
<p>A regular expression describes a set of words from a given vocabulary. We will take as an example
the vocabulary $\mathcal{V} = \{0, 1\}$ consisting simply of two elements: <code>0</code> and <code>1</code>. We describe below the basic elements and operators for creating regular expressions and the words that
they describe.</p>
<ul>
<li>
<p>Basic regular expressions:</p>
</li>
<li>
<p>The regular expression $\color{green}\epsilon$ generates the set containing only the empty word<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>: $\{\epsilon\}$.</p>
</li>
<li>
<p>For $c \in \mathcal{V}$, the regular expression $\color{green}c$ represents the set containing a single word: $\{c\}$.</p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><center>Expression</center></th>
          <th style="text-align: center"><center>Set of words</center></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$\color{green}0$</td>
          <td style="text-align: center">$\{0\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}1$</td>
          <td style="text-align: center">$\{1\}$</td>
      </tr>
  </tbody>
</table>
<ul>
<li>
<p>Compound regular expressions:</p>
</li>
<li>
<p>Parentheses can be used to group together regular expressions. Let $\color{green}{r}$ be a regular expression, then $\color{green}{(r)}$ represents the same set of
words as the expression $\color{\green}{r}$.</p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><center>Expression</center></th>
          <th style="text-align: center"><center>Set of words</center></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$\color{green}{(0)}$</td>
          <td style="text-align: center">$\{0\}$</td>
      </tr>
  </tbody>
</table>
<ul>
<li>The concatenation operator allows to juxtapose the words generated by two regular expressions. Let $\color{green}{r_1}$ and $\color{green}{r_2}$ be two regular expressions.
The concatenation of these two regular expressions is noted: $\color{green}{r_1r_2}$. The set of words described by this regular expression is
the concatenation of the words described by $\color{green}{r_1}$ with those described by $\color{green}{r_2}$.<br>
Note that this operator is associative, which means that for any
regular expression $\color{green}{r_1}$, $\color{green}{r_2}$ and $\color{green}{r_3}$, we have
$\color{green}{(r_1r_2)r_3} = \color{green}{r_1(r_2r_3)}$ that we will simply write down as $\color{green}{r_1r_2r_3}$.</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><center>Expression</center></th>
          <th style="text-align: center"><center>Set of words</center></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$\color{green}{\epsilon1}$</td>
          <td style="text-align: center">$\{1\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{10}$</td>
          <td style="text-align: center">$\{10\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{(10)1}$</td>
          <td style="text-align: center">$\{101\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{1(01)}$</td>
          <td style="text-align: center">$\{101\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{101}$</td>
          <td style="text-align: center">$\{101\}$</td>
      </tr>
  </tbody>
</table>
<ul>
<li>The union operator is used to get the union of the words generated by two regular expressions. Let $\color{green}{r_1}$ and $\color{green}{r_2}$ be two regular expressions.
The union of these two regular expressions is noted: $\color{green}{r_1\ |\ r_2}$. The set of words described by this regular expression is
the union of the words described by $\color{green}{r_1}$ with those described by $\color{green}{r_2}$.<br>
Note that this operator is commutative, that is
$\color{green}{r_1\ |\ r_2} = \color{green}{r_2\ |\ r_1}$. It&rsquo;s also associative, meaning that for every
regular expression $\color{green}{r_1}$, $\color{green}{r_2}$ and $\color{green}{r_3}$, we have
$\color{green}{(r_1\ |\ r_2)\ |\ r_3} = \color{green}{r_1\ |\ (r_2\ |\ r_3)}$ that we will simply write down as $\color{green}{r_1\ |\ r_2\ |\ r_3}$.</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><center>Expression</center></th>
          <th style="text-align: center"><center>Set of words</center></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$\color{green}{\epsilon \ | \ 1}$</td>
          <td style="text-align: center">$\{\epsilon, 1\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{(00) \ | \ (10)}$</td>
          <td style="text-align: center">$\{00, 10\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{(10) \ | \ (00)}$</td>
          <td style="text-align: center">$\{00, 10\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{(0 \ | \ 1)\ |\ (10)}$</td>
          <td style="text-align: center">$\{0, 1, 10\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{0\ |\ (1 \ | \ (10))}$</td>
          <td style="text-align: center">$\{0, 1, 10\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{0 \ | \ 1\ |\ (10)}$</td>
          <td style="text-align: center">$\{0, 1, 10\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{(0\ |\ 1)(0\ |\ 1)}$</td>
          <td style="text-align: center">$\{00, 01, 10, 11\}$</td>
      </tr>
  </tbody>
</table>
<ul>
<li>The iteration operator noted <code>*</code> allows to juxtapose $0$ or several times the words generated by a regular expression. Let $\color{green}{r}$ be a regular expression, then
the regular expression $\color{green}{r^*}$ represents the hypothetical<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> regular expression
$\color{\green}{\epsilon\ |\ rr\ |\ rrr\ |\ rrrr\ |\ \cdots}$.</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><center>Expression</center></th>
          <th style="text-align: center"><center>Set of words</center></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$\color{green}{0^*}$</td>
          <td style="text-align: center">$\{\epsilon, 0, 00, 000, 0000, \cdots\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">$\color{green}{(0\ | \ 1)^*}$</td>
          <td style="text-align: center">$\{\epsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, \cdots\}$</td>
      </tr>
  </tbody>
</table>

<div class="notices note" ><p>To avoid too many parentheses, there is a priority between the different operators: the parentheses have the highest priority,
then the $\color{green}{*}$ operator, then the concatenation operator and finally the $\color{green}{|}$ operator. We have also seen above that the concatenation and union operators
are associative, which allows us to remove more brackets.
Thus, the regular expression $\color{green}{10^*1\ |\ 11\ |\ \epsilon}$ reads $\color{green}{(((1(0^ *))1)\ |\ (11))\ |\ \epsilon}$.</p>
</div>

<h3 id="examples">Examples</h3>
<p>We give below some examples of regular expressions still on the vocabulary $\mathcal{V} = \{0, 1\}$.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"><center>Description</center></th>
          <th style="text-align: center"><center>Expression</center></th>
          <th style="text-align: center"><center>Set of words</center></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">Binary numbers (without leading zeros)</td>
          <td style="text-align: center">$\color{green}{0\ | \ 1(0\ | \ 1)^*}$</td>
          <td style="text-align: center">$\{0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, \cdots\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">Odd binary numbers</td>
          <td style="text-align: center">$\color{green}{1\ | \ 1(0\ | \ 1)^*1}$</td>
          <td style="text-align: center">$\{1, 11, 101, 111, 1001, 1011, 1101, 1111, 10001, \cdots\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">Bit strings of even length containing alternating zeros and ones</td>
          <td style="text-align: center">$\color{green}{(10)^* \ | \ (01)^*}$</td>
          <td style="text-align: center">$\{\epsilon, 10, 01, 1010, 0101, 101010, 010101, \cdots\}$</td>
      </tr>
      <tr>
          <td style="text-align: center">Bit strings whose length is a multiple of 3</td>
          <td style="text-align: center">$\color{green}{((0\ | \ 1)(0\ | \ 1)(0\ | \ 1))^*}$</td>
          <td style="text-align: center">$\{\epsilon, 000, 001, 010, 011, 100, \cdots, 111000, 111001, \cdots, 101011110, \cdots \}$</td>
      </tr>
      <tr>
          <td style="text-align: center">Bit strings that do not contain the sub-string $11$</td>
          <td style="text-align: center">$\color{green}{0^* ( 100^* )^* (1\ | \ \epsilon)}$</td>
          <td style="text-align: center">$\{\epsilon, 0, 1, 00, 01, 10, 000, 001, 010, 100, 101, 0000, 0001, \cdots\}$</td>
      </tr>
  </tbody>
</table>

<div class="notices info" ><p><a href="https://regexcrossword.com/">You can have fun using regular expressions on Regex Crossword <i class="far fa-smile-beam"></i>.</a></p>
</div>

<p>In the following video, we will formally define regular expressions and the languages they generate. We will also see how they are defined in
<code>ocamllex</code>.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/5VNKh7aaZ-g?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>The following video will give examples of regular expressions found in MiniJava and show some extensions of regular expressions.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/Wl8FXqv6dak?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h3 id="questions">Questions</h3>
<p>We will use the notation $\{a,b\}^*$ in the questions below: $\{a,b\}^*$ represents the language generated by the regular expression $\color{\green}{(a\ |\ b)^*}$.</p>
<hr>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the alphabet $\{a, b\}$. Give a regular expression to describe the language: $\{ w \in \{a, b\}^*\ |\ w$ contains the words $aa$ or $bb$ $\}$.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>A regular expression representing this language is as follows:
${\color{green}{(}}a\ {\color{green}{|}}\ b{\color{green}{)}}^{\color{green}{*}}{\color{green}{(}}aa\ {\color{green}{|}}\ bb{\color{green}{)}}{\color{green}{(}}a\ {\color{green}{|}}\ b{\color{green}{)}}^{\color{green}{*}}$</p>
<p>To test your regular expression, you can use the following <a href="https://regex-generate.github.io/regenerate/">site</a>, which allows you to generate words recognized by your regular expression,
and words that are not recognized.</p>

    </div>
</div>
<hr>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	This question, although one might think that it is very similar to the previous one, is not so easy. You can come back to this question after studying the next section on automata. Let&#39;s consider the alphabet $\{a, b\}$. Give a regular expression to describe the language: $\{ w \in \{a, b\}^*\ |\ w$ does not contain the words $aa$ or $bb\}$.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>Since you cannot have two $a$ or two $b$ following each other, you have to alternate $a$ and $b$. This is the idea behind the following regular expression.</p>
<p>${\color{green}{(}}ab{\color{green}{)}}^{\color{green}{*}}{\color{green}{(}}a\ {\color{green}{|}}\ \epsilon{\color{green}{)}}\ {\color{green}{|}}\ {\color{green}{(}}ba{\color{green}{)}}^{\color{green}{*}}{\color{green}{(}}b\ {\color{green}{|}}\ \epsilon{\color{green}{)}}$</p>
<p>Another regular expression representing the same language, which we obtained using techniques we will see in the next section, is given below.</p>
<p>$\epsilon\ {\color{green}{|}}\ a\ {\color{green}{|}}\ {\color{green}{(}}b\ {\color{green}{|}}\ ab{\color{green}{)}}{\color{green}{(}}ab{\color{green}{)}}^{\color{green}{*}}{\color{green}{(}}a\ {\color{green}{|}}\ \epsilon{\color{green}{)}}$</p>

    </div>
</div>
<hr>
<p>We want to move in the grid below using the two actions: &ldquo;go right&rdquo; and &ldquo;go up&rdquo;. We start from the lower left corner and
we want to get to the top right corner. A possible path is shown in the figure on the right.</p>
<figure><img src="/MrCoder/images/minijava/scanner/scanner_question_grid3_en.svg" width="600px" height="auto"/>
</figure>


<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Write a regular expression to describe all the actions that lead from the lower left corner to the upper right corner.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>This regular expression cannot be written succinctly without using extensions. We will have to list the different configurations.
The number of possibilities is the number of combinations of 3 elements among 6: ${{6}\choose{3}} = 20$. Indeed, it takes 6 actions to go from the start to the finish.
Among these 6 actions, 3 must go to the right and 3 must go up. So we are going to create a regular expression with 20 parts. We use <code>D</code> to go
to the right and <code>H</code> to the top.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-perl" data-lang="perl"><span style="display:flex;"><span>HHHDDD <span style="color:#f92672">|</span> HHDHDD <span style="color:#f92672">|</span> HHDDHD <span style="color:#f92672">|</span> HHDDDH <span style="color:#f92672">|</span> HDHHDD <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>HDHDHD <span style="color:#f92672">|</span> HDHDDH <span style="color:#f92672">|</span> HDDHHD <span style="color:#f92672">|</span> HDDHDH <span style="color:#f92672">|</span> HDDDHH <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>DHHHDD <span style="color:#f92672">|</span> DHHDHD <span style="color:#f92672">|</span> DHHDDH <span style="color:#f92672">|</span> DHDHHD <span style="color:#f92672">|</span> DHDHDH <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>DHDDHH <span style="color:#f92672">|</span> DDHHHD <span style="color:#f92672">|</span> DDHHDH <span style="color:#f92672">|</span> DDHDHH <span style="color:#f92672">|</span> DDDHHH</span></span></code></pre></div>
<p>We have generated the above combinations with the following program.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> string UP <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;H&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> string RIGHT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;D&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">combos</span>(<span style="color:#66d9ef">int</span> nH, <span style="color:#66d9ef">int</span> nD, string res)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nH <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>nD) {
</span></span><span style="display:flex;"><span>        cost <span style="color:#f92672">&lt;&lt;</span> res <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (nH) {
</span></span><span style="display:flex;"><span>        combos(nH <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, nD, res <span style="color:#f92672">+</span> TOP);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (nD) {
</span></span><span style="display:flex;"><span>        combos(nH, nD <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, res <span style="color:#f92672">+</span> RIGHT);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    combos(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>By using regular expressions extensions we can obtain the following more concise form.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-julia" data-lang="julia"><span style="display:flex;"><span><span style="color:#f92672">^</span>(<span style="color:#f92672">?!</span>(<span style="color:#f92672">.*</span>H<span style="color:#f92672">.*</span>){<span style="color:#ae81ff">4</span>}<span style="color:#f92672">|</span>(<span style="color:#f92672">.*</span>D<span style="color:#f92672">.*</span>){<span style="color:#ae81ff">4</span>})(H<span style="color:#f92672">|</span>D){<span style="color:#ae81ff">6</span>}<span style="color:#f92672">$</span></span></span></code></pre></div>
<p>In this expression, the operator <code>(?!(.*H.*){4}|(.*D.*){4})</code> expresses that one should not be able to find four <code>H</code> or four <code>D</code> down the line.
The expression <code>(H|D){6}</code> expresses that six characters must be recognized between <code>H</code> and <code>D</code>. It expresses that six characters must be recognized among <code>H</code> and <code>D</code>,
but we cannot find four <code>H</code> or four <code>D</code>. So we need to have exactly three <code>H</code> and three <code>D</code>.</p>

    </div>
</div>
<hr>
<p><a name="regular_expressions_q4"></a>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	This question is not too easy. You can come back to this question after studying the next section on automata. Let&#39;s consider the alphabet $\{a, b\}$. Give a regular expression to describe the language: $\{ w \in \{a, b\}^*\ |\ w$ contains an even number of $a\}$.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>A regular expression representing this language is as follows.</p>
<p>${\color{green}{(}}b\ {\color{green}{|}}\ ab^{\color{green}{*}}a{\color{green}{)}}^{\color{green}{*}}$</p>
<p>The $ab^{\color{\green}{*}}a$ part of the regular expression ensures that the number of $a$ is even. The word $\epsilon$ is not forgotten thanks to the iteration operator
on the whole alternative. The first part of the alternative, in conjunction with the iteration operator, allows you to put $b$ to the left or to the right
of the $ab^{\color{green}{*}}a$ part and also allows you to have only $b$.</p>
<p>Note that we obtained this regular expression using techniques from the following section by first going through an automaton.</p>

    </div>
</div></p>
<hr>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the alphabet $\{0, 1\}$. What is the language described by the following regular expression: $\color{green}{0^*10^*10^*(10^*\ |\ \epsilon)}$?
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>It describes the language containing two or three <code>1</code>.</p>

    </div>
</div>
<h2 id="automata">Automata</h2>
<p>In the previous section, we presented the regular expressions used to describe the so-called regular languages.
This notation is useful to describe regular languages, and we will use it to describe lexical units in the MiniJava lexical analyzer.
On the other hand, for recognition, i.e. to know whether a given word belongs to the language described by a regular expression, it is not easy to
use a regular expression directly.</p>
<p>We will now describe finite, non-deterministic and deterministic automata, which make it easier to answer the question of whether a given word
belongs to a given regular language. We will use these automata in the following section to build a software to test
effectively, if a given word belongs to the language generated by a given regular expression.</p>
<p>Note that the languages described by finite automata (non-deterministic or deterministic) are regular languages, regular expressions and the automata
are therefore two equivalent ways of describing the same languages.</p>
<h3 id="non-deterministic-finite-automata">Non-deterministic Finite Automata</h3>
<p>The following figure represents a non-deterministic finite automaton, which we will call $A_{ndf}$<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>, which describes C comments of type <code>/*...*/</code>.
To simplify, we assume that our vocabulary is $\mathcal{V} = \{ a, b, /, * \}$.
In this figure we can see the following:</p>
<ul>
<li>
<p><span style="color:green"><strong>states</strong></span>, the circles on the figure, numbered from <code>0</code> to <code>7</code> for this example.
You can see the <span style="color:green"><strong>starting state</strong></span> (or initial state), the <code>0</code> state, which has an arrow coming at it,
but which doesn&rsquo;t start from any state. The <code>7</code> state is an <span style="color:green"><strong>accepting state</strong></span> (or final state), it is represented by a double circle.</p>
</li>
<li>
<p><span style="color:green"><strong>transitions</strong></span> between states, the arrows on the figure. On the arrows, there are symbols
belonging to the vocabulary $\mathcal{V}$ or the symbol $\epsilon$. Note that on some transitions, for example the transition between state <code>3</code> and
state <code>2</code>, we put several symbols on the transition (on this transition there are the two symbols <code>a</code> and <code>b</code>).
Formally, we should have written two transitions instead of one, each with one of the two symbols, but doing as we did allows us to write the automaton more succinctly.</p>
</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments.svg" width="800px" height="auto"/>
</figure>

<p>The automaton will allow us to know if a word <code>m</code> constructed from the vocabulary $\mathcal{V}$ belongs to the language described by the automaton (we note this language $\mathcal{L}(A_{ndf})$).</p>
<p>Let&rsquo;s consider the word <code>/*/*/</code>, which we will call <code>m</code>, that belongs to $\mathcal{V}^*$.
How do we know if this word is described by the $A_{ndf}$ automaton?</p>
<p>We will start from the initial state, the state <code>0</code>, and we will follow the transitions,
character after character, looking for a path that leads us to the accepting state <code>7</code> after reading all the characters of the word <code>m</code>.</p>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments1_en.svg" width="600px" height="auto"/>
</figure>

<ul>
<li>Starting from state <code>0</code>, there is only one transition, so there is no choice. The word must therefore begin with <code>/</code>, because that is the symbol on that transition.
Once this transition is passed, we are in state <code>1</code> and we still have to analyze the <code>*/*/</code> part of <code>m</code>.</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments2_en.svg" width="600px" height="auto"/>
</figure>

<ul>
<li>Starting from state <code>1</code>, there is also only one possible transition. We must therefore have the symbol <code>*</code> in the remaining part <code>*/*/</code> of <code>m</code>,
because it is the symbol on the only transition from state <code>1</code>.
Once this transition is done, we are in state <code>2</code> and we still have to analyze the <code>/*/</code> part of <code>m</code>.</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments3_en.svg" width="600px" height="auto"/>
</figure>

<ul>
<li>The state <code>2</code> has three outgoing transitions. All three are labeled with the $\epsilon$ symbol. This symbol means that the input is not modified when
you go through such a transition. We can see now why the automaton is non-deterministic because on the same symbol, here $\epsilon$, we have the choice between several transitions.
How do we choose the transition to follow? We are going to assume for the moment that we have the skill of clairvoyance and that we are going
to choose the right transition, which is the one towards state <code>4</code>. We will see in the videos how to automate this.</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments4_en.svg" width="600px" height="auto"/>
</figure>

<ul>
<li>In state <code>4</code> we still have the choice between two transitions: we can choose not to consume a character in the input by taking the $\epsilon$ transition, or to consume the <code>/</code> character
by looping back to state <code>4</code>. As we are assuming that we can guess correctly, we will loop back to state <code>4</code> and consume the <code>/</code>.</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments5_en.svg" width="600px" height="auto"/>
</figure>

<ul>
<li>Now, the entry we have left to consume is <code>*/</code>. We will take the $\epsilon$ transition to state <code>2</code>, then the $\epsilon$ transition from state <code>2</code> to state <code>5</code>. Once again,
we do not worry for the moment about how to make the right transition choices when there is more than one possibility. We now find ourselves in the configuration below, where the cursor under the input string
has not moved.</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments6_en.svg" width="600px" height="auto"/>
 </figure>

<ul>
<li>In state <code>5</code>, we only have an outgoing transition on the <code>*</code> character. The cursor on the input is placed on the <code>*</code>, so we can
take this transition and move the cursor to the right. Now we just have to recognize the <code>/</code>.</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments7_en.svg" width="600px" height="auto"/>
 </figure>

<ul>
<li>In state <code>6</code>, there is also only one transition on the <code>/</code> symbol. Since the cursor on the input points to a <code>/</code> character, we can take this transition and move to
the accepting state <code>7</code>.</li>
</ul>
<figure><img src="/MrCoder/images/minijava/scanner/nfa_comments8_en.svg" width="600px" height="auto"/>
 </figure>

<ul>
<li>Since the input string is now empty and we are in an accepting state, we can conclude that the word <code>/*/*/</code> belongs to the $\mathcal{L}(A_{ndf})$ language.
The word <code>/*/*/</code> is therefore a comment.</li>
</ul>
<p>The input string <code>/*/*/</code> is accepted by our automaton, but how do we know if a string is not in the $\mathcal{L}(A_{ndf})$ language, that is to say
how do you know if the word is not accepted?
For a non-deterministic automaton, it must be shown that after reading all the characters of the input string, one cannot be in an accepting state.</p>

<div class="notices note" ><p>It seems easier to construct the non-deterministic finite automaton we have just seen to describe the language of comments than the regular expression
<em>$/*\color{darkgreen}{(}*^{\color{darkgreen}{+}}\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}\ \color{darkgreen}{|}\ \color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\ \color{darkgreen}{|}\ /\color{darkgreen}{)}\color{darkgreen}{)}^{\color{darkgreen}{*}}*^{\color{darkgreen}{+}}/$</em> that we saw in the <a href="/MrCoder/en/compiler/minijava/scanner/#regular_expressions">previous</a> section.
But you may be a <a href="https://fr.wikipedia.org/wiki/Perl_(language)">Perl</a>[^4] guru
and it&rsquo;s just too easy for you <i class="far fa-smile-beam"></i>.</p>
</div>

<p>In the two following videos, we will detail non-deterministic finite automata, and how to detect if a word belongs or not to the language generated by a non-deterministic finite automaton.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/rZGSM0vvz58?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/uJmyT-tE7dY?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>In the following video, we will show how to go from a regular expression to a non-deterministic finite automaton.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/KFqUYGvmAHA?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h4 id="questions-1">Questions</h4>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the alphabet $\{a, b\}$. Build an automaton that recognizes the following language: $\{ w \in \{a, b\}^*\ |\ w$ contains the word $aba\}$. For example, $aba$ is in the language, as well as $bbbbbaabaaaabb$, but not $babbbaaa$.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
         <figure><img src="/MrCoder/images/minijava/scanner/nfa_question1.svg" width="600px" height="auto"/>
 </figure>
<p>We can see that this automaton actually mimics the regular expression $\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{*}}aba\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{*}}$.</p>

    </div>
</div>
<hr>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the alphabet $\{a, b\}$. Construct an automaton that recognizes the language: $\{ w \in \{a, b\}^*\ |\ w$ does not contain the word $aba$ unless it is preceded by the word $bbb\}$. For example, $aaabbbaabaa$ is in the language, $abba$ is in the language, but not $bbabab$.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <figure><img src="/MrCoder/images/minijava/scanner/nfa_question2.svg" width="600px" height="auto"/>
</figure>
<p><a name="nfa_question2_states"></a></p>
<p>The upper part of the automaton, the states <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code>, is used to recognize a sequence of three <code>b</code> followed by anything.
The lower part of the automaton is used to recognize anything but <code>aba</code>.
The state <code>5</code> indicates that you haven&rsquo;t yet seen an <code>a</code> or that you&rsquo;ve just encountered a sequence ending in <code>bb</code> (so you&rsquo;re sure you haven&rsquo;t seen a sequence ending in <code>ab</code>).
The state <code>6</code> indicates that we are analyzing a sequence of at least one <code>a</code>
and state <code>7</code> that we just saw <code>ab</code>, so we must not have an <code>a</code> now.
From states <code>5</code>, <code>6</code> and <code>7</code> we can reach the upper part of the automaton because we have just analyzed a correct prefix and we may want to add <code>aba</code> in the following (adding <code>bbb</code> before).</p>
<p>How can we be sure that the lower part recognizes everything but <code>aba</code>? For the upper part, it is quite easy to convince yourself that it recognizes $bbb\color{darkgreen}{(}a\ \color{darkgreen}{|}\ b\color{darkgreen}{)}^{\color{darkgreen}{*}}$.
But it&rsquo;s not so easy to convince yourself that the bottom part describes everything but the <code>aba</code> chain. When you really want to be sure, there is only one way,
you have to make a proof! Sure, You can tell me that it still has to be correct. You are right <i class="far fa-smile-beam"></i>, but in a proof you just have to
convince yourself that every elementary step is correct.</p>
<p>We will do a proof by induction on the length of the input string. For a string of length 0 ($\epsilon$) of length 1 ($a$ and $b$) and of length 2 ($aa$, $ab$, $ba$ and $bb$), we can follow the transitions
from state <code>0</code> to the lower part and see that they are all recognized and they do not have <code>aba</code> in them (because the string length is less than or equal to 2). Suppose
that the property holds for strings of length $n \ge 2$, is it still true for strings of length $n + 1$? Let&rsquo;s look at the last two characters of the string <code>m</code> of length $n$.</p>
<ul>
<li>
<p><code>m</code> ends with <code>aa</code>. In this case we must be in state <code>6</code> <a href="/MrCoder/en/compiler/minijava/scanner/#nfa_question2_states">as shown above</a>. We can add an <code>a</code> and accept
the new <code>ma</code> string because we stay in state <code>6</code> which is an accepting state, and we can also add a <code>b</code> and accept the <code>mb</code> string because we are in state <code>7</code> which is also an accepting state.</p>
</li>
<li>
<p><code>m</code> ends with <code>ab</code>. In this case we must be in state <code>7</code> <a href="/MrCoder/en/compiler/minijava/scanner/#nfa_question2_states">as indicated above</a>. You cannot add an <code>a</code> because there is no transition on the character <code>a</code>
from state <code>7</code> and therefore a string containing <code>aba</code> will not be recognized. However, you can add a <code>b</code> and still recognize the string of length $n+1$ <code>mb</code>.</p>
</li>
<li>
<p><code>m</code> ends with <code>ba</code>. In this case we must be in state <code>6</code> <a href="/MrCoder/en/compiler/minijava/scanner/#nfa_question2_states">as indicated above</a> and we can add an <code>a</code> or a <code>b</code> to get the
strings of length $n+1$ <code>ma</code> or <code>mb</code>.</p>
</li>
<li>
<p><code>m</code> ends with <code>bb</code>. In this case we must be in state <code>5</code> <a href="/MrCoder/en/compiler/minijava/scanner/#nfa_question2_states">as above</a> and we can add an <code>a</code> or <code>b</code> to get the
strings of length $n+1$ <code>ma</code> or <code>mb</code>.</p>
</li>
</ul>
<p>So assuming that we can generate all words of length $n$ not containing <code>aba</code>, we have just shown that we can generate all words of length $n+1$ not containing <code>aba</code>.</p>

    </div>
</div>
<h3 id="deterministic-finite-automata">Deterministic Finite Automata</h3>
<p>Deterministic finite automata are a subset of the non-deterministic finite automata. The advantage of these automata is that they no longer need to
&ldquo;guess&rdquo; the right transition to follow because, in a given state and for a given symbol of the input, there is at most one possible transition. As we have seen
in the previous section, we can actually use a non-deterministic automaton without the need to guess. The algorithm we have seen actually allows us to dynamically construct
a deterministic finite automaton. The advantage of starting directly from a deterministic automaton is that one does not need to reconstruct it each time.
This will be all the more interesting for a lexical analyser because the regular expressions used to describe the lexical units will not change
and we will gain efficiency by building once and for all the automata corresponding to the regular expressions.</p>
<p>The following automaton is a
deterministic version of the non-deterministic automaton that recognizes the multiline comments in <code>C</code> in the previous section.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_comments.svg" width="800px" height="auto"/>
</figure>

<p>Since deterministic finite automata are a restriction of non-deterministic finite automata, one could rightly believe that they allow us to describe fewer languages.
In fact this is not the case and they are as powerful as non-deterministic finite automata.</p>
<p>The video below will describe deterministic finite automata and show how to transform a non-deterministic automaton into a deterministic one.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/hOAbe3TbdJ0?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>The code used in the previous video is available <a href="https://gist.github.com/lascar-pacagi/e2ac6243986672d9c85a839f26eadc52">here</a>.</p>
<p>In the following video, we will show how a lexical analyzer works and how to obtain a deterministic finite automaton of minimal size.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/WMsfcjieU9s?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p><a name="dfa_lexer_cpp"></a>
In the following videos, we will code in <a href="https://isocpp.org/">C++</a> a lexical analyzer for the small language fragment described in the previous video.
The code used in these videos is available <a href="https://gist.github.com/lascar-pacagi/a98b218c00eb446c8294b2683866ed56">here</a>.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/F8oztkX3e6E?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/BSBK5s-q9qU?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/LhxurDuCNls?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h4 id="questions-2">Questions</h4>
<p><a name="dfa_question2_1"></a>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the alphabet $\{a, b\}$. Construct an automaton that recognizes the language: $\{ w \in \{a, b\}^*\ |\ w$ contains an odd number of $a$ and an even number of $b \}$. For example, $abb$ is in the language, as well as $bbabbaa$ and $aaaa$, but not $b$ nor $aabb$.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <figure><img src="/MrCoder/images/minijava/scanner/dfa_question1.en.svg" width="500px" height="auto"/>
</figure>
<p>In the above automaton, each state represents a possible configuration of the parity of the $a$ and $b$. For example, the accepting state $OE$ indicates that we have encountered
an odd number of $a$ and an even number of $b$. The starting state $EE$ indicates that we saw an even number of $a$ and $b$ which is true at the very beginning as well, because then we did not meet any
$a$ and $b$.</p>

    </div>
</div></p>
<hr>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the regular expression $\color{darkgreen}{0^*(100^*)^*(1|\epsilon)}$ that describes the bit strings on the alphabet $\{0, 1\}$ not containing the substring $11$. Transform this regular expression into a non-deterministic finite automaton, then transform it into a deterministic finite automaton and finally minimize it.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>The transformation of the regular expression into a non-deterministic finite automaton gives the following automaton. Note that we have taken some liberties with the transformations that
we had seen in the video to reduce the size of the automaton a little bit, but the resulting automaton is very similar to what we had seen.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_question2_1.svg" width="1000px" height="auto"/>
</figure>
<p>The corresponding deterministic finite automaton (using the transformation we have seen) is given below.</p>
<p><a name="dfa_question2_2"></a></p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_question2_2.svg" width="650px" height="auto"/>
</figure>
<p>In this automaton, for example, the state $0$ corresponds to the set of states $\{0,1,3,4,10,11\}$ of the non-deterministic finite automaton and the state $4$ corresponds to
the set $\{8,7,9,4,10,11\}$.</p>
<p>Now we just need to minimize that automaton. First, we will make explicit the dead state that we are going to denote by <code>D</code>,
which is implicit in the <a href="/MrCoder/en/compiler/minijava/scanner/#dfa_question2_2">figure</a> above representing the deterministic automaton.
It is the state that is reached on a transition that is not indicated in the automaton of the above <a href="/MrCoder/en/compiler/minijava/scanner/#dfa_question2_2">figure</a>.
If we make this state explicit, we get the following equivalent automaton:</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_question2_2_dead.svg" width="650px" height="auto"/>
</figure>
<p>We will first consider the two sets of states that we can immediately distinguish: the terminal states
and non-terminal states. This gives us the following two groups.</p>
<ul>
<li>$G_1 = \{0,1,2,3,4\}$</li>
<li>$G_2 = \{D\}$</li>
</ul>
<p>For the $G_1$ group, the states $0,1,3$ and $4$ have a transition to one of the $G_1$ group states on a <code>0</code> or <code>1</code>. On the other hand, state $2$ have a transition
to the $G_2$ group on a <code>1</code>. So the group $G_1$ will have to be split. The group $G_2$ has only one element, so it remains unchanged.
We now get the next three groups.</p>
<ul>
<li>$G_{1,1} = \{0,1,3,4\}$</li>
<li>$G_{1,2} = \{2\}$</li>
<li>$G_2 = \{D\}$</li>
</ul>
<p>In the group $G_{1,1}$, we have</p>
<ul>
<li>$0 \xrightarrow[]{0} G_{1,1}$</li>
<li>$1 \xrightarrow[]{0} G_{1,1}$</li>
<li>$3 \xrightarrow[]{0} G_{1,1}$</li>
<li>$4 \xrightarrow[]{0} G_{1,1}$</li>
<li>$0 \xrightarrow[]{1} G_{1,2}$</li>
<li>$1 \xrightarrow[]{1} G_{1,2}$</li>
<li>$3 \xrightarrow[]{1} G_{1,2}$</li>
<li>$4 \xrightarrow[]{1} G_{1,2}$</li>
</ul>
<p>The $G_{1,1}$ state does not need to be split any further because the transitions on <code>0</code> and <code>1</code> make each of the states of
$G_{1,1}$ reach the same group. There is no more groups that can be split, so we are done minimizing. The states $0$, $1$, $3$ and $4$ will
so be grouped together in one state. The automaton obtained after minimization is given below (we do not show the dead state).</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_question2_3.svg" width="400px" height="auto"/>
</figure>
<p>If we interpret this automaton, we can see that state $0$ indicates that we have just seen a zero, or that we have not yet read anything.
As for state $2$, it indicates that we have just encountered a $1$.</p>

    </div>
</div>
<h4 id="transformation-from-an-automaton-to-a-regular-expression">Transformation from an Automaton to a Regular Expression</h4>
<p>We can automatically construct the regular expression corresponding to a finite automaton (deterministic or non-deterministic).
We show below a series of transformations to go from the deterministic finite automaton corresponding to the comments in C seen above,
to an equivalent regular expression. We will detail this transformation in the video below.</p>
<p>We can see, on the transitions, regular expressions appearing as the transformation progress. In order not to confuse the <code>*</code> character with the operator
<span style="color:green">*</span>, we write the operator in green.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_comments.svg" width="800px" height="auto"/>
</figure>

<p>First of all, we will rewrite the automaton by making clear the regular expressions representing the alternatives on the transitions.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_comments_to_regex0.svg" width="800px" height="auto"/>
</figure>

<p>We are now going to eliminate one state at a time to arrive at an automaton containing only two states: the initial state and the accepting state.</p>
<p>To eliminate the state $q = \{3,5,6\}$, for each pair of states $(q_1, q_2)$, if there is an arc
between $q_1$ and $q$ and between $q$ and $q_2$, we need to keep this information by modifying the arc between $q_1$ and $q_2$ accordingly.</p>
<p>For example, here, we will have to consider the path $\{2,3,4,5\} \rightarrow q \rightarrow \{7\}$ and add the regular expression
$**^{\color{darkgreen}{*}}/$
between the states $\{2,3,4,5\}$ and $\{7\}$ to keep the same information.
We also need to consider the $\{2,3,4,5\} \rightarrow q \rightarrow \{2,3,4,5\}$ path
and add the regular expression
$**^{\color{darkgreen}{*}}{\color{darkgreen}{(}}a\mbox{ }{\color{darkgreen}{|}}\mbox{ }b{\color{darkgreen}{)}}$
on the loop on state $\{2,3,4,5\}$.
We then get the following automaton.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_comments_to_regex1.svg" width="800px" height="auto"/>
</figure>

<p>By eliminating the state $\{2,3,4,5\}$ we get the next automaton.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_comments_to_regex2.svg" width="800px" height="auto"/>
</figure>

<p>And finally, by eliminating state $\{1\}$, we get the final regular expression on the arc connecting the initial state
to the accepting state.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_comments_to_regex3.svg" width="800px" height="auto"/>
</figure>

<p>The following video will detail this construction.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/kO5ejPkHPCk?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>The next videos will detail a program in OCaml to transform an automaton into a regular expression using the <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall</a> algorithm.</p>
<p>The following video presents the Floyd-Warshall transitive closure algorithm on a graph to present the concepts more simply before moving on to the next video
to the automatic creation of a regular expression from an automaton. The code presented in the video can be found <a href="https://gist.github.com/lascar-pacagi/593a5d40ccda8e908628ada1013c8d13">here</a>.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/5jj2Lp8EbPI?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>The following video describes the code that can transform an automaton into a regular expression. The code can be found <a href="https://gist.github.com/lascar-pacagi/02fe4e05b97b5fd5d8efa89c9c2ebf33">here</a>,
and the little python script that transforms our representation into the expected one
on this <a href="https://cyberzhg.github.io/toolbox/min_dfa">site</a> can be found <a href="https://gist.github.com/lascar-pacagi/0a3e184568256c45d19b040c6912fd44">here</a>.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/OfFBAvJiunc?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h4 id="questions-3">Questions</h4>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the alphabet $\{a, b\}$. Find a deterministic automaton that describes the language: $\{ w \in \{a, b\}^*\ |\ w$ contains an even number of $a\}$. Then transform this automaton into a regular expression.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>We had already seen this language in the section on regular expressions in this <a href="/MrCoder/en/compiler/minijava/scanner/#regular_expressions_q4">question</a>.</p>
<p>The following automaton describes the language, on the vocabulary $\{a, b\}$, where the number of $a$ is even.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q1_1.svg" width="500px" height="auto"/>
</figure>
<p>The different steps of the transformation are given below.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q1_2.svg" width="650px" height="auto"/>
</figure>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q1_3.svg" width="350px" height="auto"/>
</figure>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q1_4.svg" width="350px" height="auto"/>
</figure>
<p>So we get the regular expression ${\color{darkgreen}{(}}b\ {\color{darkgreen}{|}}\ ab^{\color{darkgreen}{*}}a{\color{darkgreen}{)}}^{\color{darkgreen}{*}}$.
This is the answer to this <a href="/MrCoder/en/compiler/minijava/scanner/#regular_expressions_q4">question</a>. That is not surprising, because we did
the same thing as we did here to obtain the regular expression <i class="far fa-smile-beam"></i>.</p>

    </div>
</div>
<hr>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Let&#39;s consider the alphabet $\{a, b\}$. Find a deterministic automaton to describe the language: $\{ w \in \{a, b\}^*\ |\ w$ does not contain an odd number of $a$ or does not contain an even number of $b\}$. Then, transform this automaton into a regular expression. Note that this language is complementary to the language $\{ w \in \{a, b\}^*\ |\ w$ contains an odd number of $a$ and an even number of $b\}$ that we have already seen.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>The following automaton represents this language. Note that this automaton is the automaton we met in this <a href="/MrCoder/en/compiler/minijava/scanner/#dfa_question2_1">question</a>
with the accepting states becoming normal states and normal states becoming accepting states.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q2_1.en.svg" width="500px" height="auto"/>
</figure>
<p>The different steps of the transformation are given below.</p>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q2_2.en.svg" width="550px" height="auto"/>
</figure>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q2_3.en.svg" width="600px" height="auto"/>
</figure>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q2_4.en.svg" width="650px" height="auto"/>
</figure>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q2_5.en.svg" width="600px" height="auto"/>
</figure>
<figure><img src="/MrCoder/images/minijava/scanner/dfa_to_regex_q2_6.en.svg" width="600px" height="auto"/>
</figure>
<p>The regular expression produced is therefore the following.</p>
<p>${\color{darkgreen}{(}}aa\ {\color{darkgreen}{|}}\ bb\ {\color{darkgreen}{|}}\ {\color{darkgreen}{(}}ab\ {\color{darkgreen}{|}}\ ba{\color{darkgreen}{)}}{\color{darkgreen}{(}}bb\ {\color{darkgreen}{|}}\ aa{\color{darkgreen}{)}}^{\color{darkgreen}{*}}{\color{darkgreen}{(}}ba\ {\color{darkgreen}{|}}\ ab{\color{darkgreen}{)}}{\color{darkgreen}{)}}^{\color{darkgreen}{*}}{\color{darkgreen}{(}}\epsilon\ {\color{darkgreen}{|}}\ b\ {\color{darkgreen}{|}}\ {\color{darkgreen}{(}}ab\ {\color{darkgreen}{|}}\ ba{\color{darkgreen}{)}}{\color{darkgreen}{(}}bb\ {\color{darkgreen}{|}}\ aa{\color{darkgreen}{)}}^{\color{darkgreen}{*}}{\color{darkgreen}{(}}\epsilon\ {\color{darkgreen}{|}}\ a{\color{darkgreen}{)}}{\color{darkgreen}{)}}$</p>
<p>To check that we did not make any errors during the transformation, we can use the <a href="https://cyberzhg.github.io/toolbox/min_dfa">following</a> site and transform the regular expression
to a minimal deterministic automaton to see if we can recognize our automaton. If you do this, you will see that you get the same automaton (with different state names).</p>

    </div>
</div>
<h2 id="regular-expressions-matching">Regular Expressions Matching</h2>
<p>We are going to put into practice the notions we have just seen about regular expressions and automata by making a small application to test
whether or not a string matches a pattern represented by a regular expression.</p>
<p>We will present a sequence of interactions in the OCaml interpreter that we will be able to do with this application.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span>utop <span style="color:#f92672">#</span> <span style="color:#66d9ef">let</span> re <span style="color:#f92672">=</span> RE.regex_from_string <span style="color:#e6db74">&#34;0*(100*)*1?&#34;</span><span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span><span style="color:#66d9ef">val</span> re <span style="color:#f92672">:</span> RE.regex <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>  RE.<span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">ZeroOrMore</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;),</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span><span>   RE.<span style="color:#a6e22e">Concatenation</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span><span>    <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">ZeroOrMore</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span><span>      <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;,</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span><span>        RE.<span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;,</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span><span>         RE.<span style="color:#a6e22e">ZeroOrMore</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;)))),</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9</span><span>    RE.<span style="color:#a6e22e">ZeroOrOne</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;)))</span></span></span></code></pre></div>
<p>On line 1, we create the regular expression $\color{darkgreen}{0^*(100^*)^*(1|\epsilon)}$ which allows us to describe the words that do not contain consecutive <code>1</code>.
Note that we use the notation <code>1?</code> to represent $\color{darkgreen}{(1|\epsilon)}$.</p>
<p>We then create an equivalent non-deterministic finite automaton.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>utop <span style="color:#f92672">#</span> <span style="color:#66d9ef">let</span> nfa <span style="color:#f92672">=</span> NFA.init re<span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> nfa <span style="color:#f92672">:</span> NFA.t <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;</span></span></span></code></pre></div>
<p>We can then test if a string, here <code>101010</code>, belongs or not to the language generated by the non-deterministic finite automaton and thus by the regular expression.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>utop <span style="color:#f92672">#</span> NFA.full_match nfa <span style="color:#e6db74">&#34;101010&#34;</span><span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> true</span></span></code></pre></div>
<p>We can see in the following example, that the string <code>011111100100</code>, containing consecutive <code>1</code>, does not match the regular expression.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>utop <span style="color:#f92672">#</span> NFA.full_match nfa <span style="color:#e6db74">&#34;011111100100&#34;</span><span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> false</span></span></code></pre></div>
<p>We can test if a substring is in a given string by surrounding an expression with <code>.*</code>. The <code>.</code> represents any character.
The following example will define a regular expression to search for the substring <code>Doc</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>utop <span style="color:#f92672">#</span> <span style="color:#66d9ef">let</span> re <span style="color:#f92672">=</span> RE.regex_from_string <span style="color:#e6db74">&#34;.*Doc.*&#34;</span><span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> re <span style="color:#f92672">:</span> RE.regex <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>  RE.<span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">ZeroOrMore</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;),</span>
</span></span><span style="display:flex;"><span>   RE.<span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;,</span>
</span></span><span style="display:flex;"><span>    RE.<span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;,</span>
</span></span><span style="display:flex;"><span>     RE.<span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;,</span> RE.<span style="color:#a6e22e">ZeroOrMore</span> <span style="color:#f92672">(</span>RE.<span style="color:#a6e22e">CharSet</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;)))))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>utop <span style="color:#f92672">#</span> <span style="color:#66d9ef">let</span> dfa <span style="color:#f92672">=</span> DFA.init re<span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> dfa <span style="color:#f92672">:</span> DFA.t <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;</span>abstr<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>utop <span style="color:#f92672">#</span> DFA.full_match dfa <span style="color:#e6db74">&#34;Wait a minute, Doc. Ah... Are you telling me that you built a time machine... out of a DeLorean?&#34;</span><span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>utop <span style="color:#f92672">#</span> DFA.full_match dfa <span style="color:#e6db74">&#34;The way I see it, if you&#39;re gonna build a time machine into a car, why not do it with some style?&#34;</span><span style="color:#f92672">;;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">=</span> false</span></span></code></pre></div>
<p>The code that will be explained in the following videos can be found <a href="https://github.com/lascar-pacagi/regex">here</a>.</p>
<p>In the following video, we will present an overview of the application and detail the code to go from a string representing a
regular expression to an OCaml representation of this regular expression.
The grammar describing regular expressions can be found <a href="images/minijava/scanner/regex.xhtml">here</a>.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/kZuPXP06OOQ?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>In the following video, we present the notion of <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">programming with continuation</a>
that we will use in conjonction with backtracking in the pattern recognition module.
The code to illustrate continuations can be found <a href="https://gist.github.com/lascar-pacagi/4c945c43c8f5e010aacd3635d203cec7">here</a>.</p>

<div class="notices warning" ><p>There is the solution to one of the questions we ask in the video at the end of the listing on continuations.</p>
</div>



    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/utqHa9ESDCw?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>In the following video, we will describe the pattern recognition module based on backtracking and continuations.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/JQ-8s5u5E4U?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>In the following video, we will describe the pattern recognition module based on non-deterministic finite automata.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/5wPEbAWMDUU?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>In the following video, we will describe the pattern recognition module based on deterministic finite automata.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/gO5UsU0mijM?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>In the following video, we will show how we have tested our different modules.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/DYnRo6TOhA0?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h3 id="questions-4">Questions</h3>
<p>The code below describes the part of the <code>regex_from_string</code> function that handles concatenations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#f92672">and</span> re1 l <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>  <span style="color:#66d9ef">let</span> e<span style="color:#f92672">,</span> l <span style="color:#f92672">=</span> re2 l <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>  <span style="color:#66d9ef">let</span> e<span style="color:#f92672">,</span> l <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> re1&#39; e l <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>      <span style="color:#66d9ef">match</span> l <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;?&#39;</span> <span style="color:#f92672">::</span> r <span style="color:#f92672">-&gt;</span> re1&#39; <span style="color:#f92672">(</span><span style="color:#a6e22e">ZeroOrOne</span> e<span style="color:#f92672">)</span> r
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">::</span> r <span style="color:#f92672">-&gt;</span> re1&#39; <span style="color:#f92672">(</span><span style="color:#a6e22e">ZeroOrMore</span> e<span style="color:#f92672">)</span> r
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>      <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">::</span> r <span style="color:#f92672">-&gt;</span> re1&#39; <span style="color:#f92672">(</span><span style="color:#a6e22e">OneOrMore</span> e<span style="color:#f92672">)</span> r
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>      <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> e<span style="color:#f92672">,</span> l
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>    <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>    re1&#39; e l
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>  <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>  <span style="color:#66d9ef">match</span> l <span style="color:#66d9ef">with</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>  <span style="color:#f92672">|</span> c <span style="color:#f92672">::</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">when</span> c <span style="color:#f92672">&lt;&gt;</span> <span style="color:#e6db74">&#39;)&#39;</span> <span style="color:#f92672">&amp;&amp;</span> c <span style="color:#f92672">&lt;&gt;</span> <span style="color:#e6db74">&#39;|&#39;</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>     <span style="color:#66d9ef">let</span> e&#39;<span style="color:#f92672">,</span> l <span style="color:#f92672">=</span> re1 l <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>     <span style="color:#a6e22e">Concatenation</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">,</span> e&#39;<span style="color:#f92672">),</span> l
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>     e<span style="color:#f92672">,</span> l</span></span></code></pre></div>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	During the video, we said that there were two cases to handle to see if there were no new concatenations. To do so, we test on line 17 if the next character is a vertical bar or the closing parenthesis but there is another case, which the code handles well, but which we have not talked about. What is this other case?
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>If there are no more characters, i.e. if the list <code>l</code> is empty on line 13, there is no more possible concatenation.
We take care of this case on line 17, because the test on line 14 requires at least one character to be successful.</p>

    </div>
</div>
<hr>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	For the backtracking pattern matching module, we saw that for the regular expression $\color{green}{(a?)^{40}a^{40}}$ (the superscript 40 indicates that the string is repeated forty times) and the input string $a^{40}$ we got a prohibitive execution time. Can you find another regular expression and another input string that would also result in a very long execution time?
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>For example, the regular expression $\color{green}{a^{++}}$ results in a prohibitive execution time on the input string <code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab</code>.</p>
<p>How to explain this behaviour?</p>
<p>We can visualize the regular expression $\color{green}{(a^+)^+}$ as the following hypothetical regular expression
$\color{green}{aa^*\ |\ aa^*aa^* \ |\ aa^*aa^*aa^*\ |\ aa^*aa^*aa^*aa^*\ |\ \cdots}$. If we take the subexpression $\color{\green}{aa^*aa^*}$, the
first $\color{green}{aa^*}$ will first consume all the <code>a</code> and the second $\color{green}{aa^*}$ will then fail because there is a <code>b</code> in the input. Now,
the first $\color{\green}{aa^*}$ will leave only one <code>a</code> and the second will consume the last one and we will fail because there is still one <code>b</code> left in the input when we are done.
Now, the first $\color{green}{aa^*}$ will leave two <code>a</code> in the input and the second $\color{green}{aa^*}$ will consume
the last two and fail, then one and fail too. So, the first $\color{green}{aa^*}$ will leave three <code>a</code> in the input and the second $\color{green}{aa^*}$
will first consume all three <code>a</code> and fail, then try to consume only two <code>a</code> and fail, then only one <code>a</code> and fail as well. And now, the first
$\color{\green}{aa^*}$ will leave four <code>a</code> and so on. The number of attempts is going to be even greater with the
subexpression $\color{green}{aa^*aa^*aa^*}$.</p>
<p>Note that in our implementation of the <code>Backtracking</code> module, we have the following code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">ZeroOrMore</span> t1 <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>  full_match t1 l <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> l&#39; <span style="color:#f92672">-&gt;</span> l <span style="color:#f92672">&lt;&gt;</span> l&#39; <span style="color:#f92672">&amp;&amp;</span> full_match t l&#39; k<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>  <span style="color:#f92672">||</span> k l</span></span></code></pre></div>
<p>Switching the lines
<code>2</code> and <code>3</code> as below still gives rise to a prohibitive amount of time contrary to the expression
$\color{green}{(a?)^{40}a^{40}}$ and the input string $a^{40}$ when we did the same inversion for <code>ZeroOrOne t1</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span><span style="color:#f92672">|</span> <span style="color:#a6e22e">ZeroOrMore</span> t1 <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span><span>  k l
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span><span>  <span style="color:#f92672">||</span> full_match t1 l <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> l&#39; <span style="color:#f92672">-&gt;</span> l <span style="color:#f92672">&lt;&gt;</span> l&#39; <span style="color:#f92672">&amp;&amp;</span> full_match t l&#39; k<span style="color:#f92672">)</span></span></span></code></pre></div>

    </div>
</div>
<hr>
<p>In our <code>DFA</code> module, we memoized the transitions already seen thanks to the <code>Memo</code> module whose definition is given below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Memo</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>  Map.<span style="color:#a6e22e">Make</span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>      <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>        <span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> S.t <span style="color:#f92672">*</span> <span style="color:#66d9ef">char</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>        <span style="color:#66d9ef">let</span> compare <span style="color:#f92672">(</span>s1<span style="color:#f92672">,</span> c1<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>s2<span style="color:#f92672">,</span> c2<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>          <span style="color:#66d9ef">let</span> res <span style="color:#f92672">=</span> compare c1 c2 <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>          <span style="color:#66d9ef">if</span> res <span style="color:#f92672">=</span> 0 <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>            S.compare s1 s2
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>          <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>            res
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>      <span style="color:#66d9ef">end</span><span style="color:#f92672">)</span></span></span></code></pre></div>
<p>The key comparison function in this table, defined from line <code>5</code> to line <code>10</code>, may require to compare sets on line <code>8</code>.<br>
When one is in a given state of the deterministic finite automaton, it is sufficient to look whether the transition on a particular character has already
been seen. There is therefore no need to compare sets and to have for each transition from the same state,
a key that contains a state and a character.<br>
To avoid creating a table that requires a pair of state and character as a key, one should associate to each state of the deterministic finite automaton (which is
a set of states of the non-deterministic finite automaton) a table.
The keys of this table will be characters, and the table will allow to store the transitions already encountered.<br>
The new module that we want to realize is the following.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">DFA2</span> <span style="color:#f92672">:</span> <span style="color:#a6e22e">Matching</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">(* TO DO *)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span></span></span></code></pre></div>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Your mission, if you choose to accept it, is to code the module to implement our new idea.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>A possible solution can be found <a href="https://gist.github.com/lascar-pacagi/00d4c601efb5ef7c96cdce56785dceca">here</a>. The file to test this new
module can be found <a href="https://gist.github.com/lascar-pacagi/d8cdf22311a08e724a0da7d9365cfbb4">here</a>.</p>

    </div>
</div>
<h2 id="lexical-analyzer-with-ocamllex">Lexical Analyzer with Ocamllex</h2>
<p>We will now describe the MiniJava lexical analyzer (or scanner) which is created using <a href="https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html#sec319">ocamllex</a>.
The tool <code>ocamllex</code> is a lexical analyzer generator. You give it a list of regular expressions with actions to perform when a regular expression is recognized.
The tool will then automatically generate a lexical analyzer that looks roughly like the <a href="https://gist.github.com/lascar-pacagi/a98b218c00eb446c8294b2683866ed56">lexer.cpp</a> program
that have we studied <a href="/MrCoder/en/compiler/minijava/scanner/#dfa_lexer_cpp">above</a>.</p>
<p>The following program shows a MiniJava program, <code>Lexical.java</code>, which is invalid, but is nevertheless lexically correct.
<a name="lexical_prog"></a>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">/*/*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">public</span> 123MrC00der;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> )(
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>int42
</span></span><span style="display:flex;"><span><span style="color:#f92672">[]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span> <span style="color:#66d9ef">this</span> sentence is <span style="color:#66d9ef">false</span></span></span></code></pre></div></p>
<p>If we execute the command <code>./mini-java --show-tokens-with-loc Lexical.java</code> to run our <code>mini-java</code> transpiler with the option to output only the tokens produced by
the lexical analyzer, we obtain the following tokens<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>CLASS
</span></span><span style="display:flex;"><span>PUBLIC
</span></span><span style="display:flex;"><span>INT_CONST ‚Äò123‚Äò
</span></span><span style="display:flex;"><span>IDENT ‚ÄòMrC00der‚Äò ‚ñ∏ line 3, char <span style="color:#ae81ff">11</span> ‚óÇ
</span></span><span style="display:flex;"><span>SEMICOLON
</span></span><span style="display:flex;"><span>WHILE
</span></span><span style="display:flex;"><span>RPAREN
</span></span><span style="display:flex;"><span>LPAREN
</span></span><span style="display:flex;"><span>LBRACE
</span></span><span style="display:flex;"><span>INTEGER
</span></span><span style="display:flex;"><span>IDENT ‚Äòint42‚Äò ‚ñ∏ line 6, char <span style="color:#ae81ff">1</span> ‚óÇ
</span></span><span style="display:flex;"><span>LBRACKET
</span></span><span style="display:flex;"><span>RBRACKET
</span></span><span style="display:flex;"><span>EOF</span></span></code></pre></div>
<p>The tokens will be used by the syntax analyzer that we will study in the next chapter.</p>
<p>The following video will introduce <code>ocamllex</code> and describe the lexical analyzer of our transpiler. The code of the calculator in <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a> can be found
<a href="https://gist.github.com/lascar-pacagi/d16ad415913e5546ab0049595596f1f8">here</a>.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/246sQu7ty00?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h3 id="questions-5">Questions</h3>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Suppose that in the lexical analyzer, the longest matching rule (the regular expression that matches the maximum number of characters is selected) is not used, but instead, the shortest matching rule is used. Why cannot we correctly recognize the tokens of MiniJava?
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>We can try this by modifying the <code>lexer.mll</code> file of our transpiler using the shortest matching rule option. We then replace the line</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>rule get_token <span style="color:#f92672">=</span> parse</span></span></code></pre></div>
<p>with the line</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>rule get_token <span style="color:#f92672">=</span> shortest</span></span></code></pre></div>
<p>Now let&rsquo;s consider again the example we saw <a href="/MrCoder/en/compiler/minijava/scanner/#lexical_prog">above</a>. If we recompile our transpiler and execute the command below,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./mini-java --show-tokens-with-loc Lexical.java</span></span></code></pre></div>
<p>we get the following output.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>IDENT ‚Äòc‚Äò ‚ñ∏ line 1, char <span style="color:#ae81ff">1</span> ‚óÇ
</span></span><span style="display:flex;"><span>IDENT ‚Äòl‚Äò ‚ñ∏ line 1, char <span style="color:#ae81ff">2</span> ‚óÇ
</span></span><span style="display:flex;"><span>IDENT ‚Äòa‚Äò ‚ñ∏ line 1, char <span style="color:#ae81ff">3</span> ‚óÇ
</span></span><span style="display:flex;"><span>IDENT ‚Äòs‚Äò ‚ñ∏ line 1, char <span style="color:#ae81ff">4</span> ‚óÇ
</span></span><span style="display:flex;"><span>IDENT ‚Äòs‚Äò ‚ñ∏ line 1, char <span style="color:#ae81ff">5</span> ‚óÇ
</span></span><span style="display:flex;"><span>Lexical error file <span style="color:#e6db74">&#34;Lexical.java&#34;</span>, line 2, character 1:
</span></span><span style="display:flex;"><span>Illegal character: /.</span></span></code></pre></div>
<p>Our lexical analyzer, with the shortest matching rule, recognizes each character of the keyword <code>class</code> as an identifier. When it gets to the <code>/</code>, the first character of the multiline comment,
it cannot recognize an identifier, so it moves on to the next rule for matching a single character, which is the rule below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#66d9ef">as</span> c  <span style="color:#f92672">{</span> <span style="color:#66d9ef">raise</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">Error</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal character: &#34;</span> <span style="color:#f92672">^</span> String.make 1 c<span style="color:#f92672">))</span> <span style="color:#f92672">}</span></span></span></code></pre></div>

    </div>
</div>
<hr>
<p>We want to write a program, using <code>ocamllex</code>, that replaces tabulations by four spaces and removes spaces
and tabulations just before the end of line. For example, suppose we have a <code>file.txt</code> file whose content is shown below using
the unix <code>cat</code> command to display tabulations, represented by <code>^I</code>, and line breaks represented by <code>$</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat -ET file.txt
</span></span><span style="display:flex;"><span>    I wish you^I ^I$
</span></span><span style="display:flex;"><span> a very happy new^I^I year^I  $
</span></span><span style="display:flex;"><span>          ^I$
</span></span><span style="display:flex;"><span>$</span></span></code></pre></div>
<p>If the <code>ocamllex</code> file is called <code>clean.mll</code>, it is compiled as shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ocamllex clean.mll
</span></span><span style="display:flex;"><span>ocamlopt clean.ml -o clean</span></span></code></pre></div>
<p>We will then use the <code>clean</code> program on a <code>file.txt</code> file, for example, as follows.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./clean &lt; fichier.txt &gt; res.txt</span></span></code></pre></div>
<p>We will then get in the <code>res.txt</code> file, the contents of the <code>file.txt</code> file where the tabulations have been transformed into four spaces, and where
the spaces and tabulations right before the end of line have been removed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat -ET res.txt
</span></span><span style="display:flex;"><span>    I wish you$
</span></span><span style="display:flex;"><span> a very happy new         year$
</span></span><span style="display:flex;"><span>$
</span></span><span style="display:flex;"><span>$</span></span></code></pre></div>

<div class="expand">
    <div class="expand-label" style="cursor: pointer;" onclick="$h = $(this);$h.next('div').slideToggle(100,function () {$h.children('i').attr('class',function () {return $h.next('div').is(':visible') ? 'fas fa-chevron-down' : 'fas fa-chevron-right';});});">
        <i style="font-size:x-small;" class="fas fa-chevron-right"></i>
        <span>
        
    	
    	Implement the program that replaces tabulations with four spaces and removes spaces and tabulations just before the end of line.
    	
    	</span>
    </div>
    <div class="expand-content" style="display: none;">
        <p>The following <code>ocamllex</code> <a href="https://gist.github.com/lascar-pacagi/b3cff072c864e636e4a2416c1491a8fe">file</a> answers the question.</p>

    </div>
</div>
<h2 id="ressources">Ressources</h2>

<div class="notices info" ><p><a href="https://regexcrossword.com/">Play with regular expressions</a><br>
<a href="https://regex101.com/">Test regular expressions</a><br>
<a href="https://regex-generate.github.io/regenerate/">Generate test-cases for regular expressions</a><br>
<a href="https://cyberzhg.github.io/toolbox/min_dfa">Transform regular expressions into automata</a><br>
<a href="https://swtch.com/~rsc/regexp/regexp1.html">Russ Cox on regular expression matching</a><br>
<a href="https://ocaml.org/learn/">Learn OCaml</a><br>
<a href="https://try.ocamlpro.com/">Try OCaml</a><br>
<a href="https://www.cs.cornell.edu/courses/cs3110/2019fa/">Functional programming course using OCaml</a><br>
<a href="https://caml.inria.fr/pub/docs/manual-ocaml/">OCaml documentation</a><br>
<a href="https://caml.inria.fr/pub/docs/manual-ocaml/lexyacc.html#sec319">Ocamllex documentation</a><br>
<a href="http://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html#lexing-and-parsing">Ocamllex in Real World OCaml</a><br>
<a href="https://isocpp.org/">ISO C++</a><br>
<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ core guidelines</a><br>
<a href="http://www.open-std.org/jtc1/sc22/wg21/">C++ standard</a>\</p>
</div>

<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>The empty word is the equivalent of the string <code>&quot;&quot;</code>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>A regular expression must be of finite size.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><code>ndf</code> for <em>non-deterministic finite</em>.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>More precisely, we obtain a representation of the tokens.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


<footer class=" footline" >
	
</footer>


        
        </div> 
        

      </div>

    <div id="navigation">
        
        
        
        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                        
                    
                    

                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                    
                
                

                    
                    
                    

                    
            
        
                    
                        
            
            
                
                    
                        
                        
                    
                
                

                    
                    
                    

                    
            
        
                    
            
        
                    
            
        
                    
            
        
        
        


	 
	 
		
			<a class="nav nav-prev" href="/MrCoder/en/compiler/minijava/introduction/" title="Introduction"> <i class="fa fa-chevron-left"></i></a>
		
		
			<a class="nav nav-next" href="/MrCoder/en/compiler/minijava/parser/" title="Syntactic Analysis" style="margin-right: 0px;"><i class="fa fa-chevron-right"></i></a>
		
	
    </div>

    </section>
    
    <div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
      <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
    </div>
    <script src="/MrCoder/js/clipboard.min.js?1768208418"></script>
    <script src="/MrCoder/js/perfect-scrollbar.min.js?1768208418"></script>
    <script src="/MrCoder/js/perfect-scrollbar.jquery.min.js?1768208418"></script>
    <script src="/MrCoder/js/jquery.sticky.js?1768208418"></script>
    <script src="/MrCoder/js/featherlight.min.js?1768208418"></script>
    <script src="/MrCoder/js/html5shiv-printshiv.min.js?1768208418"></script>
    <script src="/MrCoder/js/highlight.pack.js?1768208418"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script src="/MrCoder/js/modernizr.custom-3.6.0.js?1768208418"></script>
    <script src="/MrCoder/js/learn.js?1768208418"></script>
    <script src="/MrCoder/js/hugo-learn.js?1768208418"></script>

    <link href="/MrCoder/mermaid/mermaid.css?1768208418" rel="stylesheet" />
    <script src="/MrCoder/mermaid/mermaid.js?1768208418"></script>
    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
    

  </body>
</html>

